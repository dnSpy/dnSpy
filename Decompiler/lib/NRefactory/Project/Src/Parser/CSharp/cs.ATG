using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Text;
using ICSharpCode.NRefactory.Parser;
using ICSharpCode.NRefactory.Ast;
using ASTAttribute = ICSharpCode.NRefactory.Ast.Attribute;
using Types = ICSharpCode.NRefactory.Ast.ClassType;

COMPILER CS    /* AW 2002-12-30 renamed from CompilationUnit to CS  */


/*------------------------------------------------------------------------*
 *----- LEXER TOKEN LIST  ------------------------------------------------*
 *------------------------------------------------------------------------*/

/* START AUTOGENERATED TOKENS SECTION */
TOKENS
	/* ----- terminal classes ----- */
	/* EOF is 0 */
	ident
	Literal

	/* ----- special character ----- */
	"="
	"+"
	"-"
	"*"
	"/"
	"%"
	":"
	"::"
	";"
	"?"
	"??"
	","
	"."
	"{"
	"}"
	"["
	"]"
	"("
	")"
	">"
	"<"
	"!"
	"&&"
	"||"
	"~"
	"&"
	"|"
	"^"
	"++"
	"--"
	"=="
	"!="
	">="
	"<="
	"<<"
	"+="
	"-="
	"*="
	"/="
	"%="
	"&="
	"|="
	"^="
	"<<="
	"->"
	"=>"

	/* ----- keywords ----- */
	"abstract"
	"as"
	"base"
	"bool"
	"break"
	"byte"
	"case"
	"catch"
	"char"
	"checked"
	"class"
	"const"
	"continue"
	"decimal"
	"default"
	"delegate"
	"do"
	"double"
	"else"
	"enum"
	"event"
	"explicit"
	"extern"
	"false"
	"finally"
	"fixed"
	"float"
	"for"
	"foreach"
	"goto"
	"if"
	"implicit"
	"in"
	"int"
	"interface"
	"internal"
	"is"
	"lock"
	"long"
	"namespace"
	"new"
	"null"
	"object"
	"operator"
	"out"
	"override"
	"params"
	"private"
	"protected"
	"public"
	"readonly"
	"ref"
	"return"
	"sbyte"
	"sealed"
	"short"
	"sizeof"
	"stackalloc"
	"static"
	"string"
	"struct"
	"switch"
	"this"
	"throw"
	"true"
	"try"
	"typeof"
	"uint"
	"ulong"
	"unchecked"
	"unsafe"
	"ushort"
	"using"
	"virtual"
	"void"
	"volatile"
	"while"
	"partial"
	"where"
	"get"
	"set"
	"add"
	"remove"
	"yield"
	"select"
	"group"
	"by"
	"into"
	"from"
	"ascending"
	"descending"
	"orderby"
	"let"
	"join"
	"on"
	"equals"
/* END AUTOGENERATED TOKENS SECTION */

/*------------------------------------------------------------------------*
 *----- PARSER -----------------------------------------------------------*
 *------------------------------------------------------------------------*/

PRODUCTIONS

/*--- compilation unit: */
CS
	(.
		lexer.NextToken(); // get the first token
		compilationUnit = new CompilationUnit();
		BlockStart(compilationUnit);
	.)
=
	{ ExternAliasDirective }
	{ UsingDirective }
	{ IF (IsGlobalAttrTarget()) GlobalAttributeSection }
	{ NamespaceMemberDecl }
	EOF
.

UsingDirective
(.
	string qualident = null; TypeReference aliasedType = null;
	string alias = null;
.)
=
	"using"                     (. Location startPos = t.Location; .)
	[ IF (IdentAndDoubleColon()) Identifier (. alias = t.val; .) "::" ]
	Qualident<out qualident>
	[ "=" NonArrayType<out aliasedType> ]
	";"                         (. 
	                               if (qualident != null && qualident.Length > 0) {
	                                 string name = (alias != null && alias != "global") ? alias + "." + qualident : qualident;
	                                 INode node;
	                                 if (aliasedType != null) {
	                                     node = new UsingDeclaration(name, aliasedType);
	                                 } else {
	                                     node = new UsingDeclaration(name);
	                                 }
	                                 node.StartLocation = startPos;
	                                 node.EndLocation   = t.EndLocation;
	                                 AddChild(node);
	                               }
	                            .)
.

GlobalAttributeSection
=
	"[" (. Location startPos = t.Location; .) Identifier
	                            (. if (t.val != "assembly" && t.val != "module") Error("global attribute target specifier (assembly or module) expected");
	                               string attributeTarget = t.val;
	                               List<ASTAttribute> attributes = new List<ASTAttribute>();
	                               ASTAttribute attribute;
	                            .)
	":" Attribute<out attribute> (. attributes.Add(attribute); .)
	{ IF (NotFinalComma()) "," Attribute<out attribute> (. attributes.Add(attribute); .)}
	[ "," ]
	"]"                         (. AttributeSection section = new AttributeSection {
	                                   AttributeTarget = attributeTarget,
	                                   Attributes = attributes,
	                                   StartLocation = startPos,
	                                   EndLocation = t.EndLocation
	                               };
	                               AddChild(section);
	                            .)
.

Attribute<out ASTAttribute attribute>
(. string qualident;
   string alias = null;
.)
=
	(. Location startPos = la.Location; .)
	[ IF (IdentAndDoubleColon())
		Identifier (. alias = t.val; .)
		"::"
	]
	Qualident<out qualident> 
	(. List<Expression> positional = new List<Expression>();
	   List<NamedArgumentExpression> named = new List<NamedArgumentExpression>();
	   string name = (alias != null && alias != "global") ? alias + "." + qualident : qualident;
	.)
	[ AttributeArguments<positional, named> ]
	(. attribute = new ASTAttribute(name, positional, named); 
	   attribute.StartLocation = startPos;
	   attribute.EndLocation = t.EndLocation;
	.)
.

AttributeArguments<List<Expression> positional, List<NamedArgumentExpression> named>
=
	"("
	[
		AttributeArgument<positional, named>
		{
			","
			AttributeArgument<positional, named>
		}
	]
	")"
.

AttributeArgument<List<Expression> positional, List<NamedArgumentExpression> named>
(. string name = null; bool isNamed = false; Expression expr; Location startLocation = la.Location; .)
=
	(
		IF (IsAssignment())          (. isNamed = true; .)
		Identifier                   (. name = t.val; .)
		"="
	|
		IF (IdentAndColon())
		Identifier                   (. name = t.val; .)
		":"
	| /* empty */
	)
	Expr<out expr>
	(.
		if (expr != null) {
			if (isNamed) {
				named.Add(new NamedArgumentExpression(name, expr) { StartLocation = startLocation, EndLocation = t.EndLocation });
			} else {
				if (named.Count > 0)
					Error("positional argument after named argument is not allowed");
				if (name != null)
					expr = new NamedArgumentExpression(name, expr) { StartLocation = startLocation, EndLocation = t.EndLocation };
				positional.Add(expr);
			}
		}
	.)
.

AttributeSection<out AttributeSection section>
(.
	string attributeTarget = "";
	List<ASTAttribute> attributes = new List<ASTAttribute>();
	ASTAttribute attribute;
	
.)
=
	"[" (. Location startPos = t.Location; .) /*--- attribute target specifier: */
	[ IF (IsLocalAttrTarget())
		( "event"                       (. attributeTarget = "event";.)
		| "return"                      (. attributeTarget = "return";.)
		| Identifier                    (. attributeTarget = t.val; .)
		) ":" 
	]
	/*--- attribute list: */
	Attribute<out attribute>            (. attributes.Add(attribute); .)
	{ IF (NotFinalComma()) "," Attribute<out attribute> (. attributes.Add(attribute); .)}
	[ "," ]
	"]"                         (. section = new AttributeSection {
	                                   AttributeTarget = attributeTarget,
	                                   Attributes = attributes,
	                                   StartLocation = startPos,
	                                   EndLocation = t.EndLocation
	                               };
	                            .)
.

NamespaceMemberDecl
(.
	AttributeSection section;
	List<AttributeSection> attributes = new List<AttributeSection>();
	ModifierList m = new ModifierList();
	string qualident;
.)
= /*--- namespace declaration: */
	"namespace"                  (. Location startPos = t.Location; .)
	Qualident<out qualident>     (. INode node =  new NamespaceDeclaration(qualident);
	                                node.StartLocation = startPos;
	                                AddChild(node);
	                                BlockStart(node);
	                              .)
	"{"
	{ ExternAliasDirective }
	{ UsingDirective }
	{ NamespaceMemberDecl }
	"}"
	[ ";" ]                       (. node.EndLocation   = t.EndLocation;
	                                 BlockEnd();
	                              .)
	/*--- type declaration: */
|	{ AttributeSection<out section> (. attributes.Add(section); .) }
	  { TypeModifier<m> }
	  TypeDecl<m, attributes>
.

ExternAliasDirective
(. ExternAliasDirective ead = new ExternAliasDirective { StartLocation = la.Location }; .)
=
	"extern"
	Identifier (. if (t.val != "alias") Error("Expected 'extern alias'."); .)
	Identifier (.  ead.Name = t.val; .)
	";" (. ead.EndLocation = t.EndLocation; .)
	(. AddChild(ead); .)
.

TypeDecl<ModifierList m, List<AttributeSection> attributes>
(.
	TypeReference type;
	List<TypeReference> names;
	List<ParameterDeclarationExpression> p = new List<ParameterDeclarationExpression>();
	string name;
	List<TemplateDefinition> templates;
.)
= /*--- class declaration: */      (. m.Check(Modifiers.Classes); .)
	"class"                        (. TypeDeclaration newType = new TypeDeclaration(m.Modifier, attributes);
	                                  templates = newType.Templates;
	                                  AddChild(newType);
	                                  BlockStart(newType);
	                                  newType.StartLocation = m.GetDeclarationLocation(t.Location);
	                                  
	                                  newType.Type = Types.Class;
	                                .)
	Identifier                      (. newType.Name = t.val; .)
	
	/* .NET 2.0 */
	[ TypeParameterList<templates> ]
	
	[ ClassBase<out names>          (. newType.BaseTypes = names; .) ]
	
	/* .NET 2.0 */
	{ TypeParameterConstraintsClause<templates> }
	
	(. newType.BodyStartLocation = t.EndLocation; .)
	"{"
	ClassBody
	"}"
	[ ";" ]                         (. newType.EndLocation = t.EndLocation; 
	                                   BlockEnd();
	                                .)
| /*--- struct declaration: */  (. m.Check(Modifiers.StructsInterfacesEnumsDelegates); .)
	( "struct"                      (. TypeDeclaration newType = new TypeDeclaration(m.Modifier, attributes);
	                                   templates = newType.Templates;
	                                   newType.StartLocation = m.GetDeclarationLocation(t.Location);
	                                   AddChild(newType);
	                                   BlockStart(newType);
	                                   newType.Type = Types.Struct; 
	                                 .)
	Identifier                       (. newType.Name = t.val; .)
	
	/* .NET 2.0 */
	[ TypeParameterList<templates> ]
	
	[ StructInterfaces<out names>    (. newType.BaseTypes = names; .) ]
	
	/* .NET 2.0 */
	{ TypeParameterConstraintsClause<templates> }
	
	
	(. newType.BodyStartLocation = t.EndLocation; .)
	StructBody
	[ ";" ]                          (. newType.EndLocation = t.EndLocation; 
	                                    BlockEnd();
	                                 .)
| /*--- interface declaration: */ 
	"interface"                      (. TypeDeclaration newType = new TypeDeclaration(m.Modifier, attributes);
	                                    templates = newType.Templates;
	                                    AddChild(newType);
	                                    BlockStart(newType);
	                                    newType.StartLocation = m.GetDeclarationLocation(t.Location);
	                                    newType.Type = Types.Interface;
	                                  .)
	Identifier                        (. newType.Name = t.val; .)
	
	/* .NET 2.0 */
	[ TypeParameterList<templates> ]
	
	[ InterfaceBase<out names>       (. newType.BaseTypes = names; .) ]
	
	/* .NET 2.0 */
	{ TypeParameterConstraintsClause<templates> }
	
	(. newType.BodyStartLocation = t.EndLocation; .)
	InterfaceBody
	[ ";" ]                          (. newType.EndLocation = t.EndLocation; 
	                                    BlockEnd();
	                                 .)
| /*--- enumeration declaration: */
	"enum"                           (. TypeDeclaration newType = new TypeDeclaration(m.Modifier, attributes);
	                                    AddChild(newType);
	                                    BlockStart(newType);
	                                    newType.StartLocation = m.GetDeclarationLocation(t.Location);
	                                    newType.Type = Types.Enum;
	                                  .)
	Identifier                       (. newType.Name = t.val; .)
	[ ":" IntegralType<out name>     (. newType.BaseTypes.Add(new TypeReference(name, true)); .)
	]
	(. newType.BodyStartLocation = t.EndLocation; .)
	EnumBody 
	[ ";" ]                          (. newType.EndLocation = t.EndLocation; 
	                                    BlockEnd();
	                                 .)
| /*--- delegate declaration: */
	"delegate"                       (. DelegateDeclaration delegateDeclr = new DelegateDeclaration(m.Modifier, attributes);
	                                    templates = delegateDeclr.Templates;
	                                    delegateDeclr.StartLocation = m.GetDeclarationLocation(t.Location);
	                                 .)
	( IF (NotVoidPointer()) "void"   (. delegateDeclr.ReturnType = new TypeReference("System.Void", true); .)
		| Type<out type>             (. delegateDeclr.ReturnType = type; .)
	)
	Identifier                       (. delegateDeclr.Name = t.val; .)
	
	/* .NET 2.0 */
	[ TypeParameterList<templates> ]
	
	"(" [ FormalParameterList<p> (. delegateDeclr.Parameters = p; .)
	] ")"
	
	/* .NET 2.0 */
	{ TypeParameterConstraintsClause<templates> }
	
	";"                              (. delegateDeclr.EndLocation = t.EndLocation;
	                                    AddChild(delegateDeclr);
	                                 .)
	)
.

Qualident<out string qualident>
=
	Identifier                          (. qualidentBuilder.Length = 0; qualidentBuilder.Append(t.val); .)
	{ IF (DotAndIdent()) "." Identifier (. qualidentBuilder.Append('.');
	                                      qualidentBuilder.Append(t.val); 
	                                    .)
	} (. qualident = qualidentBuilder.ToString(); .)
.

ClassBase<out List<TypeReference> names>
(.
	TypeReference typeRef;
	names = new List<TypeReference>();
.)
=
	":" ClassType<out typeRef, false>  (. if (typeRef != null) { names.Add(typeRef); } .)
	{ "," TypeName<out typeRef, false> (. if (typeRef != null) { names.Add(typeRef); } .) }
.

ClassBody
(. AttributeSection section; .)
=
	{                                  (.List<AttributeSection> attributes = new List<AttributeSection>();
		                                 ModifierList m = new ModifierList();
		                               .)
		SYNC
		{ AttributeSection<out section> (. attributes.Add(section); .) }
		MemberModifiers<m>
		ClassMemberDecl<m, attributes> 
	}
.

StructInterfaces<out List<TypeReference> names>
(.
	TypeReference typeRef;
	names = new List<TypeReference>();
.)
=
	":" TypeName<out typeRef, false>   (. if (typeRef != null) { names.Add(typeRef); } .)
	{ "," TypeName<out typeRef, false> (. if (typeRef != null) { names.Add(typeRef); } .) }
.

StructBody
(. AttributeSection section; .)
=
	"{"
	{                                    (.List<AttributeSection> attributes = new List<AttributeSection>();
		                                   ModifierList m = new ModifierList();
		                                 .)
		{ AttributeSection<out section>  (. attributes.Add(section); .) }
		MemberModifiers<m>
		StructMemberDecl<m, attributes> 
	}
	"}"
.

InterfaceBase<out List<TypeReference> names>
(.
	TypeReference typeRef;
	names = new List<TypeReference>();
.)
=
	":" TypeName<out typeRef, false>   (. if (typeRef != null) { names.Add(typeRef); } .)
	{ "," TypeName<out typeRef, false> (. if (typeRef != null) { names.Add(typeRef); } .) }
.

InterfaceBody
= "{"
  { SYNC InterfaceMemberDecl }
  "}"
.

EnumBody                                 (. FieldDeclaration f; .)
=
	"{"
	[ EnumMemberDecl<out f>          (. AddChild(f); .)
	{ IF (NotFinalComma()) ","
		EnumMemberDecl<out f> (. AddChild(f); .)
	}
	[","] ]
	"}"
.

Type<out TypeReference type>
=
	TypeWithRestriction<out type, true, false>
.

TypeWithRestriction<out TypeReference type, bool allowNullable, bool canBeUnbound>
(.
	Location startPos = la.Location;
	string name;
	int pointer = 0;
	type = null;
.)
=
	( ClassType<out type, canBeUnbound>
	| SimpleType<out name> (. type = new TypeReference(name, true); type.StartLocation = startPos; type.EndLocation = t.EndLocation; .)
	| "void" "*"                         (. pointer = 1; type = new TypeReference("System.Void", true); type.StartLocation = startPos; type.EndLocation = t.EndLocation; .)
	)                                    (. List<int> r = new List<int>(); .)
	
	[ IF (allowNullable && la.kind == Tokens.Question) NullableQuestionMark<ref type> ]
	
	{ IF (IsPointerOrDims())             (. int i = 0; .)
		( "*"                            (. ++pointer; .)
		| "[" { "," (. ++i; .) } "]"     (. r.Add(i); .)
		)
	}
	(. if (type != null) {
			type.RankSpecifier = r.ToArray();
			type.PointerNestingLevel = pointer;
			type.EndLocation = t.EndLocation;
			type.StartLocation = startPos;
		}
	.)
.


NonArrayType<out TypeReference type>
(.
	Location startPos = la.Location;
	string name;
	int pointer = 0;
	type = null;
.)
=
	( ClassType<out type, false>
	| SimpleType<out name> (. type = new TypeReference(name, true); .)
	| "void" "*"           (. pointer = 1; type = new TypeReference("System.Void", true); .)
	)
	
	[ NullableQuestionMark<ref type> ]
	
	{ IF (IsPointer())
		"*" (. ++pointer; .)
	}
	(.if (type != null) {
		type.PointerNestingLevel = pointer; 
		type.EndLocation = t.EndLocation;
		type.StartLocation = startPos;
		} 
	.)
.

SimpleType<out string name>
(. name = String.Empty; .)
=
	IntegralType<out name> 
	| "float"   (. name = "System.Single"; .)
	| "double"  (. name = "System.Double"; .)
	| "decimal" (. name = "System.Decimal"; .)
	| "bool"    (. name = "System.Boolean"; .)
.


FormalParameterList<List<ParameterDeclarationExpression> parameter>
(.
	
	ParameterDeclarationExpression p;
	AttributeSection section;
	List<AttributeSection> attributes = new List<AttributeSection>();
.)
=
	{ AttributeSection<out section> (.attributes.Add(section); .) }
	FixedParameter<out p> (. p.Attributes = attributes;
	                         parameter.Add(p);
	                      .)
	{
		","        (. attributes = new List<AttributeSection>(); .)
		{ AttributeSection<out section> (.attributes.Add(section); .) }
		FixedParameter<out p>        (. p.Attributes = attributes; parameter.Add(p); .)
	}
.

FixedParameter<out ParameterDeclarationExpression p>
(.
	TypeReference type;
	ParameterModifiers mod = ParameterModifiers.In;
	Location start = la.Location;
	Expression expr;
.)
=
	[
		"ref"    (. mod = ParameterModifiers.Ref; .)
		| "out"  (. mod = ParameterModifiers.Out; .)
		| "params" (. mod = ParameterModifiers.Params; .)
	]
	Type<out type>
	Identifier (. p = new ParameterDeclarationExpression(type, t.val, mod); .)
	[ "=" Expr<out expr> (. p.DefaultValue = expr; p.ParamModifier |= ParameterModifiers.Optional; .) ]
	(. p.StartLocation = start; p.EndLocation = t.EndLocation; .)
.

AccessorModifiers<out ModifierList m>
(. m = new ModifierList(); .)
=
	"private"          (. m.Add(Modifiers.Private, t.Location); .)
	| "protected"      (. m.Add(Modifiers.Protected, t.Location); .)
	  ["internal"      (. m.Add(Modifiers.Internal, t.Location); .)]
	| "internal"       (. m.Add(Modifiers.Internal, t.Location); .)
	  ["protected"     (. m.Add(Modifiers.Protected, t.Location); .)]
.

TypeModifier<ModifierList m>
=
	"new"                              (. m.Add(Modifiers.New, t.Location); .)
	| "public"                         (. m.Add(Modifiers.Public, t.Location); .)
	| "protected"                      (. m.Add(Modifiers.Protected, t.Location); .)
	| "internal"                       (. m.Add(Modifiers.Internal, t.Location); .)
	| "private"                        (. m.Add(Modifiers.Private, t.Location); .)
	| "unsafe"                         (. m.Add(Modifiers.Unsafe, t.Location); .)
	| "abstract"                       (. m.Add(Modifiers.Abstract, t.Location); .)
	| "sealed"                         (. m.Add(Modifiers.Sealed, t.Location); .)
	| "static"                         (. m.Add(Modifiers.Static, t.Location); .)
	| "partial"                        (. m.Add(Modifiers.Partial, t.Location); .)
.

ClassType<out TypeReference typeRef, bool canBeUnbound>
(. TypeReference r; typeRef = null; .)
=
	TypeName<out r, canBeUnbound> (. typeRef = r; .)
	| "object"                    (. typeRef = new TypeReference("System.Object", true); typeRef.StartLocation = t.Location; typeRef.EndLocation = t.EndLocation; .)
	| "string"                    (. typeRef = new TypeReference("System.String", true); typeRef.StartLocation = t.Location; typeRef.EndLocation = t.EndLocation; .)
.

IntegralType<out string name>          (. name = ""; .)
=
	"sbyte"                            (. name = "System.SByte"; .)
	| "byte"                           (. name = "System.Byte"; .)
	| "short"                          (. name = "System.Int16"; .)
	| "ushort"                         (. name = "System.UInt16"; .)
	| "int"                            (. name = "System.Int32"; .)
	| "uint"                           (. name = "System.UInt32"; .)
	| "long"                           (. name = "System.Int64"; .)
	| "ulong"                          (. name = "System.UInt64"; .)
	| "char"                           (. name = "System.Char"; .)
.

MemberModifiers<ModifierList m>
=
	{
	  "abstract"                       (. m.Add(Modifiers.Abstract, t.Location); .)
	| "extern"                         (. m.Add(Modifiers.Extern, t.Location); .)
	| "internal"                       (. m.Add(Modifiers.Internal, t.Location); .)
	| "new"                            (. m.Add(Modifiers.New, t.Location); .)
	| "override"                       (. m.Add(Modifiers.Override, t.Location); .)
	| "private"                        (. m.Add(Modifiers.Private, t.Location); .)
	| "protected"                      (. m.Add(Modifiers.Protected, t.Location); .)
	| "public"                         (. m.Add(Modifiers.Public, t.Location); .)
	| "readonly"                       (. m.Add(Modifiers.ReadOnly, t.Location); .)
	| "sealed"                         (. m.Add(Modifiers.Sealed, t.Location); .)
	| "static"                         (. m.Add(Modifiers.Static, t.Location); .)
	| "fixed"                          (. m.Add(Modifiers.Fixed, t.Location); .)
	| "unsafe"                         (. m.Add(Modifiers.Unsafe, t.Location); .)
	| "virtual"                        (. m.Add(Modifiers.Virtual, t.Location); .)
	| "volatile"                       (. m.Add(Modifiers.Volatile, t.Location); .)
	| "partial"                        (. m.Add(Modifiers.Partial, t.Location); .)
	}
.

StructMemberDecl<ModifierList m, List<AttributeSection> attributes>
(.
	string qualident = null;
	TypeReference type;
	Expression expr;
	List<ParameterDeclarationExpression> p = new List<ParameterDeclarationExpression>();
	BlockStatement stmt = null;
	List<TemplateDefinition> templates = new List<TemplateDefinition>();
	TypeReference explicitInterface = null;
	bool isExtensionMethod = false;
.)
=
	/*--- constant declaration: */         (. m.Check(Modifiers.Constants); .)
	"const"                                (.Location startPos = t.Location; .)
	Type<out type> Identifier              (. FieldDeclaration fd = new FieldDeclaration(attributes, type, m.Modifier | Modifiers.Const);
	                                          fd.StartLocation = m.GetDeclarationLocation(startPos);
	                                          VariableDeclaration f = new VariableDeclaration(t.val);
	                                          f.StartLocation = t.Location;
	                                          f.TypeReference = type;
	                                          SafeAdd(fd, fd.Fields, f);
	                                       .)
	"=" Expr<out expr>                     (. f.Initializer = expr; .)
	{ "," Identifier                       (. f = new VariableDeclaration(t.val);
	                                          f.StartLocation = t.Location;
	                                          f.TypeReference = type;
	                                          SafeAdd(fd, fd.Fields, f);
	                                       .)
		"=" Expr<out expr>                 (. f.EndLocation = t.EndLocation; f.Initializer = expr; .)
	} ";"                                  (. fd.EndLocation = t.EndLocation; AddChild(fd); .)
	
	
|   /*--- void method (procedure) declaration: */
	IF (NotVoidPointer())                (. m.Check(Modifiers.PropertysEventsMethods); .)
	"void"                                 (. Location startPos = t.Location; .)
	( IF (IsExplicitInterfaceImplementation())
		TypeName<out explicitInterface, false>
		(.if (la.kind != Tokens.Dot || Peek(1).kind != Tokens.This) {
			qualident = TypeReference.StripLastIdentifierFromType(ref explicitInterface);
		  } .)
	|	Identifier (. qualident = t.val; .)
	)
	/* .NET 2.0 */
	[ TypeParameterList<templates> ]
	
	"("
	[ "this" (. isExtensionMethod = true; /* C# 3.0 */ .) ]
	[ FormalParameterList<p> ] ")"
	(.	MethodDeclaration methodDeclaration = new MethodDeclaration {
			Name = qualident,
			Modifier = m.Modifier,
			TypeReference = new TypeReference("System.Void", true),
			Parameters = p,
			Attributes = attributes,
			StartLocation = m.GetDeclarationLocation(startPos),
			EndLocation = t.EndLocation,
			Templates = templates,
			IsExtensionMethod = isExtensionMethod
		};
		if (explicitInterface != null)
			SafeAdd(methodDeclaration, methodDeclaration.InterfaceImplementations, new InterfaceImplementation(explicitInterface, qualident));
		AddChild(methodDeclaration);
		BlockStart(methodDeclaration);
	.)
		
	/* .NET 2.0 */
	{ TypeParameterConstraintsClause<templates> }
	
	( Block<out stmt> | ";" )              (. BlockEnd();
	                                          methodDeclaration.Body  = (BlockStatement)stmt;
	                                       .)
	
|	/*--- event declaration: */     (. m.Check(Modifiers.PropertysEventsMethods); .)
		"event"                     
		(.	EventDeclaration eventDecl = new EventDeclaration {
				Modifier = m.Modifier, 
				Attributes = attributes,
				StartLocation = t.Location
			};
			AddChild(eventDecl);
			BlockStart(eventDecl);
			EventAddRegion addBlock = null;
			EventRemoveRegion removeBlock = null;
		.)
		Type<out type>        (. eventDecl.TypeReference = type; .)
		( IF (IsExplicitInterfaceImplementation())
			TypeName<out explicitInterface, false>
			(. qualident = TypeReference.StripLastIdentifierFromType(ref explicitInterface); .)
			(. eventDecl.InterfaceImplementations.Add(new InterfaceImplementation(explicitInterface, qualident)); .)
			
		|	Identifier (. qualident = t.val; .)
			[   "=" Expr<out expr> (. eventDecl.Initializer = expr; .) ]
			{	"," /* multiple event declarations on single line */
				/* our AST isn't built to handle this, so let's create multiple overlapping EventDeclarations */
				/* commit the current EventDeclaration */
				(. eventDecl.Name = qualident; eventDecl.EndLocation = t.EndLocation; BlockEnd(); .)
				/* create a new EventDeclaration for the next identifier */
				(. eventDecl = new EventDeclaration {
				      Modifier = eventDecl.Modifier,
				      Attributes = eventDecl.Attributes,
				      StartLocation = eventDecl.StartLocation,
				      TypeReference = eventDecl.TypeReference.Clone()
				   };
				   AddChild(eventDecl);
				   BlockStart(eventDecl);
				.)
				Identifier (. qualident = t.val; .)
				[ "=" Expr<out expr> (. eventDecl.Initializer = expr; .) ]
			}
		)
		(. eventDecl.Name = qualident; eventDecl.EndLocation = t.EndLocation; .)
		[	"{" (. eventDecl.BodyStart = t.Location; .)
			EventAccessorDecls<out addBlock, out removeBlock> 
			"}" (. eventDecl.BodyEnd   = t.EndLocation; .)
		]
		[ ";" ]
		(. BlockEnd();
		   eventDecl.AddRegion = addBlock;
		   eventDecl.RemoveRegion = removeBlock;
		.)
	
|   /*--- constructor or static contructor declaration: */
	IF (IdentAndLPar())                  (. m.Check(Modifiers.Constructors | Modifiers.StaticConstructors); .)
	Identifier (. string name = t.val; Location startPos = t.Location; .) "(" [  (. m.Check(Modifiers.Constructors); .)
	FormalParameterList<p>
	]
	")" (.ConstructorInitializer init = null;  .)
	[                                      (. m.Check(Modifiers.Constructors); .)
		ConstructorInitializer<out init>
	] (. 
	     ConstructorDeclaration cd = new ConstructorDeclaration(name, m.Modifier, p, init, attributes);
	     cd.StartLocation = startPos;
	     cd.EndLocation   = t.EndLocation;
	  .)
	
	( Block<out stmt> | ";" ) (. cd.Body = (BlockStatement)stmt; AddChild(cd); .)
	
	
|   /*--- conversion operator declaration: */   (. m.Check(Modifiers.Operators);
	                                          if (m.isNone) Error("at least one modifier must be set"); 
	                                          bool isImplicit = true;
	                                          Location startPos = Location.Empty;
	                                       .)
	( "implicit" (. startPos = t.Location; .) | "explicit" (. isImplicit = false; startPos = t.Location; .) ) 
	"operator" Type<out type> (. TypeReference operatorType = type; .) 
	"(" Type<out type> Identifier (. string varName = t.val; .) ")"
	(. Location endPos = t.Location; .)
	( Block<out stmt> | ";" (. stmt = null; .) )
	(.
		
		List<ParameterDeclarationExpression> parameters = new List<ParameterDeclarationExpression>();
		parameters.Add(new ParameterDeclarationExpression(type, varName));
		OperatorDeclaration operatorDeclaration = new OperatorDeclaration {
			Name = (isImplicit ? "op_Implicit" : "op_Explicit"),
			Modifier = m.Modifier,
			Attributes = attributes, 
			Parameters = parameters, 
			TypeReference = operatorType,
			ConversionType = isImplicit ? ConversionType.Implicit : ConversionType.Explicit,
			Body = (BlockStatement)stmt,
			StartLocation = m.GetDeclarationLocation(startPos),
			EndLocation = endPos
		};
		AddChild(operatorDeclaration);
	.)
	
	
|	/*--- inner type declaration: */
	TypeDecl<m, attributes>

|	Type<out type>                       (. Location startPos = t.Location;  .)
	(
		/*--- operator declaration: */     (. OverloadableOperatorType op;
		                                      m.Check(Modifiers.Operators);
		                                      if (m.isNone) Error("at least one modifier must be set");
		                                   .)
		"operator" OverloadableOperator<out op> (. TypeReference firstType, secondType = null; string secondName = null; .)
		"(" (. Location firstStart = la.Location, secondStart = Location.Empty, secondEnd = Location.Empty; .) Type<out firstType> Identifier (. string firstName = t.val; Location firstEnd = t.EndLocation; .)
		( "," (. secondStart = la.Location; .) Type<out secondType> Identifier (. secondName = t.val; secondEnd = t.EndLocation; .)        /* (. if (Tokens.OverloadableUnaryOp[op.kind] && !Tokens.OverloadableBinaryOp[op.kind])
		                                      Error("too many operands for unary operator"); 
		                                   .)*/
		| /* empty */                      /*(. if (Tokens.OverloadableBinaryOp[op.kind]){
		                                      	Error("too few operands for binary operator");
		                                      }
		                                   .)*/
		)
		(. Location endPos = t.Location; .)
		")" ( Block<out stmt> | ";" )
		(.
			if (op == OverloadableOperatorType.Add && secondType == null)
				op = OverloadableOperatorType.UnaryPlus;
			if (op == OverloadableOperatorType.Subtract && secondType == null)
				op = OverloadableOperatorType.UnaryMinus;
			OperatorDeclaration operatorDeclaration = new OperatorDeclaration {
				Modifier = m.Modifier,
				Attributes = attributes,
				TypeReference = type,
				OverloadableOperator = op,
				Name = GetReflectionNameForOperator(op),
				Body = (BlockStatement)stmt,
				StartLocation = m.GetDeclarationLocation(startPos),
				EndLocation = endPos
			};
			SafeAdd(operatorDeclaration, operatorDeclaration.Parameters, new ParameterDeclarationExpression(firstType, firstName) { StartLocation = firstStart, EndLocation = firstEnd });
			if (secondType != null) {
				SafeAdd(operatorDeclaration, operatorDeclaration.Parameters, new ParameterDeclarationExpression(secondType, secondName) { StartLocation = secondStart, EndLocation = secondEnd });
			}
			AddChild(operatorDeclaration);
		.)
		
		/*--- field declaration: */
	| IF (IsVarDecl())
	    (.	m.Check(Modifiers.Fields);
			FieldDeclaration fd = new FieldDeclaration(attributes, type, m.Modifier);
			fd.StartLocation = m.GetDeclarationLocation(startPos); 
		.)
		( IF (m.Contains(Modifiers.Fixed))
			VariableDeclarator<fd>
			"["
			Expr<out expr> (. if (fd.Fields.Count > 0)
								fd.Fields[fd.Fields.Count-1].FixedArrayInitialization = expr; .)
			"]"
			{	","
				VariableDeclarator<fd>
				"["
				Expr<out expr> (. if (fd.Fields.Count > 0)
									fd.Fields[fd.Fields.Count-1].FixedArrayInitialization = expr; .)
				"]"
			}
		|	/* non-fixed field */
			VariableDeclarator<fd>
			{ "," VariableDeclarator<fd> }
		)
		";" (. fd.EndLocation = t.EndLocation; AddChild(fd); .)
		
		/*--- unqualified indexer declaration (without interface name): */
		|                                  (. m.Check(Modifiers.Indexers); .)
		"this" "[" FormalParameterList<p> "]" (. Location endLocation = t.EndLocation; .) "{" (.
			         PropertyDeclaration indexer = new PropertyDeclaration(m.Modifier | Modifiers.Default, attributes, "Item", p);
			         indexer.StartLocation = startPos;
			         indexer.EndLocation   = endLocation;
			         indexer.BodyStart     = t.Location;
			         indexer.TypeReference = type;
			         PropertyGetRegion getRegion;
			         PropertySetRegion setRegion;
			       .) 
		AccessorDecls<out getRegion, out setRegion> "}" (. 
			          indexer.BodyEnd    = t.EndLocation;
			          indexer.GetRegion = getRegion;
			          indexer.SetRegion = setRegion;
			          AddChild(indexer);
			       .)
	|  IF (IsIdentifierToken(la))
		( IF (IsExplicitInterfaceImplementation())
			TypeName<out explicitInterface, false>
			(.if (la.kind != Tokens.Dot || Peek(1).kind != Tokens.This) {
				qualident = TypeReference.StripLastIdentifierFromType(ref explicitInterface);
			  } .)
		|	Identifier (. qualident = t.val; .)
		)
		(. Location qualIdentEndLocation = t.EndLocation; .)
		
		(
			/*--- "not void" method (function) declaration: */
			(                              (. m.Check(Modifiers.PropertysEventsMethods); .)
				/* .NET 2.0 */
				[ TypeParameterList<templates> ]
				"(" 
				[ "this" (. isExtensionMethod = true; .) ]
				[ FormalParameterList<p> ] ")"
				(.
					MethodDeclaration methodDeclaration = new MethodDeclaration {
						Name = qualident,
						Modifier = m.Modifier,
						TypeReference = type,
						Parameters = p, 
						Attributes = attributes
					};
					if (explicitInterface != null)
						methodDeclaration.InterfaceImplementations.Add(new InterfaceImplementation(explicitInterface, qualident));
					methodDeclaration.StartLocation = m.GetDeclarationLocation(startPos);
					methodDeclaration.EndLocation   = t.EndLocation;
					methodDeclaration.IsExtensionMethod = isExtensionMethod;
					methodDeclaration.Templates = templates;
					AddChild(methodDeclaration);
				                                       .)
				{ TypeParameterConstraintsClause<templates> }
				( Block<out stmt> | ";" ) (. methodDeclaration.Body  = (BlockStatement)stmt; .)
			
			/*--- property declaration: */  
			| "{" (. PropertyDeclaration pDecl = new PropertyDeclaration(qualident, type, m.Modifier, attributes); 
					 if (explicitInterface != null)
						pDecl.InterfaceImplementations.Add(new InterfaceImplementation(explicitInterface, qualident));
			         pDecl.StartLocation = m.GetDeclarationLocation(startPos);
			         pDecl.EndLocation   = qualIdentEndLocation;
			         pDecl.BodyStart   = t.Location;
			         PropertyGetRegion getRegion;
			         PropertySetRegion setRegion;
			      .)
			   AccessorDecls<out getRegion, out setRegion> 
			   "}" (. 
			          pDecl.GetRegion = getRegion;
			          pDecl.SetRegion = setRegion;
			          pDecl.BodyEnd = t.EndLocation;
			          AddChild(pDecl);
			       .)
			)
			
			/*--- qualified indexer declaration (with interface name): */
			|                              (. m.Check(Modifiers.Indexers); .)
			"." "this" "[" FormalParameterList<p> "]" (.
			         PropertyDeclaration indexer = new PropertyDeclaration(m.Modifier | Modifiers.Default, attributes, "Item", p);
			         indexer.StartLocation = m.GetDeclarationLocation(startPos);
			         indexer.EndLocation   = t.EndLocation;
			         indexer.TypeReference = type;
			         if (explicitInterface != null)
						SafeAdd(indexer, indexer.InterfaceImplementations, new InterfaceImplementation(explicitInterface, "this"));
			         PropertyGetRegion getRegion;
			         PropertySetRegion setRegion;
			       .) 
			  "{" (. Location bodyStart = t.Location; .)
			  AccessorDecls<out getRegion, out setRegion> 
			  "}"  (. indexer.BodyStart = bodyStart;
			          indexer.BodyEnd   = t.EndLocation;
			          indexer.GetRegion = getRegion;
			          indexer.SetRegion = setRegion;
			          AddChild(indexer);
			       .)
		)
	)
.

ClassMemberDecl<ModifierList m, List<AttributeSection> attributes>
(. BlockStatement stmt = null; .)
=
	StructMemberDecl<m, attributes>
	| /*--- destructor declaration: */ (. m.Check(Modifiers.Destructors); Location startPos = la.Location; .)
	"~" Identifier                     (. DestructorDeclaration d = new DestructorDeclaration(t.val, m.Modifier, attributes); 
	                                      d.Modifier = m.Modifier;
	                                      d.StartLocation = m.GetDeclarationLocation(startPos);
	                                   .)
	"(" ")" (. d.EndLocation = t.EndLocation; .) ( Block<out stmt> | ";" )  (. 
	                                      d.Body = stmt;
	                                      AddChild(d);
	                                   .)
.

InterfaceMemberDecl
(.
	TypeReference type;
	
	AttributeSection section;
	Modifiers mod = Modifiers.None;
	List<AttributeSection> attributes = new List<AttributeSection>();
	List<ParameterDeclarationExpression> parameters = new List<ParameterDeclarationExpression>();
	string name;
	PropertyGetRegion getBlock;
	PropertySetRegion setBlock;
	Location startLocation = new Location(-1, -1);
	List<TemplateDefinition> templates = new List<TemplateDefinition>();
.)
=
	{ AttributeSection<out section>     (. attributes.Add(section); .)}
	[ "new" (. mod = Modifiers.New; startLocation = t.Location; .) ]
	(
		/*--- interface void method (procedure) declaration: */
		IF (NotVoidPointer()) "void" (. if (startLocation.IsEmpty) startLocation = t.Location; .)
		Identifier (. name = t.val; .)
		[ TypeParameterList<templates> ]
		"(" [ FormalParameterList<parameters> ] ")"
		{ TypeParameterConstraintsClause<templates> }
		";"
		(.  MethodDeclaration md = new MethodDeclaration {
				Name = name, Modifier = mod, TypeReference = new TypeReference("System.Void", true), 
				Parameters = parameters, Attributes = attributes, Templates = templates,
				StartLocation = startLocation, EndLocation = t.EndLocation
			};
			AddChild(md);
		.)
		| (
			Type<out type> (. if (startLocation.IsEmpty) startLocation = t.Location; .)
			(
				Identifier            (. name = t.val; Location qualIdentEndLocation = t.EndLocation; .)
				(
					/*--- interface "not void" method (function) declaration: */
					/* .NET 2.0 */
					[ TypeParameterList<templates> ]
					"(" [ FormalParameterList<parameters> ] ")" 
					/* .NET 2.0 */
					{ TypeParameterConstraintsClause<templates> }
					";" (.  MethodDeclaration md = new MethodDeclaration {
								Name = name, Modifier = mod, TypeReference = type,
								Parameters = parameters, Attributes = attributes, Templates = templates,
								StartLocation = startLocation, EndLocation = t.EndLocation
							};
							AddChild(md);
						.)
					/*--- interface property declaration: */
					|
						(. PropertyDeclaration pd = new PropertyDeclaration(name, type, mod, attributes);
						   AddChild(pd); .)
						"{"
							(. Location bodyStart = t.Location;.)
							InterfaceAccessors<out getBlock, out setBlock>
						"}" (. pd.GetRegion = getBlock; pd.SetRegion = setBlock; pd.StartLocation = startLocation; pd.EndLocation = qualIdentEndLocation; pd.BodyStart = bodyStart; pd.BodyEnd = t.EndLocation; .)
				)
				/*--- interface indexer declaration: */
			|	"this" "[" FormalParameterList<parameters> "]"
				(. Location bracketEndLocation = t.EndLocation; .)
				(. PropertyDeclaration id = new PropertyDeclaration(mod | Modifiers.Default, attributes, "Item", parameters);
					id.TypeReference = type;
				   AddChild(id); .)
				"{" (. Location bodyStart = t.Location;.)
				InterfaceAccessors<out getBlock, out setBlock>
				"}"
				(. id.GetRegion = getBlock; id.SetRegion = setBlock; id.StartLocation = startLocation;  id.EndLocation = bracketEndLocation; id.BodyStart = bodyStart; id.BodyEnd = t.EndLocation;.)
			)
			/*--- interface event declaration: */
			|	"event" (. if (startLocation.IsEmpty) startLocation = t.Location; .)
				Type<out type> Identifier
				(.	EventDeclaration ed = new EventDeclaration {
						TypeReference = type, Name = t.val, Modifier = mod, Attributes = attributes
					};
					AddChild(ed);
				.)
			";"
			(. ed.StartLocation = startLocation; ed.EndLocation = t.EndLocation; .)
		)
	)
.

EnumMemberDecl<out FieldDeclaration f>
(.
	Expression expr = null;
	List<AttributeSection> attributes = new List<AttributeSection>();
	AttributeSection section = null;
	VariableDeclaration varDecl = null;
.)
=
	{ AttributeSection<out section> (. attributes.Add(section); .) }
	Identifier                      (. f = new FieldDeclaration(attributes);
	                                   varDecl         = new VariableDeclaration(t.val);
	                                   f.Fields.Add(varDecl);
	                                   f.StartLocation = t.Location;
	                                   f.EndLocation = t.EndLocation;
	                                .)
	[ "=" Expr<out expr> (. varDecl.Initializer = expr; .) ]
.


AccessorDecls<out PropertyGetRegion getBlock, out PropertySetRegion setBlock>
(.
	List<AttributeSection> attributes = new List<AttributeSection>(); 
	AttributeSection section;
	getBlock = null;
	setBlock = null; 
	ModifierList modifiers = null;
.)
=
	{ AttributeSection<out section> (. attributes.Add(section); .) }
	[ AccessorModifiers<out modifiers> ]
	(
			GetAccessorDecl<out getBlock, attributes>
			(. if (modifiers != null) {getBlock.Modifier = modifiers.Modifier; } .)
			[  (. attributes = new List<AttributeSection>(); modifiers = null; .)
				{ AttributeSection<out section> (. attributes.Add(section); .) }
				[ AccessorModifiers<out modifiers> ]
				SetAccessorDecl<out setBlock, attributes>
				(. if (modifiers != null) {setBlock.Modifier = modifiers.Modifier; } .)
			]
		|
			SetAccessorDecl<out setBlock, attributes>
			(. if (modifiers != null) {setBlock.Modifier = modifiers.Modifier; } .)
			[  (. attributes = new List<AttributeSection>(); modifiers = null; .)
				{ AttributeSection<out section> (. attributes.Add(section); .) }
				[ AccessorModifiers<out modifiers> ]
				GetAccessorDecl<out getBlock, attributes>
				(. if (modifiers != null) {getBlock.Modifier = modifiers.Modifier; } .)
			]
		| Identifier (. Error("get or set accessor declaration expected"); .)
	)
.

GetAccessorDecl<out PropertyGetRegion getBlock, List<AttributeSection> attributes>
(. BlockStatement stmt = null; .)
=
	"get"
	(. Location startLocation = t.Location; .)
	( Block<out stmt> | ";" )
	(. getBlock = new PropertyGetRegion(stmt, attributes); .)
	(. getBlock.StartLocation = startLocation; getBlock.EndLocation = t.EndLocation; .)
.

SetAccessorDecl<out PropertySetRegion setBlock, List<AttributeSection> attributes>
(. BlockStatement stmt = null; .)
=
	"set"
	(. Location startLocation = t.Location; .)
	( Block<out stmt> | ";" )
	(. setBlock = new PropertySetRegion(stmt, attributes); .)
	(. setBlock.StartLocation = startLocation; setBlock.EndLocation = t.EndLocation; .)
.

EventAccessorDecls<out EventAddRegion addBlock, out EventRemoveRegion removeBlock>
(. AttributeSection section;
   List<AttributeSection> attributes = new List<AttributeSection>();
   BlockStatement stmt;
   addBlock = null;
   removeBlock = null;
.)
=
	{ AttributeSection<out section> (. attributes.Add(section); .) }
	(
		                                    (. addBlock = new EventAddRegion(attributes); .)
			AddAccessorDecl<out stmt>       (. attributes = new List<AttributeSection>(); addBlock.Block = stmt; .)
			{ AttributeSection<out section> (. attributes.Add(section); .)}
			RemoveAccessorDecl<out stmt>    (. removeBlock = new EventRemoveRegion(attributes); removeBlock.Block = stmt; .)
		|
			RemoveAccessorDecl <out stmt>    (. removeBlock = new EventRemoveRegion(attributes); removeBlock.Block = stmt; attributes = new List<AttributeSection>(); .)
			{ AttributeSection<out section>  (. attributes.Add(section); .) }
			AddAccessorDecl<out stmt>        (. addBlock = new EventAddRegion(attributes); addBlock.Block = stmt; .)
	)
.

InterfaceAccessors<out PropertyGetRegion getBlock, out PropertySetRegion setBlock>
(.
	AttributeSection section;
	List<AttributeSection> attributes = new List<AttributeSection>();
	getBlock = null; setBlock = null;
	PropertyGetSetRegion lastBlock = null;
.)
=
	{ AttributeSection<out section> (. attributes.Add(section); .) }
	(. Location startLocation = la.Location; .)
	(
		"get"   (. getBlock = new PropertyGetRegion(null, attributes); .)
		| "set" (. setBlock = new PropertySetRegion(null, attributes); .)
	)
	";"
	(. if (getBlock != null) { getBlock.StartLocation = startLocation; getBlock.EndLocation = t.EndLocation; }
	   if (setBlock != null) { setBlock.StartLocation = startLocation; setBlock.EndLocation = t.EndLocation; }
	   attributes = new List<AttributeSection>(); .)
	[
		{ AttributeSection<out section> (. attributes.Add(section); .) }
		(. startLocation = la.Location; .)
		(
			"get"   (. if (getBlock != null) Error("get already declared");
			                             else { getBlock = new PropertyGetRegion(null, attributes); lastBlock = getBlock; }
			                          .)
			| "set" (. if (setBlock != null) Error("set already declared");
			                             else { setBlock = new PropertySetRegion(null, attributes); lastBlock = setBlock; }
			                          .)
		)
		";"
		(. if (lastBlock != null) { lastBlock.StartLocation = startLocation; lastBlock.EndLocation = t.EndLocation; } .)
	]
.

VariableDeclarator<FieldDeclaration parentFieldDeclaration>
(. Expression expr = null; .)
=
	Identifier                            (. VariableDeclaration f = new VariableDeclaration(t.val); f.StartLocation = t.Location; .)
	[ "=" VariableInitializer<out expr>   (. f.Initializer = expr; .) ]
	(. f.EndLocation = t.EndLocation; SafeAdd(parentFieldDeclaration, parentFieldDeclaration.Fields, f); .)
.

Block<out BlockStatement stmt>
=
	"{" (. BlockStatement blockStmt = new BlockStatement();
	       blockStmt.StartLocation = t.Location;
	       BlockStart(blockStmt);
	       if (!ParseMethodBodies) lexer.SkipCurrentBlock(0);
	    .)
	{ Statement }
	SYNC "}"
	    (.
	       stmt = blockStmt;
	       blockStmt.EndLocation = t.EndLocation;
	       BlockEnd();
	    .)
.

AddAccessorDecl<out BlockStatement stmt>
(.stmt = null;.) 
=
	"add"
	Block<out stmt>
.

RemoveAccessorDecl<out BlockStatement stmt>
(.stmt = null;.) 
=
	"remove"
	Block<out stmt>
.

ConstructorInitializer<out ConstructorInitializer ci>
(. Expression expr; ci = new ConstructorInitializer(); .)
=
	":"
	(
		"base" (. ci.ConstructorInitializerType = ConstructorInitializerType.Base; .)
		| "this"  (. ci.ConstructorInitializerType = ConstructorInitializerType.This; .)
	) 
	"("
	[ Argument<out expr> (. SafeAdd(ci, ci.Arguments, expr); .) 
	  { "," Argument<out expr> (. SafeAdd(ci, ci.Arguments, expr); .) }
	]
	")"
.

VariableInitializer<out Expression initializerExpression>
(. TypeReference type = null; Expression expr = null; initializerExpression = null; .)
=
	Expr<out initializerExpression>
	| CollectionInitializer<out initializerExpression>
	| "stackalloc" Type<out type> "[" Expr<out expr> "]" (. initializerExpression = new StackAllocExpression(type, expr); .)
.

OverloadableOperator<out OverloadableOperatorType op>
(. op = OverloadableOperatorType.None; .)
=
	"+"      (. op = OverloadableOperatorType.Add; .)
	| "-"    (. op = OverloadableOperatorType.Subtract; .)
	
	| "!"    (. op = OverloadableOperatorType.Not; .)
	| "~"    (. op = OverloadableOperatorType.BitNot; .)
	
	| "++"   (. op = OverloadableOperatorType.Increment; .)
	| "--"   (. op = OverloadableOperatorType.Decrement; .)
	
	| "true"   (. op = OverloadableOperatorType.IsTrue; .)
	| "false"   (. op = OverloadableOperatorType.IsFalse; .)
	
	| "*"    (. op = OverloadableOperatorType.Multiply; .)
	| "/"    (. op = OverloadableOperatorType.Divide; .)
	| "%"    (. op = OverloadableOperatorType.Modulus; .)
	
	| "&"    (. op = OverloadableOperatorType.BitwiseAnd; .)
	| "|"    (. op = OverloadableOperatorType.BitwiseOr; .)
	| "^"    (. op = OverloadableOperatorType.ExclusiveOr; .)
	
	| "<<"   (. op = OverloadableOperatorType.ShiftLeft; .)
	| "=="   (. op = OverloadableOperatorType.Equality; .)
	| "!="    (. op = OverloadableOperatorType.InEquality; .)
	| "<"     (. op = OverloadableOperatorType.LessThan; .)
	| ">="    (. op = OverloadableOperatorType.GreaterThanOrEqual; .)
	| "<="    (. op = OverloadableOperatorType.LessThanOrEqual; .)
	| ">"     (. op = OverloadableOperatorType.GreaterThan; .) [ ">" (. op = OverloadableOperatorType.ShiftRight; .) ]
.

Argument<out Expression argumentexpr>
(. argumentexpr = null; .)
=
	IF (IdentAndColon())
	(. Token ident; Expression expr; .)
	Identifier (. ident = t; .)
	":"
	ArgumentValue<out expr>
	(. argumentexpr = new NamedArgumentExpression(ident.val, expr) { StartLocation = ident.Location, EndLocation = t.EndLocation }; .)

|	ArgumentValue<out argumentexpr>
.

ArgumentValue<out Expression argumentexpr>
(.
	Expression expr;
	FieldDirection fd = FieldDirection.None;
.)
=
	[
		"ref" (. fd = FieldDirection.Ref; .)
		| "out" (. fd = FieldDirection.Out; .)
	]
	Expr<out expr>
	(. argumentexpr = fd != FieldDirection.None ? argumentexpr = new DirectionExpression(fd, expr) : expr; .)
.

AssignmentOperator<out AssignmentOperatorType op>
(. op = AssignmentOperatorType.None; .)
=
	"="     (. op = AssignmentOperatorType.Assign; .)
	| "+="  (. op = AssignmentOperatorType.Add; .)
	| "-="  (. op = AssignmentOperatorType.Subtract; .)
	| "*="  (. op = AssignmentOperatorType.Multiply; .)
	| "/="  (. op = AssignmentOperatorType.Divide; .)
	| "%="  (. op = AssignmentOperatorType.Modulus; .)
	| "&="  (. op = AssignmentOperatorType.BitwiseAnd; .)
	| "|="  (. op = AssignmentOperatorType.BitwiseOr; .)
	| "^="  (. op = AssignmentOperatorType.ExclusiveOr; .)
	| "<<=" (. op = AssignmentOperatorType.ShiftLeft; .)
	| IF (la.kind == Tokens.GreaterThan && Peek(1).kind == Tokens.GreaterEqual)
		">" ">=" (. op = AssignmentOperatorType.ShiftRight; .)
.

CollectionInitializer<out Expression outExpr>
(.
	Expression expr = null;
	CollectionInitializerExpression initializer = new CollectionInitializerExpression();
.)
=
	"{" (. initializer.StartLocation = t.Location; .)
	[	VariableInitializer<out expr>
		(. SafeAdd(initializer, initializer.CreateExpressions, expr); .)
		{ IF (NotFinalComma())
			"," VariableInitializer<out expr>
			(. SafeAdd(initializer, initializer.CreateExpressions, expr); .)
		}
		[ "," ]
	]
	"}" (. initializer.EndLocation = t.Location; outExpr = initializer; .)
.

CollectionOrObjectInitializer<out Expression outExpr>
(.
	Expression expr = null;
	CollectionInitializerExpression initializer = new CollectionInitializerExpression();
.)
=
	"{" (. initializer.StartLocation = t.Location; .)
	[	ObjectPropertyInitializerOrVariableInitializer<out expr>
		(. SafeAdd(initializer, initializer.CreateExpressions, expr); .)
		{ IF (NotFinalComma())
			"," ObjectPropertyInitializerOrVariableInitializer<out expr>
			(. SafeAdd(initializer, initializer.CreateExpressions, expr); .)
		}
		[ "," ]
	]
	"}" (. initializer.EndLocation = t.Location; outExpr = initializer; .)
.

ObjectPropertyInitializerOrVariableInitializer<out Expression expr>
(. expr = null; .)
=
( IF (IdentAndAsgn())
	Identifier
	(. MemberInitializerExpression mie = new MemberInitializerExpression(t.val, null);
	   mie.StartLocation = t.Location;
	   mie.IsKey = true;
	   Expression r = null; .)
	"=" 
	( CollectionOrObjectInitializer<out r>
	| VariableInitializer<out r> )
	(. mie.Expression = r; mie.EndLocation = t.EndLocation; expr = mie; .)
	
|	VariableInitializer <out expr>
)
.

LocalVariableDecl<out Statement stmt>
(.
	TypeReference type;
	VariableDeclaration      var = null;
	LocalVariableDeclaration localVariableDeclaration; 
	Location startPos = la.Location;
.)
=
	Type<out type> (. localVariableDeclaration = new LocalVariableDeclaration(type); localVariableDeclaration.StartLocation = startPos; .)
	LocalVariableDeclarator<out var> (. SafeAdd(localVariableDeclaration, localVariableDeclaration.Variables, var); .)
	{ "," LocalVariableDeclarator<out var> (. SafeAdd(localVariableDeclaration, localVariableDeclaration.Variables, var); .) }
	(. stmt = localVariableDeclaration; stmt.EndLocation = t.EndLocation; .)
.

LocalVariableDeclarator<out VariableDeclaration var>
(. Expression expr = null; .)
=
	Identifier (. var = new VariableDeclaration(t.val); var.StartLocation = t.Location; .)
	[ "=" VariableInitializer<out expr> (. var.Initializer = expr; .) ]
	(. var.EndLocation = t.EndLocation; .)
.

Statement
(.
	Statement stmt = null;
	Location startPos = la.Location;
.)
=
	SYNC
	(
		/*--- labeled statement: */
		IF (IsLabel()) Identifier (. AddChild(new LabelStatement(t.val)); .)
		":" Statement
		/*--- local constant declaration: */
	|	"const"
		LocalVariableDecl<out stmt>
		(. if (stmt != null) { ((LocalVariableDeclaration)stmt).Modifier |= Modifiers.Const; } .)
		";" (. AddChild(stmt); .)
		/*--- local variable declaration: */
	|	IF (IsLocalVarDecl()) LocalVariableDecl<out stmt> ";" (. AddChild(stmt); .)
	
	|	EmbeddedStatement<out stmt> (. AddChild(stmt); .)
		/* LL(1) confict: LocalVariableDecl *
		 *            <-> StatementExpr     *
		 * ident {"." ident} { "[" Expr ... */
	)
	(.
		if (stmt != null) {
			stmt.StartLocation = startPos;
			stmt.EndLocation = t.EndLocation;
		}
	.)
.

EmbeddedStatement<out Statement statement>
(.
	TypeReference type = null;
	Expression expr = null;
	Statement embeddedStatement = null;
	BlockStatement block = null;
	statement = null;
.)
=
	(. Location startLocation = la.Location; .)
	(
		Block<out block> (. statement = block; .)
	
		/*--- empty statement: */
	|	";"                       (. statement = new EmptyStatement(); .)
	
		/*--- checked / unchecked statement: */
	|	IF (UnCheckedAndLBrace()) (. bool isChecked = true; .)
		("checked" | "unchecked"    (. isChecked = false;.) )
		Block<out block>            (. statement = isChecked ? (Statement)new CheckedStatement(block) : (Statement)new UncheckedStatement(block); .)
	
		/*--- selection statements (if, switch): */
	|	IfStatement<out statement>
	
	|	"switch" (. List<SwitchSection> switchSections = new List<SwitchSection>(); .)
		  "(" Expr<out expr> ")"
		  "{" SwitchSections<switchSections>
		  "}"
		(. statement = new SwitchStatement(expr, switchSections); .)
		
		/*--- iteration statements (while, do, for, foreach): */
	|	"while" "(" Expr<out expr> ")"
		EmbeddedStatement<out embeddedStatement>
		(. statement = new DoLoopStatement(expr, embeddedStatement, ConditionType.While, ConditionPosition.Start);.)
	
	|	"do" EmbeddedStatement<out embeddedStatement> "while"
		"(" Expr<out expr> ")" ";" 
		(. statement = new DoLoopStatement(expr, embeddedStatement, ConditionType.While, ConditionPosition.End); .)
	
	|	"for" (. List<Statement> initializer = null; List<Statement> iterator = null; .)
		  "(" [ ForInitializer<out initializer> ] ";"
		  [ Expr<out expr> ] ";"
		  [ ForIterator<out iterator> ] ")"
		  EmbeddedStatement<out embeddedStatement> 
		  (. statement = new ForStatement(initializer, expr, iterator, embeddedStatement); .)
	
	|	"foreach" "(" Type<out type> Identifier   (. string varName = t.val; .)
		"in" Expr<out expr> ")"
		EmbeddedStatement<out embeddedStatement>
		(.  statement = new ForeachStatement(type, varName , expr, embeddedStatement); .)
	
		/*--- jump statements (break, contine, goto, return, throw): */
	|	"break" ";"               (. statement = new BreakStatement(); .)
	|	"continue" ";"            (. statement = new ContinueStatement(); .)
	|	GotoStatement<out statement>
	
	|	IF (IsYieldStatement()) "yield"
		( "return" Expr<out expr> (. statement = new YieldStatement(new ReturnStatement(expr)); .)
		| "break" (. statement = new YieldStatement(new BreakStatement()); .) )
		";"
	
	|	"return" [ Expr<out expr> ] ";"    (. statement = new ReturnStatement(expr); .)
	|	"throw" [ Expr<out expr> ] ";"     (. statement = new ThrowStatement(expr); .)
	  
		/*--- expression statement: */
	|	StatementExpr<out statement> SYNC ";"
	
		/*--- try statement: */
	|	TryStatement<out statement>
	
		/*--- lock satement: */
	|	"lock" "(" Expr<out expr> ")"
		EmbeddedStatement<out embeddedStatement> (. statement = new LockStatement(expr, embeddedStatement); .)
	
		/*--- using statement: */
	|	(.Statement resourceAcquisitionStmt = null; .)
		"using" "("
		ResourceAcquisition<out resourceAcquisitionStmt> ")"
		EmbeddedStatement<out embeddedStatement> (. statement = new UsingStatement(resourceAcquisitionStmt, embeddedStatement); .)
	
		/*--- unsafe statement: */
	|	"unsafe" Block<out block>  (. statement = new UnsafeStatement(block); .)
		/*--- fixed statement: */
	|	(. Statement pointerDeclarationStmt = null; .)
		"fixed" "("  
		ResourceAcquisition<out pointerDeclarationStmt> ")"
		EmbeddedStatement<out embeddedStatement>  (. statement = new FixedStatement(pointerDeclarationStmt, embeddedStatement); .)
	)
	(.	if (statement != null) {
			statement.StartLocation = startLocation;
			statement.EndLocation = t.EndLocation;
		}
	.)
.

IfStatement<out Statement statement>
(.
	Expression expr = null;
	Statement embeddedStatement = null;
	statement = null;
.)
=
	"if"
	"(" Expr<out expr> ")"
	EmbeddedStatement<out embeddedStatement>
	(. Statement elseStatement = null; .)
	[ "else" EmbeddedStatement<out elseStatement> ]
	(. statement = elseStatement != null ? new IfElseStatement(expr, embeddedStatement, elseStatement) : new IfElseStatement(expr, embeddedStatement); .)
	(. if (elseStatement is IfElseStatement && (elseStatement as IfElseStatement).TrueStatement.Count == 1) {
		/* else if-section (otherwise we would have a BlockStatment) */
		(statement as IfElseStatement).ElseIfSections.Add(
		             new ElseIfSection((elseStatement as IfElseStatement).Condition,
		                               (elseStatement as IfElseStatement).TrueStatement[0]));
		(statement as IfElseStatement).ElseIfSections.AddRange((elseStatement as IfElseStatement).ElseIfSections);
		(statement as IfElseStatement).FalseStatement = (elseStatement as IfElseStatement).FalseStatement;
		}
	.)
.

ForInitializer<out List<Statement> initializer>
(.
	Statement stmt; 
	initializer = new List<Statement>();
.)
=
	IF (IsLocalVarDecl()) LocalVariableDecl<out stmt> (. initializer.Add(stmt);.)
	| StatementExpr<out stmt> (.initializer.Add(stmt);.) { "," StatementExpr<out stmt> (. initializer.Add(stmt);.) }
.

ForIterator<out List<Statement> iterator>
(.
	Statement stmt; 
	iterator = new List<Statement>();
.)
=
	StatementExpr<out stmt> (. iterator.Add(stmt);.) { "," StatementExpr<out stmt> (. iterator.Add(stmt); .) }
.

SwitchSections<List<SwitchSection> switchSections>
(.
	SwitchSection switchSection = new SwitchSection();
	CaseLabel label;
.)
=
	SwitchLabel<out label> (. SafeAdd(switchSection, switchSection.SwitchLabels, label); .) 
	(. BlockStart(switchSection); .)
	{
		( SwitchLabel<out label>
		  (. if (label != null) {
		  		if (switchSection.Children.Count > 0) {
		  			// open new section
		  			BlockEnd(); switchSections.Add(switchSection);
		  			switchSection = new SwitchSection();
		  			BlockStart(switchSection);
		  		}
		  		SafeAdd(switchSection, switchSection.SwitchLabels, label);
		  	 }
		  .)
		| Statement)
	}
	(. BlockEnd(); switchSections.Add(switchSection); .)
.

SwitchLabel<out CaseLabel label>
 (. Expression expr = null; label = null; .)
=
	"case" Expr<out expr> ":" (. label =  new CaseLabel(expr); .)
	| "default" ":" (. label =  new CaseLabel(); .)
.

TryStatement<out Statement tryStatement>
(.
	BlockStatement blockStmt = null, finallyStmt = null;
	CatchClause catchClause = null;
	List<CatchClause> catchClauses = new List<CatchClause>();
.)
=
	"try"  Block<out blockStmt>
	{
		CatchClause<out catchClause>
		(. if (catchClause != null) catchClauses.Add(catchClause); .)
	}
	[ "finally" Block<out finallyStmt> ]
	(.
		tryStatement = new TryCatchStatement(blockStmt, catchClauses, finallyStmt);
		if (catchClauses != null) {
			foreach (CatchClause cc in catchClauses) cc.Parent = tryStatement;
		}
	.)
.

CatchClause<out CatchClause catchClause>
=
	"catch" (. string identifier;
	           BlockStatement stmt;
	           TypeReference typeRef;
	           Location startPos = t.Location;
	           catchClause = null;
	        .)
	(
		/*--- general catch clause */
		Block<out stmt> (. catchClause = new CatchClause(stmt);  .)
		
		/*--- specific catch clause */
		| "(" ClassType<out typeRef, false> (. identifier = null; .)
			[ Identifier (. identifier = t.val; .) ]
		   ")" Block<out stmt> 
		   (. catchClause = new CatchClause(typeRef, identifier, stmt); .)
	)
	(. 
		if (catchClause != null) {
			catchClause.StartLocation = startPos;
			catchClause.EndLocation = t.Location;
		}
	.)
.

GotoStatement<out Statement stmt>
(. Expression expr; stmt = null; .)
=
	"goto"
	(
		Identifier (. stmt = new GotoStatement(t.val); .) ";"
		| "case" Expr<out expr>  ";" (. stmt = new GotoCaseStatement(expr); .)
		| "default" ";" (. stmt = new GotoCaseStatement(null); .)
	)
.

ResourceAcquisition<out Statement stmt>
(.
	stmt = null;
	Expression expr;
.)
=
	(
		IF (IsLocalVarDecl()) LocalVariableDecl<out stmt>
		| Expr<out expr> /* LL(1) conflict resoltion:                             *
		                  * check if next is Qualident followed by ident          *
		                  * ==> LocalVariableDecl                                 *
		                  * new problem: first set of ResourceAcquisition changes */
		(. stmt = new ExpressionStatement(expr); .)
	)
.

StatementExpr<out Statement stmt>
(. Expression expr; .)
=
	Expr<out expr>
	/* The grammar allows only assignments or method invocations here, */
	/* but we don't enforce that here */
	(. stmt = new ExpressionStatement(expr); .)
.

Expr<out Expression expr>
(. expr = null; Expression expr1 = null, expr2 = null; AssignmentOperatorType op; .)
=
	(. Location startLocation = la.Location; .)
	UnaryExpr<out expr>
	/*--- conditional expression: */
	(	
		( AssignmentOperator<out op> Expr<out expr1> (. expr = new AssignmentExpression(expr, op, expr1); .) )
		| IF (la.kind == Tokens.GreaterThan && Peek(1).kind == Tokens.GreaterEqual)
		  ( AssignmentOperator<out op> Expr<out expr1> (. expr = new AssignmentExpression(expr, op, expr1); .) )
		| (
			ConditionalOrExpr<ref expr>
			[ "??" Expr<out expr1> (. expr = new BinaryOperatorExpression(expr, BinaryOperatorType.NullCoalescing, expr1); .) ]
			[ "?" Expr<out expr1> ":" Expr<out expr2> (. expr = new ConditionalExpression(expr, expr1, expr2);  .) ]
		)
	)
	(.	if (expr != null) {
			if (expr.StartLocation.IsEmpty)
				expr.StartLocation = startLocation;
			if (expr.EndLocation.IsEmpty)
				expr.EndLocation = t.EndLocation;
		}
	.)
.


UnaryExpr<out Expression uExpr>
(.
	TypeReference type = null;
	Expression expr = null;
	ArrayList expressions = new ArrayList();
	uExpr = null;
.)
=
	{
		/* IF (Tokens.UnaryOp[la.kind] || IsTypeCast()) */
		(
			  "+"  (. expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.Plus) { StartLocation = t.Location }); .)
			| "-"  (. expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.Minus) { StartLocation = t.Location }); .)
			| "!"  (. expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.Not) { StartLocation = t.Location }); .)
			| "~"  (. expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.BitNot) { StartLocation = t.Location }); .)
			| "*"  (. expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.Dereference) { StartLocation = t.Location }); .)
			| "++" (. expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.Increment) { StartLocation = t.Location }); .)
			| "--" (. expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.Decrement) { StartLocation = t.Location }); .)
			| "&"  (. expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.AddressOf) { StartLocation = t.Location }); .)
			
			/*--- cast expression: */
			/* Problem:  "(" Type ")" from here and                     *
			 *           "(" Expr ")" from PrimaryExpr                  *
			 * Solution: (in IsTypeCast())                              */
			| IF (IsTypeCast()) "(" Type<out type> ")"  (.  expressions.Add(new CastExpression(type) { StartLocation = t.Location }); .)
		)
	}
	
	/* special rule (2.4.4.2) to allow writing int.MinValue and long.MinValue */
	( IF (LastExpressionIsUnaryMinus(expressions) && IsMostNegativeIntegerWithoutTypeSuffix())
		Literal
		(.
			expressions.RemoveAt(expressions.Count - 1);
			if (t.literalValue is uint) {
				expr = new PrimitiveExpression(int.MinValue, int.MinValue.ToString());
			} else if (t.literalValue is ulong) {
				expr = new PrimitiveExpression(long.MinValue, long.MinValue.ToString());
			} else {
				throw new Exception("t.literalValue must be uint or ulong");
			}
		.)
	|	PrimaryExpr<out expr> 
	)
	(.	for (int i = 0; i < expressions.Count; ++i) {
			Expression nextExpression = i + 1 < expressions.Count ? (Expression)expressions[i + 1] : expr;
			if (expressions[i] is CastExpression) {
				((CastExpression)expressions[i]).Expression = nextExpression;
			} else {
				((UnaryOperatorExpression)expressions[i]).Expression = nextExpression;
			}
		}
		if (expressions.Count > 0) {
			uExpr = (Expression)expressions[0];
		} else {
			uExpr = expr;
		}
	.)
.


PrimaryExpr<out Expression pexpr>
(.
	TypeReference type = null;
	Expression expr;
	pexpr = null;
.)
=
	(. Location startLocation = la.Location; .)
	(
		"true"                              (.pexpr = new PrimitiveExpression(true, "true");  .)
	|	"false"                           (.pexpr = new PrimitiveExpression(false, "false"); .)
	|	"null"                            (.pexpr = new PrimitiveExpression(null, "null");  .)          /* from literal token */
	|	Literal                           (.pexpr = new PrimitiveExpression(t.literalValue, t.val) { LiteralFormat = t.literalFormat };  .)
	| IF (StartOfQueryExpression())
		QueryExpression<out pexpr>
	| IF (IdentAndDoubleColon())
		Identifier (. type = new TypeReference(t.val); .)
		"::" (. pexpr = new TypeReferenceExpression(type); .)
		Identifier (. if (type.Type == "global") { type.IsGlobal = true; type.Type = t.val ?? "?"; } else type.Type += "." + (t.val ?? "?"); .)

		/*--- simple name (IdentifierExpression): */
	|	Identifier
		(. pexpr = new IdentifierExpression(t.val); .)
		
		[	ShortedLambdaExpression<(IdentifierExpression)pexpr, out pexpr> 
		| IF (IsGenericInSimpleNameOrMemberAccess())
			(. List<TypeReference> typeList; .)
			TypeArgumentList<out typeList, false>
			(. ((IdentifierExpression)pexpr).TypeArguments = typeList; .)
		]
	| IF (IsLambdaExpression()) /* Lambda expression */
		LambdaExpression<out pexpr>

		/*--- parenthesized expression: */
	|	"(" Expr<out expr> ")" (. pexpr = new ParenthesizedExpression(expr); .)
	
	| /*--- predefined type member access: */
		(. string val = null; .)
		( "bool" (. val = "System.Boolean"; .) 
		| "byte" (. val = "System.Byte"; .)   
		| "char" (. val = "System.Char"; .)
		| "decimal" (. val = "System.Decimal"; .)
		| "double"  (. val = "System.Double"; .)
		| "float"   (. val = "System.Single"; .)
		| "int"     (. val = "System.Int32"; .)
		| "long"  (. val = "System.Int64"; .)
		| "object"   (. val = "System.Object"; .)
		| "sbyte" (. val = "System.SByte"; .)
		| "short"   (. val = "System.Int16"; .)
		| "string"  (. val = "System.String"; .)
		| "uint"  (. val = "System.UInt32"; .)
		| "ulong"    (. val = "System.UInt64"; .)
		| "ushort" (. val = "System.UInt16"; .)
		| "void" (. val = "System.Void"; .)
		)
		(. pexpr = new TypeReferenceExpression(new TypeReference(val, true)) { StartLocation = t.Location, EndLocation = t.EndLocation }; .)
		
		/*--- this access: */
	|	"this"                              (. pexpr = new ThisReferenceExpression(); pexpr.StartLocation = t.Location; pexpr.EndLocation = t.EndLocation; .)
		/*--- base access: */
	|	"base"                              (. pexpr = new BaseReferenceExpression(); pexpr.StartLocation = t.Location; pexpr.EndLocation = t.EndLocation; .)
	
		/* new ... - ObjectCreationExpression or ArrayCreateExpression */
	|	NewExpression<out pexpr>
	
	|	"typeof" "("
		(
			IF (NotVoidPointer()) "void" (. type = new TypeReference("System.Void", true); .)
		|	TypeWithRestriction<out type, true, true>
		)
		")"                            (. pexpr = new TypeOfExpression(type); .)
		
	|	"default" "(" Type<out type> ")" (. pexpr = new DefaultValueExpression(type); .)
	|	"sizeof" "(" Type<out type> ")" (. pexpr = new SizeOfExpression(type); .)
	|	"checked" "(" Expr<out expr> ")" (. pexpr = new CheckedExpression(expr); .)
	|	"unchecked" "(" Expr<out expr> ")" (. pexpr = new UncheckedExpression(expr); .)
	|	"delegate" AnonymousMethodExpr<out expr> (. pexpr = expr; .)
	)
	(.	if (pexpr != null) {
			if (pexpr.StartLocation.IsEmpty)
				pexpr.StartLocation = startLocation;
			if (pexpr.EndLocation.IsEmpty)
				pexpr.EndLocation = t.EndLocation;
		}
	.)
	{
		(. startLocation = la.Location; .)
		(
			"++"   (. pexpr = new UnaryOperatorExpression(pexpr, UnaryOperatorType.PostIncrement); .)
		|
			"--" (. pexpr = new UnaryOperatorExpression(pexpr, UnaryOperatorType.PostDecrement); .)
		/*--- member access */
		|	PointerMemberAccess<out pexpr, pexpr>
		|	MemberAccess<out pexpr, pexpr>
			
		/*--- invocation expression: */
		|	"("
			(. List<Expression> parameters = new List<Expression>(); .)
			(. pexpr = new InvocationExpression(pexpr, parameters); .)
			[ Argument<out expr>     (. SafeAdd(pexpr, parameters, expr); .)
			  { "," Argument<out expr> (. SafeAdd(pexpr, parameters, expr); .)
			  }
			]
			")"
		/*--- element access */
		|  (. /*if (isArrayCreation) Error("element access not allow on array creation");*/
		      List<Expression> indices = new List<Expression>();
		      pexpr = new IndexerExpression(pexpr, indices);
		   .)
			"[" Expr<out expr> (. SafeAdd(pexpr, indices, expr); .)
			{ "," Expr<out expr> (. SafeAdd(pexpr, indices, expr); .)
			} "]"
		)
		(.	if (pexpr != null) {
				if (pexpr.StartLocation.IsEmpty)
					pexpr.StartLocation = startLocation;
				if (pexpr.EndLocation.IsEmpty)
					pexpr.EndLocation = t.EndLocation;
			}
		.)
	}
.

MemberAccess<out Expression expr, Expression target>
(. List<TypeReference> typeList; .)
=
	(.	if (ShouldConvertTargetExpressionToTypeReference(target)) {
			TypeReference type = GetTypeReferenceFromExpression(target);
			if (type != null) {
				target = new TypeReferenceExpression(type) { StartLocation = t.Location, EndLocation = t.EndLocation };
			}
		}
	.)
	"." (. Location startLocation = t.Location; .)
	Identifier
	(. expr = new MemberReferenceExpression(target, t.val); expr.StartLocation = startLocation; expr.EndLocation = t.EndLocation; .)
	[ IF (IsGenericInSimpleNameOrMemberAccess())
		TypeArgumentList<out typeList, false>
		(. ((MemberReferenceExpression)expr).TypeArguments = typeList; .)
	]
.

PointerMemberAccess<out Expression expr, Expression target>
(. List<TypeReference> typeList; .)
=
	"->"
	Identifier
	(. expr = new PointerReferenceExpression(target, t.val); expr.StartLocation = t.Location; expr.EndLocation = t.EndLocation; .)
	[ IF (IsGenericInSimpleNameOrMemberAccess())
		TypeArgumentList<out typeList, false>
		(. ((MemberReferenceExpression)expr).TypeArguments = typeList; .)
	]
.

NewExpression<out Expression pexpr>
(.	pexpr = null;
	List<Expression> parameters = new List<Expression>();
	TypeReference type = null;
	Expression expr;
.)
=
	"new"
	[ NonArrayType<out type> ] /* optional since .NET 3.0 */
	
	/*--- delegate / object creation expression: */
	/* Note: a delegate creation expression allow only a single Expr  */
	/*       not an argument list, but this is not distinguished here */
	(
		(	(. ObjectCreateExpression oce = new ObjectCreateExpression(type, parameters); .)
			"(" (. if (type == null) Error("Cannot use an anonymous type with arguments for the constructor"); .)
			    [ Argument<out expr>          (. SafeAdd(oce, parameters, expr); .)
			      { "," Argument<out expr>    (. SafeAdd(oce, parameters, expr); .) }
			    ]
			")" (. pexpr = oce; .)
			[ CollectionOrObjectInitializer<out expr> (. oce.ObjectInitializer = (CollectionInitializerExpression)expr; .) ]
		|	(. ObjectCreateExpression oce = new ObjectCreateExpression(type, parameters); .)
			CollectionOrObjectInitializer<out expr> (. oce.ObjectInitializer = (CollectionInitializerExpression)expr; .)
			(. pexpr = oce; .)
		)
		
	/*--- array creation expression: */
	|	"["
		(.	ArrayCreateExpression ace = new ArrayCreateExpression(type);
			/* we must not change RankSpecifier on the null type reference*/
			if (ace.CreateType.IsNull) { ace.CreateType = new TypeReference(""); }
			pexpr = ace;
			int dims = 0; List<int> ranks = new List<int>();
		.)
		(
			{ "," (. dims += 1; .) }
			"]" (. ranks.Add(dims); dims = 0; .)
			{ "[" { "," (. ++dims; .) } "]" (. ranks.Add(dims); dims = 0; .) }
			(. ace.CreateType.RankSpecifier = ranks.ToArray(); .)
			CollectionInitializer<out expr> (. ace.ArrayInitializer = (CollectionInitializerExpression)expr; .)
		|	Expr<out expr> (. if (expr != null) parameters.Add(expr); .)
			{	"," (. dims += 1; .)
				Expr<out expr> (. if (expr != null) parameters.Add(expr); .)
			}
			"]" (. ranks.Add(dims); ace.Arguments = parameters; dims = 0; .)
			{ "[" { "," (. ++dims; .) } "]" (. ranks.Add(dims); dims = 0; .) }
			(. ace.CreateType.RankSpecifier = ranks.ToArray(); .)
			[ CollectionInitializer<out expr> (. ace.ArrayInitializer = (CollectionInitializerExpression)expr; .) ]
		)
	)
.

/* Lambda expression with parameter list */
LambdaExpression<out Expression outExpr>
(.
	LambdaExpression lambda = new LambdaExpression();
	lambda.StartLocation = la.Location;
	ParameterDeclarationExpression p;
	outExpr = lambda;
.)
=
	"("
	[
		LambdaExpressionParameter<out p> (. SafeAdd(lambda, lambda.Parameters, p); .)
		{ ","
			LambdaExpressionParameter<out p> (. SafeAdd(lambda, lambda.Parameters, p); .)
		}
	]
	")"
	"=>"
	LambdaExpressionBody<lambda>
.

ShortedLambdaExpression<IdentifierExpression ident, out Expression pexpr>
(. LambdaExpression lambda = new LambdaExpression(); pexpr = lambda; .)
=
	"=>"
	/* not an IdentifierExpression, but a short lambda expression*/
	(.
		lambda.StartLocation = ident.StartLocation;
		SafeAdd(lambda, lambda.Parameters, new ParameterDeclarationExpression(null, ident.Identifier));
		lambda.Parameters[0].StartLocation = ident.StartLocation;
		lambda.Parameters[0].EndLocation = ident.EndLocation;
	.)
	LambdaExpressionBody<lambda>
.

LambdaExpressionParameter<out ParameterDeclarationExpression p>
(.	Location start = la.Location; p = null;
	TypeReference type;
	ParameterModifiers mod = ParameterModifiers.In;
.)
=
	( IF (Peek(1).kind == Tokens.Comma || Peek(1).kind == Tokens.CloseParenthesis)
		Identifier
		(.	p = new ParameterDeclarationExpression(null, t.val);
			p.StartLocation = start; p.EndLocation = t.EndLocation;
		.)
	| [ "ref"  (. mod = ParameterModifiers.Ref; .)
	  | "out"  (. mod = ParameterModifiers.Out; .)
	  ]
	Type<out type>
		Identifier
		(.	p = new ParameterDeclarationExpression(type, t.val, mod);
			p.StartLocation = start; p.EndLocation = t.EndLocation;
		.)
	)
.

LambdaExpressionBody<LambdaExpression lambda>
(. Expression expr; BlockStatement stmt; .)
=
	(
		Block<out stmt> (. lambda.StatementBody = stmt; .)
	|	Expr<out expr> (. lambda.ExpressionBody = expr; .)
	)
	(. lambda.EndLocation = t.EndLocation; .)
	(. lambda.ExtendedEndLocation = la.Location; .)
.

AnonymousMethodExpr<out Expression outExpr>
(.
	AnonymousMethodExpression expr = new AnonymousMethodExpression();
	expr.StartLocation = t.Location;
	BlockStatement stmt;
	List<ParameterDeclarationExpression> p = new List<ParameterDeclarationExpression>();
	outExpr = expr;
.)
=
	[
		"("
		[ FormalParameterList<p> (. expr.Parameters = p; .) ]
		")"
		(. expr.HasParameterList = true; .)
	]
	Block<out stmt> (. expr.Body = stmt; .)
	(. expr.EndLocation = t.Location; .)
.

ConditionalOrExpr<ref Expression outExpr>
(. Expression expr; Location startLocation = la.Location; .)
=
	ConditionalAndExpr<ref outExpr>  { "||" UnaryExpr<out expr> ConditionalAndExpr<ref expr> (.  outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.LogicalOr, expr) { StartLocation = startLocation, EndLocation = t.EndLocation };  .) }
.

ConditionalAndExpr<ref Expression outExpr>
(. Expression expr; Location startLocation = la.Location; .)
=
	InclusiveOrExpr<ref outExpr>  { "&&" UnaryExpr<out expr> InclusiveOrExpr<ref expr> (.  outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.LogicalAnd, expr) { StartLocation = startLocation, EndLocation = t.EndLocation };  .) }
.

InclusiveOrExpr<ref Expression outExpr>
(. Expression expr; Location startLocation = la.Location; .)
=
	ExclusiveOrExpr<ref outExpr>  { "|" UnaryExpr<out expr> ExclusiveOrExpr<ref expr> (.  outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.BitwiseOr, expr) { StartLocation = startLocation, EndLocation = t.EndLocation };  .) }
.

ExclusiveOrExpr<ref Expression outExpr>
(. Expression expr; Location startLocation = la.Location; .)
=
	AndExpr<ref outExpr>  { "^" UnaryExpr<out expr> AndExpr<ref expr> (.  outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.ExclusiveOr, expr) { StartLocation = startLocation, EndLocation = t.EndLocation };  .) }
.

AndExpr<ref Expression outExpr>
(. Expression expr; Location startLocation = la.Location; .)
=
	EqualityExpr<ref outExpr> { "&" UnaryExpr<out expr> EqualityExpr<ref expr> (.  outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.BitwiseAnd, expr) { StartLocation = startLocation, EndLocation = t.EndLocation };  .) }
.

EqualityExpr<ref Expression outExpr>
(.
	Expression expr;
	BinaryOperatorType op = BinaryOperatorType.None;
	Location startLocation = la.Location;
.)
=
	RelationalExpr<ref outExpr>
	{
		(
			"!="   (. op = BinaryOperatorType.InEquality; .)
			| "==" (. op = BinaryOperatorType.Equality; .)
		)
		UnaryExpr<out expr> RelationalExpr<ref expr> (.  outExpr = new BinaryOperatorExpression(outExpr, op, expr) { StartLocation = startLocation, EndLocation = t.EndLocation };  .) 
	}
.

RelationalExpr<ref Expression outExpr>
(.
	TypeReference type;
	Expression expr;
	BinaryOperatorType op = BinaryOperatorType.None;
	Location startLocation = la.Location;
.)
=
	ShiftExpr<ref outExpr>
	{
		(	"<"    (. op = BinaryOperatorType.LessThan; .)
		|	">"  (. op = BinaryOperatorType.GreaterThan; .)
		|	"<=" (. op = BinaryOperatorType.LessThanOrEqual; .)
		|	">=" (. op = BinaryOperatorType.GreaterThanOrEqual; .)
		)
		UnaryExpr<out expr>
		ShiftExpr<ref expr>
		(. outExpr = new BinaryOperatorExpression(outExpr, op, expr) { StartLocation = startLocation, EndLocation = t.EndLocation }; .)
	|
		(	"is"
			TypeWithRestriction<out type, false, false>
			[ IF (la.kind == Tokens.Question && !IsPossibleExpressionStart(Peek(1).kind))
				NullableQuestionMark<ref type> ]
			(. outExpr = new TypeOfIsExpression(outExpr, type)  { StartLocation = startLocation, EndLocation = t.EndLocation }; .)
		|	"as"
			TypeWithRestriction<out type, false, false>
			[ IF (la.kind == Tokens.Question && !IsPossibleExpressionStart(Peek(1).kind))
				NullableQuestionMark<ref type> ]
			(. outExpr = new CastExpression(type, outExpr, CastType.TryCast) { StartLocation = startLocation, EndLocation = t.EndLocation }; .)
		)
	}
.

ShiftExpr<ref Expression outExpr>
(.
	Expression expr;
	BinaryOperatorType op = BinaryOperatorType.None;
	Location startLocation = la.Location;
.)
=
	AdditiveExpr<ref outExpr> 
	{
		(	"<<"   (. op = BinaryOperatorType.ShiftLeft; .)
			| IF (IsShiftRight()) (
				">" ">" (. op = BinaryOperatorType.ShiftRight; .)
			)
		)
		UnaryExpr<out expr> AdditiveExpr<ref expr> (.  outExpr = new BinaryOperatorExpression(outExpr, op, expr) { StartLocation = startLocation, EndLocation = t.EndLocation };  .) 
	}
.

AdditiveExpr<ref Expression outExpr>
(.
	Expression expr;
	BinaryOperatorType op = BinaryOperatorType.None;
	Location startLocation = la.Location;
.)
=
	MultiplicativeExpr<ref outExpr>
	{
		(
			"+"   (. op = BinaryOperatorType.Add; .)
			| "-" (. op = BinaryOperatorType.Subtract; .)
		)
		UnaryExpr<out expr> MultiplicativeExpr<ref expr> (.  outExpr = new BinaryOperatorExpression(outExpr, op, expr) { StartLocation = startLocation, EndLocation = t.EndLocation };  .)
	}
.

MultiplicativeExpr<ref Expression outExpr>
(.
	Expression expr;
	BinaryOperatorType op = BinaryOperatorType.None;
	Location startLocation = la.Location;
.)
=
	{
		(
			"*"   (. op = BinaryOperatorType.Multiply; .)
			| "/" (. op = BinaryOperatorType.Divide; .)
			| "%" (. op = BinaryOperatorType.Modulus; .)
		) 
		UnaryExpr<out expr> (. outExpr = new BinaryOperatorExpression(outExpr, op, expr) { StartLocation = startLocation, EndLocation = t.EndLocation }; .) 
	}
.

/* .NET 2.0 rules */	

TypeName<out TypeReference typeRef, bool canBeUnbound>
(.	List<TypeReference> typeArguments = null;
	string alias = null;
	string qualident;
	Location startLocation = la.Location;
.)
=
	[ IF (IdentAndDoubleColon())
		Identifier (. alias = t.val; .)
		"::"
	]
	Qualident<out qualident>
	[TypeArgumentList<out typeArguments, canBeUnbound>]
	(.
		if (alias == null) {
			typeRef = new TypeReference(qualident, typeArguments);
		} else if (alias == "global") {
			typeRef = new TypeReference(qualident, typeArguments);
			typeRef.IsGlobal = true;
		} else {
			typeRef = new TypeReference(alias + "." + qualident, typeArguments);
		}
	.)
	{ IF (DotAndIdent())
		"." (. typeArguments = null; .)
		Qualident<out qualident>
		[TypeArgumentList<out typeArguments, canBeUnbound>]
		(. typeRef = new InnerClassTypeReference(typeRef, qualident, typeArguments); .)
	}
	(. typeRef.StartLocation = startLocation; typeRef.EndLocation = t.EndLocation; .)
.


NullableQuestionMark<ref TypeReference typeRef>
(. List<TypeReference> typeArguments = new List<TypeReference>(1); .)
=
	"?"
	(.
		if (typeRef != null) typeArguments.Add(typeRef);
		typeRef = new TypeReference("System.Nullable", typeArguments) { IsKeyword = true };
	.)
.

TypeArgumentList<out List<TypeReference> types, bool canBeUnbound>
(. 
	types = new List<TypeReference>();
	TypeReference type = null;
.)
=
	"<"
	( IF (canBeUnbound && (la.kind == Tokens.GreaterThan || la.kind == Tokens.Comma))
		(. types.Add(TypeReference.Null); .)
		{ "," (. types.Add(TypeReference.Null); .) }
	| Type<out type> (. if (type != null) { types.Add(type); } .)
	  { "," Type<out type> (. if (type != null) { types.Add(type); } .) }
	)
	">"
.

TypeParameterList<List<TemplateDefinition> templates>
(.
	TemplateDefinition template;
.)
=
	"<"
	VariantTypeParameter<out template> (. templates.Add(template); .)
	{	","
		VariantTypeParameter<out template> (. templates.Add(template); .)
	}
	">"
.

VariantTypeParameter<out TemplateDefinition typeParameter>
(.
	typeParameter = new TemplateDefinition();
	AttributeSection section;
.)
=
	{ AttributeSection<out section> (. typeParameter.Attributes.Add(section); .) }
	[
		"in"  (. typeParameter.VarianceModifier = VarianceModifier.Contravariant; .)
	|	"out" (. typeParameter.VarianceModifier = VarianceModifier.Covariant; .)
	]
	Identifier (. typeParameter.Name = t.val; typeParameter.StartLocation = t.Location; .)
(. typeParameter.EndLocation = t.EndLocation; .)
.

TypeParameterConstraintsClause<List<TemplateDefinition> templates>
(. string name = ""; TypeReference type; .)
=
	"where"
	Identifier (. name = t.val; .)
	":"
	TypeParameterConstraintsClauseBase<out type> (. 
	                                                TemplateDefinition td = null;
	                                                foreach (TemplateDefinition d in templates) {
	                                                	if (d.Name == name) {
	                                                		td = d;
	                                                		break;
	                                                	}
	                                                }
	                                                if ( td != null && type != null) { td.Bases.Add(type); }
	                                             .)
	{ "," TypeParameterConstraintsClauseBase<out type> (.
	                                                    td = null;
	                                                    foreach (TemplateDefinition d in templates) {
	                                                    	if (d.Name == name) {
	                                                    		td = d;
	                                                    		break;
	                                                    	}
	                                                    }
	                                                    if ( td != null && type != null) { td.Bases.Add(type); }
	                                                   .) }
.

TypeParameterConstraintsClauseBase<out TypeReference type>
(. TypeReference t; type = null; .)
=
	"struct"          (. type = TypeReference.StructConstraint; .)
	| "class"         (. type = TypeReference.ClassConstraint; .)
	| "new" "(" ")"   (. type = TypeReference.NewConstraint; .)
	| Type<out t>     (. type = t; .)
.

QueryExpression<out Expression outExpr>
(.	QueryExpression q = new QueryExpression(); outExpr = q; q.StartLocation = la.Location; 
	QueryExpressionFromClause fromClause;
.)
=
	QueryExpressionFromClause<out fromClause>  (. q.FromClause = fromClause; .)
	QueryExpressionBody<ref q>
	(.	q.EndLocation = t.EndLocation; 
		outExpr = q; /* set outExpr to q again if QueryExpressionBody changed it (can happen with 'into' clauses) */ 
	.)
.

QueryExpressionFromClause<out QueryExpressionFromClause fc>
(.	fc = new QueryExpressionFromClause();
fc.StartLocation = la.Location;
CollectionRangeVariable variable;
.)
=
	"from"
	QueryExpressionFromOrJoinClause<out variable>
	(. fc.EndLocation = t.EndLocation;
	fc.Sources.Add(variable);
	.)
.

QueryExpressionJoinClause<out QueryExpressionJoinClause jc>
(.	jc = new QueryExpressionJoinClause(); jc.StartLocation = la.Location; 
	Expression expr;
	CollectionRangeVariable variable;
.)
=
	"join"
	QueryExpressionFromOrJoinClause<out variable>
	"on"
	Expr<out expr> (. jc.OnExpression = expr; .)
	"equals"
	Expr<out expr> (. jc.EqualsExpression = expr; .)
	[ "into"
		Identifier (. jc.IntoIdentifier = t.val; .)
	]
	(.
	   jc.EndLocation = t.EndLocation;
	   jc.Source = variable;
	.)
.

QueryExpressionFromOrJoinClause<out CollectionRangeVariable variable>
(. TypeReference type; Expression expr; variable = new CollectionRangeVariable(); .)
=
	(. variable.Type = null; .)
	[ IF (IsLocalVarDecl()) Type<out type> (. variable.Type = type; .) ]
	Identifier  (. variable.Identifier = t.val; .)
	"in"
	Expr<out expr> (. variable.Expression = expr; .)
.

QueryExpressionBody<ref QueryExpression q>
(.	QueryExpressionFromClause fromClause;     QueryExpressionWhereClause whereClause;
	QueryExpressionLetClause letClause;       QueryExpressionJoinClause joinClause;
	QueryExpressionOrderClause orderClause;
	QueryExpressionSelectClause selectClause; QueryExpressionGroupClause groupClause;
.)
=
	{ (	QueryExpressionFromClause<out fromClause>     (. SafeAdd<QueryExpressionClause>(q, q.MiddleClauses, fromClause); .)
	  |	QueryExpressionWhereClause<out whereClause>   (. SafeAdd<QueryExpressionClause>(q, q.MiddleClauses, whereClause); .)
	  |	QueryExpressionLetClause<out letClause>       (. SafeAdd<QueryExpressionClause>(q, q.MiddleClauses, letClause); .)
	  |	QueryExpressionJoinClause<out joinClause>     (. SafeAdd<QueryExpressionClause>(q, q.MiddleClauses, joinClause); .)
	  | QueryExpressionOrderByClause<out orderClause> (. SafeAdd<QueryExpressionClause>(q, q.MiddleClauses, orderClause); .)
	  ) }
	(	QueryExpressionSelectClause<out selectClause> (. q.SelectOrGroupClause = selectClause; .)
	|	QueryExpressionGroupClause<out groupClause>  (. q.SelectOrGroupClause = groupClause; .)
	)
	[ QueryExpressionIntoClause<ref q> ]
.

QueryExpressionWhereClause<out QueryExpressionWhereClause wc>
(. Expression expr; wc = new QueryExpressionWhereClause(); wc.StartLocation = la.Location; .)
=
	"where"
	Expr<out expr> (. wc.Condition = expr; .)
	(. wc.EndLocation = t.EndLocation; .)
.

QueryExpressionLetClause<out QueryExpressionLetClause wc>
(. Expression expr; wc = new QueryExpressionLetClause(); wc.StartLocation = la.Location; .)
=
	"let"
	Identifier (. wc.Identifier = t.val; .)
	"="
	Expr<out expr> (. wc.Expression = expr; .)
	(. wc.EndLocation = t.EndLocation; .)
.

QueryExpressionOrderByClause<out QueryExpressionOrderClause oc>
(. QueryExpressionOrdering ordering; oc = new QueryExpressionOrderClause(); oc.StartLocation = la.Location; .)
=
	"orderby"
	QueryExpressionOrdering<out ordering> (. SafeAdd(oc, oc.Orderings, ordering); .)
	{ ","
		QueryExpressionOrdering<out ordering> (. SafeAdd(oc, oc.Orderings, ordering); .)
	}
	(. oc.EndLocation = t.EndLocation; .)
.

QueryExpressionOrdering<out QueryExpressionOrdering ordering>
(. Expression expr; ordering = new QueryExpressionOrdering(); ordering.StartLocation = la.Location; .)
=
	Expr<out expr> (. ordering.Criteria = expr; .)
	[	"ascending"  (. ordering.Direction = QueryExpressionOrderingDirection.Ascending; .)
	|	"descending" (. ordering.Direction = QueryExpressionOrderingDirection.Descending; .)
	]
	(. ordering.EndLocation = t.EndLocation; .)
.

QueryExpressionSelectClause<out QueryExpressionSelectClause sc>
(. Expression expr; sc = new QueryExpressionSelectClause(); sc.StartLocation = la.Location; .)
=
	"select"
	Expr<out expr> (. sc.Projection = expr; .)
	(. sc.EndLocation = t.EndLocation; .)
.

QueryExpressionGroupClause<out QueryExpressionGroupClause gc>
(. Expression expr; gc = new QueryExpressionGroupClause(); gc.StartLocation = la.Location; .)
=
	"group"
	Expr<out expr> (. gc.Projection = expr; .)
	"by"
	Expr<out expr> (. gc.GroupBy = expr; .)
	(. gc.EndLocation = t.EndLocation; .)
.

QueryExpressionIntoClause<ref QueryExpression q>
(.	QueryExpression firstQuery = q;
	QueryExpression continuedQuery = new QueryExpression(); 
	continuedQuery.StartLocation = q.StartLocation;
	firstQuery.EndLocation = la.Location;
	continuedQuery.FromClause = new QueryExpressionFromClause();
	CollectionRangeVariable fromVariable = new CollectionRangeVariable();
	continuedQuery.FromClause.Sources.Add(fromVariable);
	fromVariable.StartLocation = la.Location;
	// nest firstQuery inside continuedQuery.
	fromVariable.Expression = firstQuery;
	continuedQuery.IsQueryContinuation = true;
	q = continuedQuery;
.)
=
	"into"
	Identifier (. fromVariable.Identifier = t.val; .)
	(. continuedQuery.FromClause.EndLocation = t.EndLocation; .)
	QueryExpressionBody<ref q>
.

/* allow usage of context sensitive keywords as identifiers */
Identifier
=
/* when updating this list, ensure you also change KeywordList.IdentifierTokens*/
	ident
|	"partial"
|	"where"
|	"get"
|	"set"
|	"add"
|	"remove"
|	"yield"
|	"select"
|	"group"
|	"by"
|	"into"
|	"from"
|	"ascending"
|	"descending"
|	"orderby"
|	"let"
|	"join"
|	"on"
|	"equals"
.

	
END CS.
