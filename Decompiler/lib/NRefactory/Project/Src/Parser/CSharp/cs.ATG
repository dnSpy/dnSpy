using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Text;
using ICSharpCode.NRefactory.Parser;
using ICSharpCode.NRefactory.Ast;
using ASTAttribute = ICSharpCode.NRefactory.Ast.Attribute;
using Types = ICSharpCode.NRefactory.Ast.ClassType;

COMPILER CS    /* AW 2002-12-30 renamed from CompilationUnit to CS  */


/*------------------------------------------------------------------------*
 *----- LEXER TOKEN LIST  ------------------------------------------------*
 *------------------------------------------------------------------------*/

/* START AUTOGENERATED TOKENS SECTION */
TOKENS
	/* ----- terminal classes ----- */
	/* EOF is 0 */
	ident
	Literal

	/* ----- special character ----- */
	"="
	"+"
	"-"
	"*"
	"/"
	"%"
	":"
	"::"
	";"
	"?"
	"??"
	","
	"."
	"{"
	"}"
	"["
	"]"
	"("
	")"
	">"
	"<"
	"!"
	"&&"
	"||"
	"~"
	"&"
	"|"
	"^"
	"++"
	"--"
	"=="
	"!="
	">="
	"<="
	"<<"
	"+="
	"-="
	"*="
	"/="
	"%="
	"&="
	"|="
	"^="
	"<<="
	"->"
	"=>"

	/* ----- keywords ----- */
	"abstract"
	"as"
	"base"
	"bool"
	"break"
	"byte"
	"case"
	"catch"
	"char"
	"checked"
	"class"
	"const"
	"continue"
	"decimal"
	"default"
	"delegate"
	"do"
	"double"
	"else"
	"enum"
	"event"
	"explicit"
	"extern"
	"false"
	"finally"
	"fixed"
	"float"
	"for"
	"foreach"
	"goto"
	"if"
	"implicit"
	"in"
	"int"
	"interface"
	"internal"
	"is"
	"lock"
	"long"
	"namespace"
	"new"
	"null"
	"object"
	"operator"
	"out"
	"override"
	"params"
	"private"
	"protected"
	"public"
	"readonly"
	"ref"
	"return"
	"sbyte"
	"sealed"
	"short"
	"sizeof"
	"stackalloc"
	"static"
	"string"
	"struct"
	"switch"
	"this"
	"throw"
	"true"
	"try"
	"typeof"
	"uint"
	"ulong"
	"unchecked"
	"unsafe"
	"ushort"
	"using"
	"virtual"
	"void"
	"volatile"
	"while"
	"partial"
	"where"
	"get"
	"set"
	"add"
	"remove"
	"yield"
	"select"
	"group"
	"by"
	"into"
	"from"
	"ascending"
	"descending"
	"orderby"
	"let"
	"join"
	"on"
	"equals"
/* END AUTOGENERATED TOKENS SECTION */

/*------------------------------------------------------------------------*
 *----- PARSER -----------------------------------------------------------*
 *------------------------------------------------------------------------*/

PRODUCTIONS

/*--- compilation unit: */
CS
(. lexer.NextToken(); /* get the first token */ .)
=
	{ UsingDirective }
	{ IF (IsGlobalAttrTarget()) GlobalAttributeSection }
	{ NamespaceMemberDecl }
	EOF
.

UsingDirective
(.
	string qualident = null; TypeReference aliasedType = null;
.)
=
	"using"                     (. Location startPos = t.Location; .)
	Qualident<out qualident>
	[ "=" NonArrayType<out aliasedType> ]
	";"                         (. 
	                               if (qualident != null && qualident.Length > 0) {
	                                 INode node;
	                                 if (aliasedType != null) {
	                                     node = new UsingDeclaration(qualident, aliasedType);
	                                 } else {
	                                     node = new UsingDeclaration(qualident);
	                                 }
	                                 node.StartLocation = startPos;
	                                 node.EndLocation   = t.EndLocation;
	                                 compilationUnit.AddChild(node);
	                               }
	                            .)
.

GlobalAttributeSection
=
	"[" (. Location startPos = t.Location; .) Identifier
	                            (. if (t.val != "assembly" && t.val != "module") Error("global attribute target specifier (assembly or module) expected");
	                               string attributeTarget = t.val;
	                               List<ASTAttribute> attributes = new List<ASTAttribute>();
	                               ASTAttribute attribute;
	                            .)
	":" Attribute<out attribute> (. attributes.Add(attribute); .)
	{ IF (NotFinalComma()) "," Attribute<out attribute> (. attributes.Add(attribute); .)}
	[ "," ]
	"]"                         (. AttributeSection section = new AttributeSection {
	                                   AttributeTarget = attributeTarget,
	                                   Attributes = attributes,
	                                   StartLocation = startPos,
	                                   EndLocation = t.EndLocation
	                               };
	                               compilationUnit.AddChild(section);
	                            .)
.

Attribute<out ASTAttribute attribute>
(. string qualident;
   string alias = null;
.)
=
	(. Location startPos = la.Location; .)
	[ IF (IdentAndDoubleColon())
		Identifier (. alias = t.val; .)
		"::"
	]
	Qualident<out qualident> 
	(. List<Expression> positional = new List<Expression>();
	   List<NamedArgumentExpression> named = new List<NamedArgumentExpression>();
	   string name = (alias != null && alias != "global") ? alias + "." + qualident : qualident;
	.)
	[ AttributeArguments<positional, named> ]
	(. attribute = new ASTAttribute(name, positional, named); 
	   attribute.StartLocation = startPos;
	   attribute.EndLocation = t.EndLocation;
	.)
.

AttributeArguments<List<Expression> positional, List<NamedArgumentExpression> named>
(.
	bool nameFound = false;
	string name = "";
	Expression expr;
.)
=
	"("
	[
		[
			IF (IsAssignment())          (. nameFound = true; .)
			Identifier                   (. name = t.val; .)
			"="
		] Expr<out expr>                 (. if (expr != null) {if(name == "") positional.Add(expr);
		                                    else { named.Add(new NamedArgumentExpression(name, expr)); name = ""; }
		                                    }
		                                 .)
		
		{
			","
				(
					IF (IsAssignment())    (. nameFound = true; .)
					Identifier                 (. name = t.val; .)
					"="
					| /*Empty*/                (. if (nameFound) Error("no positional argument after named argument"); .)
				) Expr<out expr>           (. if (expr != null) { if(name == "") positional.Add(expr);
				                              else { named.Add(new NamedArgumentExpression(name, expr)); name = ""; }
				                              }
				                           .)
		}
	]
	")"
.

AttributeSection<out AttributeSection section>
(.
	string attributeTarget = "";
	List<ASTAttribute> attributes = new List<ASTAttribute>();
	ASTAttribute attribute;
	
.)
=
	"[" (. Location startPos = t.Location; .) /*--- attribute target specifier: */
	[ IF (IsLocalAttrTarget())
		( "event"                       (. attributeTarget = "event";.)
		| "return"                      (. attributeTarget = "return";.)
		| Identifier                    (. if (t.val != "field"   && t.val != "method" &&
		                                      t.val != "param" &&
		                                      t.val != "property" && t.val != "type")
		                                    Error("attribute target specifier (field, event, method, param, property, return or type) expected");
		                                   attributeTarget = t.val;
		                                .)
		) ":" 
	]
	/*--- attribute list: */
	Attribute<out attribute>            (. attributes.Add(attribute); .)
	{ IF (NotFinalComma()) "," Attribute<out attribute> (. attributes.Add(attribute); .)}
	[ "," ]
	"]"                         (. section = new AttributeSection {
	                                   AttributeTarget = attributeTarget,
	                                   Attributes = attributes,
	                                   StartLocation = startPos,
	                                   EndLocation = t.EndLocation
	                               };
	                            .)
.

NamespaceMemberDecl
(.
	AttributeSection section;
	List<AttributeSection> attributes = new List<AttributeSection>();
	ModifierList m = new ModifierList();
	string qualident;
.)
= /*--- namespace declaration: */
	"namespace"                  (. Location startPos = t.Location; .)
	Qualident<out qualident>     (. INode node =  new NamespaceDeclaration(qualident);
	                                node.StartLocation = startPos;
	                                compilationUnit.AddChild(node);
	                                compilationUnit.BlockStart(node);
	                              .)
	"{"
	{ UsingDirective }
	{ NamespaceMemberDecl }
	"}"
	[ ";" ]                       (. node.EndLocation   = t.EndLocation;
	                                 compilationUnit.BlockEnd();
	                              .)
	/*--- type declaration: */
	| { AttributeSection<out section> (. attributes.Add(section); .) }
	  { TypeModifier<m> }
	  TypeDecl<m, attributes>
.

TypeDecl<ModifierList m, List<AttributeSection> attributes>
(.
	TypeReference type;
	List<TypeReference> names;
	List<ParameterDeclarationExpression> p = new List<ParameterDeclarationExpression>();
	string name;
	List<TemplateDefinition> templates;
.)
= /*--- class declaration: */      (. m.Check(Modifiers.Classes); .)
	"class"                        (. TypeDeclaration newType = new TypeDeclaration(m.Modifier, attributes);
	                                  templates = newType.Templates;
	                                  compilationUnit.AddChild(newType);
	                                  compilationUnit.BlockStart(newType);
	                                  newType.StartLocation = m.GetDeclarationLocation(t.Location);
	                                  
	                                  newType.Type = Types.Class;
	                                .)
	Identifier                      (. newType.Name = t.val; .)
	
	/* .NET 2.0 */
	[ TypeParameterList<templates> ]
	
	[ ClassBase<out names>          (. newType.BaseTypes = names; .) ]
	
	/* .NET 2.0 */
	{ TypeParameterConstraintsClause<templates> }
	
	(. newType.BodyStartLocation = t.EndLocation; .)
	"{"
	ClassBody
	"}"
	[ ";" ]                         (. newType.EndLocation = t.Location; 
	                                   compilationUnit.BlockEnd();
	                                .)
| /*--- struct declaration: */  (. m.Check(Modifiers.StructsInterfacesEnumsDelegates); .)
	( "struct"                      (. TypeDeclaration newType = new TypeDeclaration(m.Modifier, attributes);
	                                   templates = newType.Templates;
	                                   newType.StartLocation = m.GetDeclarationLocation(t.Location);
	                                   compilationUnit.AddChild(newType);
	                                   compilationUnit.BlockStart(newType);
	                                   newType.Type = Types.Struct; 
	                                 .)
	Identifier                       (. newType.Name = t.val; .)
	
	/* .NET 2.0 */
	[ TypeParameterList<templates> ]
	
	[ StructInterfaces<out names>    (. newType.BaseTypes = names; .) ]
	
	/* .NET 2.0 */
	{ TypeParameterConstraintsClause<templates> }
	
	
	(. newType.BodyStartLocation = t.EndLocation; .)
	StructBody
	[ ";" ]                          (. newType.EndLocation = t.Location; 
	                                    compilationUnit.BlockEnd();
	                                 .)
| /*--- interface declaration: */ 
	"interface"                      (. TypeDeclaration newType = new TypeDeclaration(m.Modifier, attributes);
	                                    templates = newType.Templates;
	                                    compilationUnit.AddChild(newType);
	                                    compilationUnit.BlockStart(newType);
	                                    newType.StartLocation = m.GetDeclarationLocation(t.Location);
	                                    newType.Type = Types.Interface;
	                                  .)
	Identifier                        (. newType.Name = t.val; .)
	
	/* .NET 2.0 */
	[ TypeParameterList<templates> ]
	
	[ InterfaceBase<out names>       (. newType.BaseTypes = names; .) ]
	
	/* .NET 2.0 */
	{ TypeParameterConstraintsClause<templates> }
	
	(. newType.BodyStartLocation = t.EndLocation; .)
	InterfaceBody
	[ ";" ]                          (. newType.EndLocation = t.Location; 
	                                    compilationUnit.BlockEnd();
	                                 .)
| /*--- enumeration declaration: */
	"enum"                           (. TypeDeclaration newType = new TypeDeclaration(m.Modifier, attributes);
	                                    compilationUnit.AddChild(newType);
	                                    compilationUnit.BlockStart(newType);
	                                    newType.StartLocation = m.GetDeclarationLocation(t.Location);
	                                    newType.Type = Types.Enum;
	                                  .)
	Identifier                       (. newType.Name = t.val; .)
	[ ":" IntegralType<out name>     (. newType.BaseTypes.Add(new TypeReference(name)); .)
	]
	(. newType.BodyStartLocation = t.EndLocation; .)
	EnumBody 
	[ ";" ]                          (. newType.EndLocation = t.Location; 
	                                    compilationUnit.BlockEnd();
	                                 .)
| /*--- delegate declaration: */
	"delegate"                       (. DelegateDeclaration delegateDeclr = new DelegateDeclaration(m.Modifier, attributes);
	                                    templates = delegateDeclr.Templates;
	                                    delegateDeclr.StartLocation = m.GetDeclarationLocation(t.Location);
	                                 .)
	( IF (NotVoidPointer()) "void"   (. delegateDeclr.ReturnType = new TypeReference("void", 0, null); .)
		| Type<out type>             (. delegateDeclr.ReturnType = type; .)
	)
	Identifier                       (. delegateDeclr.Name = t.val; .)
	
	/* .NET 2.0 */
	[ TypeParameterList<templates> ]
	
	"(" [ FormalParameterList<p> (. delegateDeclr.Parameters = p; .)
	] ")"
	
	/* .NET 2.0 */
	{ TypeParameterConstraintsClause<templates> }
	
	";"                              (. delegateDeclr.EndLocation = t.Location;
	                                    compilationUnit.AddChild(delegateDeclr);
	                                 .)
	)
.

Qualident<out string qualident>
=
	Identifier                          (. qualidentBuilder.Length = 0; qualidentBuilder.Append(t.val); .)
	{ IF (DotAndIdent()) "." Identifier (. qualidentBuilder.Append('.');
	                                      qualidentBuilder.Append(t.val); 
	                                    .)
	} (. qualident = qualidentBuilder.ToString(); .)
.

ClassBase<out List<TypeReference> names>
(.
	TypeReference typeRef;
	names = new List<TypeReference>();
.)
=
	":" ClassType<out typeRef, false>  (. if (typeRef != null) { names.Add(typeRef); } .)
	{ "," TypeName<out typeRef, false> (. if (typeRef != null) { names.Add(typeRef); } .) }
.

ClassBody
(. AttributeSection section; .)
=
	{                                  (.List<AttributeSection> attributes = new List<AttributeSection>();
		                                 ModifierList m = new ModifierList();
		                               .)
		SYNC
		{ AttributeSection<out section> (. attributes.Add(section); .) }
		MemberModifiers<m>
		ClassMemberDecl<m, attributes> 
	}
.

StructInterfaces<out List<TypeReference> names>
(.
	TypeReference typeRef;
	names = new List<TypeReference>();
.)
=
	":" TypeName<out typeRef, false>   (. if (typeRef != null) { names.Add(typeRef); } .)
	{ "," TypeName<out typeRef, false> (. if (typeRef != null) { names.Add(typeRef); } .) }
.

StructBody
(. AttributeSection section; .)
=
	"{"
	{                                    (.List<AttributeSection> attributes = new List<AttributeSection>();
		                                   ModifierList m = new ModifierList();
		                                 .)
		{ AttributeSection<out section>  (. attributes.Add(section); .) }
		MemberModifiers<m>
		StructMemberDecl<m, attributes> 
	}
	"}"
.

InterfaceBase<out List<TypeReference> names>
(.
	TypeReference typeRef;
	names = new List<TypeReference>();
.)
=
	":" TypeName<out typeRef, false>   (. if (typeRef != null) { names.Add(typeRef); } .)
	{ "," TypeName<out typeRef, false> (. if (typeRef != null) { names.Add(typeRef); } .) }
.

InterfaceBody
= "{"
  { SYNC InterfaceMemberDecl }
  "}"
.

EnumBody                                 (. FieldDeclaration f; .)
=
	"{"
	[ EnumMemberDecl<out f>          (. compilationUnit.AddChild(f); .)
	{ IF (NotFinalComma()) ","
		EnumMemberDecl<out f> (. compilationUnit.AddChild(f); .)
	}
	[","] ]
	"}"
.

Type<out TypeReference type>
=
	TypeWithRestriction<out type, true, false>
.

TypeWithRestriction<out TypeReference type, bool allowNullable, bool canBeUnbound>
(.
	string name;
	int pointer = 0;
	type = null;
.)
=
	( ClassType<out type, canBeUnbound>
	| SimpleType<out name> (. type = new TypeReference(name); .)
	| "void" "*"                         (. pointer = 1; type = new TypeReference("void"); .)
	)                                    (. List<int> r = new List<int>(); .)
	
	[ IF (allowNullable && la.kind == Tokens.Question) NullableQuestionMark<ref type> ]
	
	{ IF (IsPointerOrDims())             (. int i = 0; .)
		( "*"                            (. ++pointer; .)
		| "[" { "," (. ++i; .) } "]"     (. r.Add(i); .)
		)
	}
	(. if (type != null) {
		type.RankSpecifier = r.ToArray();
		type.PointerNestingLevel = pointer;
	   }
	.)
.


NonArrayType<out TypeReference type>
(.
	string name;
	int pointer = 0;
	type = null;
.)
=
	( ClassType<out type, false>
	| SimpleType<out name> (. type = new TypeReference(name); .)
	| "void" "*"           (. pointer = 1; type = new TypeReference("void"); .)
	)
	
	[ NullableQuestionMark<ref type> ]
	
	{ IF (IsPointer())
		"*" (. ++pointer; .)
	}
	(. if (type != null) { type.PointerNestingLevel = pointer; } .)
.

SimpleType<out string name>
(. name = String.Empty; .)
=
	IntegralType<out name> 
	| "float"   (. name = "float"; .)
	| "double"  (. name = "double"; .)
	| "decimal" (. name = "decimal"; .)
	| "bool"    (. name = "bool"; .)
.


FormalParameterList<List<ParameterDeclarationExpression> parameter>
(.
	
	ParameterDeclarationExpression p;
	AttributeSection section;
	List<AttributeSection> attributes = new List<AttributeSection>();
.)
=
	{ AttributeSection<out section> (.attributes.Add(section); .) }
	(
		FixedParameter<out p> (. bool paramsFound = false;
		                         p.Attributes = attributes;
		                         parameter.Add(p);
		                      .)
		{
			","                              (. attributes = new List<AttributeSection>(); if (paramsFound) Error("params array must be at end of parameter list"); .)
			{ AttributeSection<out section> (.attributes.Add(section); .) }
			(
				FixedParameter<out p>        (. p.Attributes = attributes; parameter.Add(p); .)
				| ParameterArray<out p>      (. paramsFound = true; p.Attributes = attributes; parameter.Add(p); .)
			)
		}
		| ParameterArray<out p>              (. p.Attributes = attributes; parameter.Add(p); .)
	)
.

FixedParameter<out ParameterDeclarationExpression p>
(.
	TypeReference type;
	ParameterModifiers mod = ParameterModifiers.In;
	Location start = t.Location;
.)
=
	[
		"ref"    (. mod = ParameterModifiers.Ref; .)
		| "out"  (. mod = ParameterModifiers.Out; .)
	]
	Type<out type> Identifier (. p = new ParameterDeclarationExpression(type, t.val, mod); p.StartLocation = start; p.EndLocation = t.Location; .)
.

ParameterArray<out ParameterDeclarationExpression p>
(. TypeReference type; .)
=
	"params" Type<out type> Identifier (. p = new ParameterDeclarationExpression(type, t.val, ParameterModifiers.Params); .)
. 

AccessorModifiers<out ModifierList m>
(. m = new ModifierList(); .)
=
	"private"          (. m.Add(Modifiers.Private, t.Location); .)
	| "protected"      (. m.Add(Modifiers.Protected, t.Location); .)
	  ["internal"      (. m.Add(Modifiers.Internal, t.Location); .)]
	| "internal"       (. m.Add(Modifiers.Internal, t.Location); .)
	  ["protected"     (. m.Add(Modifiers.Protected, t.Location); .)]
.

TypeModifier<ModifierList m>
=
	"new"                              (. m.Add(Modifiers.New, t.Location); .)
	| "public"                         (. m.Add(Modifiers.Public, t.Location); .)
	| "protected"                      (. m.Add(Modifiers.Protected, t.Location); .)
	| "internal"                       (. m.Add(Modifiers.Internal, t.Location); .)
	| "private"                        (. m.Add(Modifiers.Private, t.Location); .)
	| "unsafe"                         (. m.Add(Modifiers.Unsafe, t.Location); .)
	| "abstract"                       (. m.Add(Modifiers.Abstract, t.Location); .)
	| "sealed"                         (. m.Add(Modifiers.Sealed, t.Location); .)
	| "static"                         (. m.Add(Modifiers.Static, t.Location); .)
	| "partial"                        (. m.Add(Modifiers.Partial, t.Location); .)
.

ClassType<out TypeReference typeRef, bool canBeUnbound>
(. TypeReference r; typeRef = null; .)
=
	TypeName<out r, canBeUnbound> (. typeRef = r; .)
	| "object"                    (. typeRef = new TypeReference("object"); .)
	| "string"                    (. typeRef = new TypeReference("string"); .)
.

IntegralType<out string name>          (. name = ""; .)
=
	"sbyte"                            (. name = "sbyte"; .)
	| "byte"                           (. name = "byte"; .)
	| "short"                          (. name = "short"; .)
	| "ushort"                         (. name = "ushort"; .)
	| "int"                            (. name = "int"; .)
	| "uint"                           (. name = "uint"; .)
	| "long"                           (. name = "long"; .)
	| "ulong"                          (. name = "ulong"; .)
	| "char"                           (. name = "char"; .)
.

MemberModifiers<ModifierList m>
=
	{
	  "abstract"                       (. m.Add(Modifiers.Abstract, t.Location); .)
	| "extern"                         (. m.Add(Modifiers.Extern, t.Location); .)
	| "internal"                       (. m.Add(Modifiers.Internal, t.Location); .)
	| "new"                            (. m.Add(Modifiers.New, t.Location); .)
	| "override"                       (. m.Add(Modifiers.Override, t.Location); .)
	| "private"                        (. m.Add(Modifiers.Private, t.Location); .)
	| "protected"                      (. m.Add(Modifiers.Protected, t.Location); .)
	| "public"                         (. m.Add(Modifiers.Public, t.Location); .)
	| "readonly"                       (. m.Add(Modifiers.ReadOnly, t.Location); .)
	| "sealed"                         (. m.Add(Modifiers.Sealed, t.Location); .)
	| "static"                         (. m.Add(Modifiers.Static, t.Location); .)
	| "fixed"                          (. m.Add(Modifiers.Fixed, t.Location); .)
	| "unsafe"                         (. m.Add(Modifiers.Unsafe, t.Location); .)
	| "virtual"                        (. m.Add(Modifiers.Virtual, t.Location); .)
	| "volatile"                       (. m.Add(Modifiers.Volatile, t.Location); .)
	| "partial"                        (. m.Add(Modifiers.Partial, t.Location); .)
	}
.

StructMemberDecl<ModifierList m, List<AttributeSection> attributes>
(.
	string qualident = null;
	TypeReference type;
	Expression expr;
	List<ParameterDeclarationExpression> p = new List<ParameterDeclarationExpression>();
	Statement stmt = null;
	List<VariableDeclaration> variableDeclarators = new List<VariableDeclaration>();
	List<TemplateDefinition> templates = new List<TemplateDefinition>();
	TypeReference explicitInterface = null;
	bool isExtensionMethod = false;
.)
=
	/*--- constant declaration: */         (. m.Check(Modifiers.Constants); .)
	"const"                                (.Location startPos = t.Location; .)
	Type<out type> Identifier              (. FieldDeclaration fd = new FieldDeclaration(attributes, type, m.Modifier | Modifiers.Const);
	                                          fd.StartLocation = m.GetDeclarationLocation(startPos);
	                                          VariableDeclaration f = new VariableDeclaration(t.val);
	                                          fd.Fields.Add(f);
	                                       .)
	"=" Expr<out expr>                     (. f.Initializer = expr; .)
	{ "," Identifier                       (. f = new VariableDeclaration(t.val);
	                                          fd.Fields.Add(f);
	                                       .)
		"=" Expr<out expr>                 (. f.Initializer = expr; .)
	} ";"                                  (. fd.EndLocation = t.EndLocation; compilationUnit.AddChild(fd); .)
	
	
|   /*--- void method (procedure) declaration: */
	IF (NotVoidPointer())                (. m.Check(Modifiers.PropertysEventsMethods); .)
	"void"                                 (. Location startPos = t.Location; .)
	( IF (IsExplicitInterfaceImplementation())
		TypeName<out explicitInterface, false>
		(.if (la.kind != Tokens.Dot || Peek(1).kind != Tokens.This) {
			qualident = TypeReference.StripLastIdentifierFromType(ref explicitInterface);
		  } .)
	|	Identifier (. qualident = t.val; .)
	)
	/* .NET 2.0 */
	[ TypeParameterList<templates> ]
	
	"("
	[ "this" (. isExtensionMethod = true; /* C# 3.0 */ .) ]
	[ FormalParameterList<p> ] ")"
	(.	MethodDeclaration methodDeclaration = new MethodDeclaration {
			Name = qualident,
			Modifier = m.Modifier,
			TypeReference = new TypeReference("void"),
			Parameters = p,
			Attributes = attributes,
			StartLocation = m.GetDeclarationLocation(startPos),
			EndLocation = t.EndLocation,
			Templates = templates,
			IsExtensionMethod = isExtensionMethod
		};
		if (explicitInterface != null)
			methodDeclaration.InterfaceImplementations.Add(new InterfaceImplementation(explicitInterface, qualident));
		compilationUnit.AddChild(methodDeclaration);
		compilationUnit.BlockStart(methodDeclaration);
	.)
		
	/* .NET 2.0 */
	{ TypeParameterConstraintsClause<templates> }
	
	( Block<out stmt> | ";" )              (. compilationUnit.BlockEnd();
	                                          methodDeclaration.Body  = (BlockStatement)stmt;
	                                       .)
	
|	/*--- event declaration: */     (. m.Check(Modifiers.PropertysEventsMethods); .)
		"event"                     
		(.	EventDeclaration eventDecl = new EventDeclaration {
				Modifier = m.Modifier, 
				Attributes = attributes,
				StartLocation = t.Location
			};
			compilationUnit.AddChild(eventDecl);
			compilationUnit.BlockStart(eventDecl);
			EventAddRegion addBlock = null;
			EventRemoveRegion removeBlock = null;
		.)
		Type<out type>        (. eventDecl.TypeReference = type; .)
		( IF (IsExplicitInterfaceImplementation())
			TypeName<out explicitInterface, false>
			(. qualident = TypeReference.StripLastIdentifierFromType(ref explicitInterface); .)
			(. eventDecl.InterfaceImplementations.Add(new InterfaceImplementation(explicitInterface, qualident)); .)
			
		|	Identifier (. qualident = t.val; .)
		)
		(. eventDecl.Name = qualident; eventDecl.EndLocation = t.EndLocation; .)
		[   "=" Expr<out expr> (. eventDecl.Initializer = expr; .) ]
		[	"{" (. eventDecl.BodyStart = t.Location; .)
			EventAccessorDecls<out addBlock, out removeBlock> 
			"}" (. eventDecl.BodyEnd   = t.EndLocation; .)
		]
		[ ";" ]
		(. compilationUnit.BlockEnd();
		   eventDecl.AddRegion = addBlock;
		   eventDecl.RemoveRegion = removeBlock;
		.)
	
|   /*--- constructor or static contructor declaration: */
	IF (IdentAndLPar())                  (. m.Check(Modifiers.Constructors | Modifiers.StaticConstructors); .)
	Identifier (. string name = t.val; Location startPos = t.Location; .) "(" [  (. m.Check(Modifiers.Constructors); .)
	FormalParameterList<p>
	]
	")" (.ConstructorInitializer init = null;  .)
	[                                      (. m.Check(Modifiers.Constructors); .)
		ConstructorInitializer<out init>
	] (. 
	     ConstructorDeclaration cd = new ConstructorDeclaration(name, m.Modifier, p, init, attributes); 
	     cd.StartLocation = startPos;
	     cd.EndLocation   = t.EndLocation;
	  .)
	
	( Block<out stmt> | ";" ) (. cd.Body = (BlockStatement)stmt; compilationUnit.AddChild(cd); .)
	
	
|   /*--- conversion operator declaration: */   (. m.Check(Modifiers.Operators);
	                                          if (m.isNone) Error("at least one modifier must be set"); 
	                                          bool isImplicit = true;
	                                          Location startPos = Location.Empty;
	                                       .)
	( "implicit" (. startPos = t.Location; .) | "explicit" (. isImplicit = false; startPos = t.Location; .) ) 
	"operator" Type<out type> (. TypeReference operatorType = type; .) 
	"(" Type<out type> Identifier (. string varName = t.val; .) ")"
	(. Location endPos = t.Location; .)
	( Block<out stmt> | ";" (. stmt = null; .) )
	(.
		
		List<ParameterDeclarationExpression> parameters = new List<ParameterDeclarationExpression>();
		parameters.Add(new ParameterDeclarationExpression(type, varName));
		OperatorDeclaration operatorDeclaration = new OperatorDeclaration {
			Modifier = m.Modifier,
			Attributes = attributes, 
			Parameters = parameters, 
			TypeReference = operatorType,
			ConversionType = isImplicit ? ConversionType.Implicit : ConversionType.Explicit,
			Body = (BlockStatement)stmt,
			StartLocation = m.GetDeclarationLocation(startPos),
			EndLocation = endPos
		};
		compilationUnit.AddChild(operatorDeclaration);
	.)
	
	
|	/*--- inner type declaration: */
	TypeDecl<m, attributes>

|	Type<out type>                       (. Location startPos = t.Location;  .)
	(
		/*--- operator declaration: */     (. OverloadableOperatorType op;
		                                      m.Check(Modifiers.Operators);
		                                      if (m.isNone) Error("at least one modifier must be set");
		                                   .)
		"operator" OverloadableOperator<out op> (. TypeReference firstType, secondType = null; string secondName = null; .)
		"(" Type<out firstType> Identifier (. string firstName = t.val; .)
		( "," Type<out secondType> Identifier (. secondName = t.val; .)        /* (. if (Tokens.OverloadableUnaryOp[op.kind] && !Tokens.OverloadableBinaryOp[op.kind])
		                                      Error("too many operands for unary operator"); 
		                                   .)*/
		| /* empty */                      /*(. if (Tokens.OverloadableBinaryOp[op.kind]){
		                                      	Error("too few operands for binary operator");
		                                      }
		                                   .)*/
		)
		(. Location endPos = t.Location; .)
		")" ( Block<out stmt> | ";" )
		(.
			List<ParameterDeclarationExpression> parameters = new List<ParameterDeclarationExpression>();
			parameters.Add(new ParameterDeclarationExpression(firstType, firstName));
			if (secondType != null) {
				parameters.Add(new ParameterDeclarationExpression(secondType, secondName));
			}
			OperatorDeclaration operatorDeclaration = new OperatorDeclaration {
				Modifier = m.Modifier,
				Attributes = attributes,
				Parameters = parameters,
				TypeReference = type,
				OverloadableOperator = op,
				Body = (BlockStatement)stmt,
				StartLocation = m.GetDeclarationLocation(startPos),
				EndLocation = endPos
			};
			compilationUnit.AddChild(operatorDeclaration);
		.)
		
		/*--- field declaration: */
	| IF (IsVarDecl())
	    (.	m.Check(Modifiers.Fields);
			FieldDeclaration fd = new FieldDeclaration(attributes, type, m.Modifier);
			fd.StartLocation = m.GetDeclarationLocation(startPos); 
		.)
		( IF (m.Contains(Modifiers.Fixed))
			VariableDeclarator<variableDeclarators>
			"["
			Expr<out expr> (. if (variableDeclarators.Count > 0)
								variableDeclarators[variableDeclarators.Count-1].FixedArrayInitialization = expr; .)
			"]"
			{	","
				VariableDeclarator<variableDeclarators>
				"["
				Expr<out expr> (. if (variableDeclarators.Count > 0)
									variableDeclarators[variableDeclarators.Count-1].FixedArrayInitialization = expr; .)
				"]"
			}
		|	/* non-fixed field */
			VariableDeclarator<variableDeclarators>
			{ "," VariableDeclarator<variableDeclarators> }
		)
		";"                                (. fd.EndLocation = t.EndLocation; fd.Fields = variableDeclarators; compilationUnit.AddChild(fd); .)
		
		/*--- unqualified indexer declaration (without interface name): */
		|                                  (. m.Check(Modifiers.Indexers); .)
		"this" "[" FormalParameterList<p> "]" (. Location endLocation = t.EndLocation; .) "{" (.
			         IndexerDeclaration indexer = new IndexerDeclaration(type, p, m.Modifier, attributes);
			         indexer.StartLocation = startPos;
			         indexer.EndLocation   = endLocation;
			         indexer.BodyStart     = t.Location;
			         PropertyGetRegion getRegion;
			         PropertySetRegion setRegion;
			       .) 
		AccessorDecls<out getRegion, out setRegion> "}" (. 
			          indexer.BodyEnd    = t.EndLocation;
			          indexer.GetRegion = getRegion;
			          indexer.SetRegion = setRegion;
			          compilationUnit.AddChild(indexer);
			       .)
	|  IF (IsIdentifierToken(la))
		( IF (IsExplicitInterfaceImplementation())
			TypeName<out explicitInterface, false>
			(.if (la.kind != Tokens.Dot || Peek(1).kind != Tokens.This) {
				qualident = TypeReference.StripLastIdentifierFromType(ref explicitInterface);
			  } .)
		|	Identifier (. qualident = t.val; .)
		)
		(. Location qualIdentEndLocation = t.EndLocation; .)
		
		(
			/*--- "not void" method (function) declaration: */
			(                              (. m.Check(Modifiers.PropertysEventsMethods); .)
				/* .NET 2.0 */
				[ TypeParameterList<templates> ]
				"(" 
				[ "this" (. isExtensionMethod = true; .) ]
				[ FormalParameterList<p> ] ")"
				(.
					MethodDeclaration methodDeclaration = new MethodDeclaration {
						Name = qualident,
						Modifier = m.Modifier,
						TypeReference = type,
						Parameters = p, 
						Attributes = attributes
					};
					if (explicitInterface != null)
						methodDeclaration.InterfaceImplementations.Add(new InterfaceImplementation(explicitInterface, qualident));
					methodDeclaration.StartLocation = m.GetDeclarationLocation(startPos);
					methodDeclaration.EndLocation   = t.EndLocation;
					methodDeclaration.IsExtensionMethod = isExtensionMethod;
					methodDeclaration.Templates = templates;
					compilationUnit.AddChild(methodDeclaration);
				                                       .)
				{ TypeParameterConstraintsClause<templates> }
				( Block<out stmt> | ";" ) (. methodDeclaration.Body  = (BlockStatement)stmt; .)
			
			/*--- property declaration: */  
			| "{" (. PropertyDeclaration pDecl = new PropertyDeclaration(qualident, type, m.Modifier, attributes); 
					 if (explicitInterface != null)
						pDecl.InterfaceImplementations.Add(new InterfaceImplementation(explicitInterface, qualident));
			         pDecl.StartLocation = m.GetDeclarationLocation(startPos);
			         pDecl.EndLocation   = qualIdentEndLocation;
			         pDecl.BodyStart   = t.Location;
			         PropertyGetRegion getRegion;
			         PropertySetRegion setRegion;
			      .)
			   AccessorDecls<out getRegion, out setRegion> 
			   "}" (. 
			          pDecl.GetRegion = getRegion;
			          pDecl.SetRegion = setRegion;
			          pDecl.BodyEnd = t.EndLocation;
			          compilationUnit.AddChild(pDecl);
			       .)
			)
			
			/*--- qualified indexer declaration (with interface name): */
			|                              (. m.Check(Modifiers.Indexers); .)
			"." "this" "[" FormalParameterList<p> "]" (.
			         IndexerDeclaration indexer = new IndexerDeclaration(type, p, m.Modifier, attributes);
			         indexer.StartLocation = m.GetDeclarationLocation(startPos);
			         indexer.EndLocation   = t.EndLocation;
			         if (explicitInterface != null)
						indexer.InterfaceImplementations.Add(new InterfaceImplementation(explicitInterface, "this"));
			         PropertyGetRegion getRegion;
			         PropertySetRegion setRegion;
			       .) 
			  "{" (. Location bodyStart = t.Location; .)
			  AccessorDecls<out getRegion, out setRegion> 
			  "}"  (. indexer.BodyStart = bodyStart;
			          indexer.BodyEnd   = t.EndLocation;
			          indexer.GetRegion = getRegion;
			          indexer.SetRegion = setRegion;
			          compilationUnit.AddChild(indexer);
			       .)
		)
	)
.

ClassMemberDecl<ModifierList m, List<AttributeSection> attributes>
(. Statement stmt = null; .)
=
	StructMemberDecl<m, attributes>
	| /*--- destructor declaration: */ (. m.Check(Modifiers.Destructors); Location startPos = t.Location; .)
	"~" Identifier                     (. DestructorDeclaration d = new DestructorDeclaration(t.val, m.Modifier, attributes); 
	                                      d.Modifier = m.Modifier;
	                                      d.StartLocation = m.GetDeclarationLocation(startPos);
	                                   .)
	"(" ")" (. d.EndLocation = t.EndLocation; .) ( Block<out stmt> | ";" )  (. 
	                                      d.Body = (BlockStatement)stmt;
	                                      compilationUnit.AddChild(d);
	                                   .)
.

InterfaceMemberDecl
(.
	TypeReference type;
	
	AttributeSection section;
	Modifiers mod = Modifiers.None;
	List<AttributeSection> attributes = new List<AttributeSection>();
	List<ParameterDeclarationExpression> parameters = new List<ParameterDeclarationExpression>();
	string name;
	PropertyGetRegion getBlock;
	PropertySetRegion setBlock;
	Location startLocation = new Location(-1, -1);
	List<TemplateDefinition> templates = new List<TemplateDefinition>();
.)
=
	{ AttributeSection<out section>     (. attributes.Add(section); .)}
	[ "new" (. mod = Modifiers.New; startLocation = t.Location; .) ]
	(
		/*--- interface void method (procedure) declaration: */
		IF (NotVoidPointer()) "void" (. if (startLocation.X == -1) startLocation = t.Location; .)
		Identifier (. name = t.val; .)
		[ TypeParameterList<templates> ]
		"(" [ FormalParameterList<parameters> ] ")"
		{ TypeParameterConstraintsClause<templates> }
		";"
		(.  MethodDeclaration md = new MethodDeclaration {
				Name = name, Modifier = mod, TypeReference = new TypeReference("void"), 
				Parameters = parameters, Attributes = attributes, Templates = templates,
				StartLocation = startLocation, EndLocation = t.EndLocation
			};
			compilationUnit.AddChild(md);
		.)
		| (
			Type<out type> (. if (startLocation.X == -1) startLocation = t.Location; .)
			(
				Identifier            (. name = t.val; Location qualIdentEndLocation = t.EndLocation; .)
				(
					/*--- interface "not void" method (function) declaration: */
					/* .NET 2.0 */
					[ TypeParameterList<templates> ]
					"(" [ FormalParameterList<parameters> ] ")" 
					/* .NET 2.0 */
					{ TypeParameterConstraintsClause<templates> }
					";" (.  MethodDeclaration md = new MethodDeclaration {
								Name = name, Modifier = mod, TypeReference = type,
								Parameters = parameters, Attributes = attributes, Templates = templates,
								StartLocation = startLocation, EndLocation = t.EndLocation
							};
							compilationUnit.AddChild(md);
						.)
					/*--- interface property declaration: */
					|                   (. PropertyDeclaration pd = new PropertyDeclaration(name, type, mod, attributes); compilationUnit.AddChild(pd); .)
					"{" (. Location bodyStart = t.Location;.) InterfaceAccessors<out getBlock, out setBlock> "}" (. pd.GetRegion = getBlock; pd.SetRegion = setBlock; pd.StartLocation = startLocation; pd.EndLocation = qualIdentEndLocation; pd.BodyStart = bodyStart; pd.BodyEnd = t.EndLocation; .)
				)
				/*--- interface indexer declaration: */
			|	"this" "[" FormalParameterList<parameters> "]" (.Location bracketEndLocation = t.EndLocation; .)  (. IndexerDeclaration id = new IndexerDeclaration(type, parameters, mod, attributes); compilationUnit.AddChild(id); .)
				"{" (. Location bodyStart = t.Location;.) InterfaceAccessors<out getBlock, out setBlock> "}" (. id.GetRegion = getBlock; id.SetRegion = setBlock; id.StartLocation = startLocation;  id.EndLocation = bracketEndLocation; id.BodyStart = bodyStart; id.BodyEnd = t.EndLocation;.)
			)
			/*--- interface event declaration: */
			|	"event" (. if (startLocation.X == -1) startLocation = t.Location; .)
				Type<out type> Identifier
				(.	EventDeclaration ed = new EventDeclaration {
						TypeReference = type, Name = t.val, Modifier = mod, Attributes = attributes
					};
					compilationUnit.AddChild(ed);
				.)
			";"                        (. ed.StartLocation = startLocation; ed.EndLocation = t.EndLocation; .)
		)
	)
.

EnumMemberDecl<out FieldDeclaration f>
(.
	Expression expr = null;
	List<AttributeSection> attributes = new List<AttributeSection>();
	AttributeSection section = null;
	VariableDeclaration varDecl = null;
.)
=
	{ AttributeSection<out section> (. attributes.Add(section); .) }
	Identifier                      (. f = new FieldDeclaration(attributes);
	                                   varDecl         = new VariableDeclaration(t.val);
	                                   f.Fields.Add(varDecl);
	                                   f.StartLocation = t.Location;
	                                .)
	[ "=" Expr<out expr> (. varDecl.Initializer = expr; .) ]
.


AccessorDecls<out PropertyGetRegion getBlock, out PropertySetRegion setBlock>
(.
	List<AttributeSection> attributes = new List<AttributeSection>(); 
	AttributeSection section;
	getBlock = null;
	setBlock = null; 
	ModifierList modifiers = null;
.)
=
	{ AttributeSection<out section> (. attributes.Add(section); .) }
	[ AccessorModifiers<out modifiers> ]
	(
			GetAccessorDecl<out getBlock, attributes>
			(. if (modifiers != null) {getBlock.Modifier = modifiers.Modifier; } .)
			[  (. attributes = new List<AttributeSection>(); modifiers = null; .)
				{ AttributeSection<out section> (. attributes.Add(section); .) }
				[ AccessorModifiers<out modifiers> ]
				SetAccessorDecl<out setBlock, attributes>
				(. if (modifiers != null) {setBlock.Modifier = modifiers.Modifier; } .)
			]
		|
			SetAccessorDecl<out setBlock, attributes>
			(. if (modifiers != null) {setBlock.Modifier = modifiers.Modifier; } .)
			[  (. attributes = new List<AttributeSection>(); modifiers = null; .)
				{ AttributeSection<out section> (. attributes.Add(section); .) }
				[ AccessorModifiers<out modifiers> ]
				GetAccessorDecl<out getBlock, attributes>
				(. if (modifiers != null) {getBlock.Modifier = modifiers.Modifier; } .)
			]
		| Identifier (. Error("get or set accessor declaration expected"); .)
	)
.

GetAccessorDecl<out PropertyGetRegion getBlock, List<AttributeSection> attributes>
(. Statement stmt = null; .)
=
	"get"
	(. Location startLocation = t.Location; .)
	( Block<out stmt> | ";" )
	(. getBlock = new PropertyGetRegion((BlockStatement)stmt, attributes); .)
	(. getBlock.StartLocation = startLocation; getBlock.EndLocation = t.EndLocation; .)
.

SetAccessorDecl<out PropertySetRegion setBlock, List<AttributeSection> attributes>
(. Statement stmt = null; .)
=
	"set"
	(. Location startLocation = t.Location; .)
	( Block<out stmt> | ";" )
	(. setBlock = new PropertySetRegion((BlockStatement)stmt, attributes); .)
	(. setBlock.StartLocation = startLocation; setBlock.EndLocation = t.EndLocation; .)
.

EventAccessorDecls<out EventAddRegion addBlock, out EventRemoveRegion removeBlock>
(. AttributeSection section;
   List<AttributeSection> attributes = new List<AttributeSection>();
   Statement stmt;
   addBlock = null;
   removeBlock = null;
.)
=
	{ AttributeSection<out section> (. attributes.Add(section); .) }
	(
		                                    (. addBlock = new EventAddRegion(attributes); .)
			AddAccessorDecl<out stmt>       (. attributes = new List<AttributeSection>(); addBlock.Block = (BlockStatement)stmt; .)
			{ AttributeSection<out section> (. attributes.Add(section); .)}
			RemoveAccessorDecl<out stmt>    (. removeBlock = new EventRemoveRegion(attributes); removeBlock.Block = (BlockStatement)stmt; .)
		|
			RemoveAccessorDecl <out stmt>    (. removeBlock = new EventRemoveRegion(attributes); removeBlock.Block = (BlockStatement)stmt; attributes = new List<AttributeSection>(); .)
			{ AttributeSection<out section>  (. attributes.Add(section); .) }
			AddAccessorDecl<out stmt>        (. addBlock = new EventAddRegion(attributes); addBlock.Block = (BlockStatement)stmt; .)
	)
.

InterfaceAccessors<out PropertyGetRegion getBlock, out PropertySetRegion setBlock>
(.
	AttributeSection section;
	List<AttributeSection> attributes = new List<AttributeSection>();
	getBlock = null; setBlock = null;
	PropertyGetSetRegion lastBlock = null;
.)
=
	{ AttributeSection<out section> (. attributes.Add(section); .) }
	(. Location startLocation = la.Location; .)
	(
		"get"   (. getBlock = new PropertyGetRegion(null, attributes); .)
		| "set" (. setBlock = new PropertySetRegion(null, attributes); .)
	)
	";"
	(. if (getBlock != null) { getBlock.StartLocation = startLocation; getBlock.EndLocation = t.EndLocation; }
	   if (setBlock != null) { setBlock.StartLocation = startLocation; setBlock.EndLocation = t.EndLocation; }
	   attributes = new List<AttributeSection>(); .)
	[
		{ AttributeSection<out section> (. attributes.Add(section); .) }
		(. startLocation = la.Location; .)
		(
			"get"   (. if (getBlock != null) Error("get already declared");
			                             else { getBlock = new PropertyGetRegion(null, attributes); lastBlock = getBlock; }
			                          .)
			| "set" (. if (setBlock != null) Error("set already declared");
			                             else { setBlock = new PropertySetRegion(null, attributes); lastBlock = setBlock; }
			                          .)
		)
		";"
		(. if (lastBlock != null) { lastBlock.StartLocation = startLocation; lastBlock.EndLocation = t.EndLocation; } .)
	]
.

VariableDeclarator<List<VariableDeclaration> fieldDeclaration>
(. Expression expr = null; .)
=
	Identifier                            (. VariableDeclaration f = new VariableDeclaration(t.val); .)
	[ "=" VariableInitializer<out expr>   (. f.Initializer = expr; .) ] (. fieldDeclaration.Add(f); .)
.

Block<out Statement stmt> /* not BlockStatement because of EmbeddedStatement */
=
	"{" (. BlockStatement blockStmt = new BlockStatement();
	       blockStmt.StartLocation = t.Location;
	       compilationUnit.BlockStart(blockStmt);
	       if (!ParseMethodBodies) lexer.SkipCurrentBlock(0);
	    .)
	{ Statement }
	"}" (. 
	       stmt = blockStmt;
	       blockStmt.EndLocation = t.EndLocation;
	       compilationUnit.BlockEnd();
	    .)
.

AddAccessorDecl<out Statement stmt>
(.stmt = null;.) 
=
	"add"
	Block<out stmt>
.

RemoveAccessorDecl<out Statement stmt>
(.stmt = null;.) 
=
	"remove"
	Block<out stmt>
.

ConstructorInitializer<out ConstructorInitializer ci>
(. Expression expr; ci = new ConstructorInitializer(); .)
=
	":"
	(
		"base" (. ci.ConstructorInitializerType = ConstructorInitializerType.Base; .)
		| "this"  (. ci.ConstructorInitializerType = ConstructorInitializerType.This; .)
	) 
	"("
	[ Argument<out expr> (. if (expr != null) { ci.Arguments.Add(expr); } .) { "," Argument<out expr> (. if (expr != null) { ci.Arguments.Add(expr); } .) } ]
	")"
.

VariableInitializer<out Expression initializerExpression>
(. TypeReference type = null; Expression expr = null; initializerExpression = null; .)
=
	Expr<out initializerExpression>
	| CollectionInitializer<out initializerExpression>
	| "stackalloc" Type<out type> "[" Expr<out expr> "]" (. initializerExpression = new StackAllocExpression(type, expr); .)
.

OverloadableOperator<out OverloadableOperatorType op>
(. op = OverloadableOperatorType.None; .)
=
	"+"      (. op = OverloadableOperatorType.Add; .)
	| "-"    (. op = OverloadableOperatorType.Subtract; .)
	
	| "!"    (. op = OverloadableOperatorType.Not; .)
	| "~"    (. op = OverloadableOperatorType.BitNot; .)
	
	| "++"   (. op = OverloadableOperatorType.Increment; .)
	| "--"   (. op = OverloadableOperatorType.Decrement; .)
	
	| "true"   (. op = OverloadableOperatorType.IsTrue; .)
	| "false"   (. op = OverloadableOperatorType.IsFalse; .)
	
	| "*"    (. op = OverloadableOperatorType.Multiply; .)
	| "/"    (. op = OverloadableOperatorType.Divide; .)
	| "%"    (. op = OverloadableOperatorType.Modulus; .)
	
	| "&"    (. op = OverloadableOperatorType.BitwiseAnd; .)
	| "|"    (. op = OverloadableOperatorType.BitwiseOr; .)
	| "^"    (. op = OverloadableOperatorType.ExclusiveOr; .)
	
	| "<<"   (. op = OverloadableOperatorType.ShiftLeft; .)
	| "=="   (. op = OverloadableOperatorType.Equality; .)
	| "!="    (. op = OverloadableOperatorType.InEquality; .)
	| "<"     (. op = OverloadableOperatorType.LessThan; .)
	| ">="    (. op = OverloadableOperatorType.GreaterThanOrEqual; .)
	| "<="    (. op = OverloadableOperatorType.LessThanOrEqual; .)
	| ">"     (. op = OverloadableOperatorType.GreaterThan; .) [ ">" (. op = OverloadableOperatorType.ShiftRight; .) ]
.

Argument<out Expression argumentexpr>
(.
	Expression expr;
	FieldDirection fd = FieldDirection.None;
.)
=
	[
		"ref" (. fd = FieldDirection.Ref; .)
		| "out" (. fd = FieldDirection.Out; .)
	]
	Expr<out expr>
	(. argumentexpr = fd != FieldDirection.None ? argumentexpr = new DirectionExpression(fd, expr) : expr; .)
.

AssignmentOperator<out AssignmentOperatorType op>
(. op = AssignmentOperatorType.None; .)
=
	"="     (. op = AssignmentOperatorType.Assign; .)
	| "+="  (. op = AssignmentOperatorType.Add; .)
	| "-="  (. op = AssignmentOperatorType.Subtract; .)
	| "*="  (. op = AssignmentOperatorType.Multiply; .)
	| "/="  (. op = AssignmentOperatorType.Divide; .)
	| "%="  (. op = AssignmentOperatorType.Modulus; .)
	| "&="  (. op = AssignmentOperatorType.BitwiseAnd; .)
	| "|="  (. op = AssignmentOperatorType.BitwiseOr; .)
	| "^="  (. op = AssignmentOperatorType.ExclusiveOr; .)
	| "<<=" (. op = AssignmentOperatorType.ShiftLeft; .)
	| IF (la.kind == Tokens.GreaterThan && Peek(1).kind == Tokens.GreaterEqual)
		">" ">=" (. op = AssignmentOperatorType.ShiftRight; .)
.

CollectionInitializer<out Expression outExpr>
(.
	Expression expr = null;
	CollectionInitializerExpression initializer = new CollectionInitializerExpression();
.)
=
	"{" (. initializer.StartLocation = t.Location; .)
	[	VariableInitializer<out expr>
		(. if (expr != null) { initializer.CreateExpressions.Add(expr); } .)
		{ IF (NotFinalComma())
			"," VariableInitializer<out expr>
			(. if (expr != null) { initializer.CreateExpressions.Add(expr); } .)
		}
		[ "," ]
	]
	"}" (. initializer.EndLocation = t.Location; outExpr = initializer; .)
.

CollectionOrObjectInitializer<out Expression outExpr>
(.
	Expression expr = null;
	CollectionInitializerExpression initializer = new CollectionInitializerExpression();
.)
=
	"{" (. initializer.StartLocation = t.Location; .)
	[	ObjectPropertyInitializerOrVariableInitializer<out expr>
		(. if (expr != null) { initializer.CreateExpressions.Add(expr); } .)
		{ IF (NotFinalComma())
			"," ObjectPropertyInitializerOrVariableInitializer<out expr>
			(. if (expr != null) { initializer.CreateExpressions.Add(expr); } .)
		}
		[ "," ]
	]
	"}" (. initializer.EndLocation = t.Location; outExpr = initializer; .)
.

ObjectPropertyInitializerOrVariableInitializer<out Expression expr>
(. expr = null; .)
=
( IF (IdentAndAsgn())
	Identifier
	(. NamedArgumentExpression nae = new NamedArgumentExpression(t.val, null);
	   nae.StartLocation = t.Location;
	   Expression r = null; .)
	"=" 
	( CollectionOrObjectInitializer<out r>
	| VariableInitializer <out r> )
	(. nae.Expression = r; nae.EndLocation = t.EndLocation; expr = nae; .)
	
|	VariableInitializer <out expr>
)
.

LocalVariableDecl<out Statement stmt>
(.
	TypeReference type;
	VariableDeclaration      var = null;
	LocalVariableDeclaration localVariableDeclaration; 
.)
=
	Type<out type> (. localVariableDeclaration = new LocalVariableDeclaration(type); localVariableDeclaration.StartLocation = t.Location; .)
	LocalVariableDeclarator<out var> (. localVariableDeclaration.Variables.Add(var); .)
	{ "," LocalVariableDeclarator<out var> (. localVariableDeclaration.Variables.Add(var); .) }
	(. stmt = localVariableDeclaration; .)
.

LocalVariableDeclarator<out VariableDeclaration var>
(. Expression expr = null; .)
=
	Identifier (. var = new VariableDeclaration(t.val); .)
	[ "=" VariableInitializer<out expr> (. var.Initializer = expr; .) ]
.

Statement
(.
	TypeReference type;
	Expression expr;
	Statement stmt = null;
	Location startPos = la.Location;
.)
=
	SYNC
	(
		/*--- labeled statement: */
		IF (IsLabel()) Identifier (. compilationUnit.AddChild(new LabelStatement(t.val)); .)
		":" Statement
		/*--- local constant declaration: */
		| "const" Type<out type> (. LocalVariableDeclaration var = new LocalVariableDeclaration(type, Modifiers.Const); string ident = null; var.StartLocation = t.Location; .) 
		  Identifier (. ident = t.val; .)
		  "=" Expr<out expr> (. var.Variables.Add(new VariableDeclaration(ident, expr)); .)
		  { "," Identifier (. ident = t.val; .) "=" Expr<out expr> (. var.Variables.Add(new VariableDeclaration(ident, expr)); .) }
		  ";" (. compilationUnit.AddChild(var); .)

		/*--- local variable declaration: */
	|	IF (IsLocalVarDecl()) LocalVariableDecl<out stmt> ";" (. compilationUnit.AddChild(stmt); .)
	
	|	EmbeddedStatement<out stmt> (. compilationUnit.AddChild(stmt); .)
		/* LL(1) confict: LocalVariableDecl *
		 *            <-> StatementExpr     *
		 * ident {"." ident} { "[" Expr ... */
	)
	(.
		if (stmt != null) {
			stmt.StartLocation = startPos;
			stmt.EndLocation = t.EndLocation;
		}
	.)
.

EmbeddedStatement<out Statement statement>
(.
	TypeReference type = null;
	Expression expr = null;
	Statement embeddedStatement = null;
	statement = null;
.)
=
	(. Location startLocation = la.Location; .)
	(
		Block<out statement>
	
		/*--- empty statement: */
	|	";"                       (. statement = new EmptyStatement(); .)
	
		/*--- checked / unchecked statement: */
	|	IF (UnCheckedAndLBrace()) (. Statement block; bool isChecked = true; .)
		("checked" | "unchecked"    (. isChecked = false;.) )
		Block<out block>            (. statement = isChecked ? (Statement)new CheckedStatement(block) : (Statement)new UncheckedStatement(block); .)
	
		/*--- selection statements (if, switch): */
	|	IfStatement<out statement>
	
	|	"switch" (. List<SwitchSection> switchSections = new List<SwitchSection>(); .)
		  "(" Expr<out expr> ")"
		  "{" SwitchSections<switchSections>
		  "}"  (. statement = new SwitchStatement(expr, switchSections); .)
	
		/*--- iteration statements (while, do, for, foreach): */
	|	"while" "(" Expr<out expr> ")"
		EmbeddedStatement<out embeddedStatement>
		(. statement = new DoLoopStatement(expr, embeddedStatement, ConditionType.While, ConditionPosition.Start);.)
	
	|	"do" EmbeddedStatement<out embeddedStatement> "while"
		"(" Expr<out expr> ")" ";" 
		(. statement = new DoLoopStatement(expr, embeddedStatement, ConditionType.While, ConditionPosition.End); .)
	
	|	"for" (. List<Statement> initializer = null; List<Statement> iterator = null; .)
		  "(" [ ForInitializer<out initializer> ] ";"
		  [ Expr<out expr> ] ";"
		  [ ForIterator<out iterator> ] ")"
		  EmbeddedStatement<out embeddedStatement> (. statement = new ForStatement(initializer, expr, iterator, embeddedStatement); .)
	
	|	"foreach" "(" Type<out type> Identifier   (. string varName = t.val; .)
		"in" Expr<out expr> ")"
		EmbeddedStatement<out embeddedStatement>
		(.  statement = new ForeachStatement(type, varName , expr, embeddedStatement); .)
	
		/*--- jump statements (break, contine, goto, return, throw): */
	|	"break" ";"               (. statement = new BreakStatement(); .)
	|	"continue" ";"            (. statement = new ContinueStatement(); .)
	|	GotoStatement<out statement>
	
	|	IF (IsYieldStatement()) "yield"
		( "return" Expr<out expr> (. statement = new YieldStatement(new ReturnStatement(expr)); .)
		| "break" (. statement = new YieldStatement(new BreakStatement()); .) )
		";"
	
	|	"return" [ Expr<out expr> ] ";"    (. statement = new ReturnStatement(expr); .)
	|	"throw" [ Expr<out expr> ] ";"     (. statement = new ThrowStatement(expr); .)
	  
		/*--- expression statement: */
	|	StatementExpr<out statement> SYNC ";"
	
		/*--- try statement: */
	|	TryStatement<out statement>
	
		/*--- lock satement: */
	|	"lock" "(" Expr<out expr> ")"
		EmbeddedStatement<out embeddedStatement> (. statement = new LockStatement(expr, embeddedStatement); .)
	
		/*--- using statement: */
	|	(.Statement resourceAcquisitionStmt = null; .)
		"using" "("
		ResourceAcquisition<out resourceAcquisitionStmt> ")"
		EmbeddedStatement<out embeddedStatement> (. statement = new UsingStatement(resourceAcquisitionStmt, embeddedStatement); .)
	
		/*--- unsafe statement: */
	|	"unsafe" Block<out embeddedStatement>  (. statement = new UnsafeStatement(embeddedStatement); .)
		/*--- fixed statement: */
	|	"fixed"
		"(" Type<out type>     (. if (type == null || type.PointerNestingLevel == 0) Error("can only fix pointer types");
		                          List<VariableDeclaration> pointerDeclarators = new List<VariableDeclaration>(1);
		                       .)
		Identifier             (. string identifier = t.val; .)
		"=" Expr<out expr>     (. pointerDeclarators.Add(new VariableDeclaration(identifier, expr)); .)
		{
			"," Identifier     (. identifier = t.val; .)
			"=" Expr<out expr> (. pointerDeclarators.Add(new VariableDeclaration(identifier, expr)); .)
		}
		")" EmbeddedStatement<out embeddedStatement>  (. statement = new FixedStatement(type, pointerDeclarators, embeddedStatement); .)
	)
	(.	if (statement != null) {
			statement.StartLocation = startLocation;
			statement.EndLocation = t.EndLocation;
		}
	.)
.

IfStatement<out Statement statement>
(.
	Expression expr = null;
	Statement embeddedStatement = null;
	statement = null;
.)
=
	"if"
	"(" Expr<out expr> ")"
	EmbeddedStatement<out embeddedStatement>
	(. Statement elseStatement = null; .)
	[ "else" EmbeddedStatement<out elseStatement> ]
	(. statement = elseStatement != null ? new IfElseStatement(expr, embeddedStatement, elseStatement) : new IfElseStatement(expr, embeddedStatement); .)
	(. if (elseStatement is IfElseStatement && (elseStatement as IfElseStatement).TrueStatement.Count == 1) {
		/* else if-section (otherwise we would have a BlockStatment) */
		(statement as IfElseStatement).ElseIfSections.Add(
		             new ElseIfSection((elseStatement as IfElseStatement).Condition,
		                               (elseStatement as IfElseStatement).TrueStatement[0]));
		(statement as IfElseStatement).ElseIfSections.AddRange((elseStatement as IfElseStatement).ElseIfSections);
		(statement as IfElseStatement).FalseStatement = (elseStatement as IfElseStatement).FalseStatement;
		}
	.)
.

ForInitializer<out List<Statement> initializer>
(.
	Statement stmt; 
	initializer = new List<Statement>();
.)
=
	IF (IsLocalVarDecl()) LocalVariableDecl<out stmt> (. initializer.Add(stmt);.)
	| StatementExpr<out stmt> (.initializer.Add(stmt);.) { "," StatementExpr<out stmt> (. initializer.Add(stmt);.) }
.

ForIterator<out List<Statement> iterator>
(.
	Statement stmt; 
	iterator = new List<Statement>();
.)
=
	StatementExpr<out stmt> (. iterator.Add(stmt);.) { "," StatementExpr<out stmt> (. iterator.Add(stmt); .) }
.

SwitchSections<List<SwitchSection> switchSections>
(.
	SwitchSection switchSection = new SwitchSection();
	CaseLabel label;
.)
=
	SwitchLabel<out label> (. if (label != null) { switchSection.SwitchLabels.Add(label); } .) 
	(. compilationUnit.BlockStart(switchSection); .)
	{
		( SwitchLabel<out label>
		  (. if (label != null) {
		  		if (switchSection.Children.Count > 0) {
		  			// open new section
		  			compilationUnit.BlockEnd(); switchSections.Add(switchSection);
		  			switchSection = new SwitchSection();
		  			compilationUnit.BlockStart(switchSection);
		  		}
		  		switchSection.SwitchLabels.Add(label);
		  	 }
		  .)
		| Statement)
	}
	(. compilationUnit.BlockEnd(); switchSections.Add(switchSection); .)
.

SwitchLabel<out CaseLabel label>
 (. Expression expr = null; label = null; .)
=
	"case" Expr<out expr> ":" (. label =  new CaseLabel(expr); .)
	| "default" ":" (. label =  new CaseLabel(); .)
.

TryStatement<out Statement tryStatement>
(.
	Statement blockStmt = null, finallyStmt = null;
	List<CatchClause> catchClauses = null;
.)
=
	"try"  Block<out blockStmt>
	(
		CatchClauses<out catchClauses> [ "finally" Block<out finallyStmt> ]
		| "finally" Block<out finallyStmt>
	)
	(.
		tryStatement = new TryCatchStatement(blockStmt, catchClauses, finallyStmt);
	
	.)
.

CatchClauses<out List<CatchClause> catchClauses>
(.
	catchClauses = new List<CatchClause>();
.)
=
	"catch" (. string identifier;
	           Statement stmt;
	           TypeReference typeRef;
	        .)
	/*--- general catch clause (as only catch clause) */
	(
		Block<out stmt> (. catchClauses.Add(new CatchClause(stmt)); .)
		/*--- specific catch clause */
		| "(" ClassType<out typeRef, false> (. identifier = null; .)
			[ Identifier (. identifier = t.val; .) ]
		   ")" Block<out stmt> 
		   (. catchClauses.Add(new CatchClause(typeRef, identifier, stmt)); .)
		{ IF (IsTypedCatch()) "catch" "(" ClassType<out typeRef, false> (. identifier = null; .)
			[ Identifier (. identifier = t.val; .) ]
		   ")" Block<out stmt>
		   (. catchClauses.Add(new CatchClause(typeRef, identifier, stmt)); .) }
		/*--- general catch clause (after specific catch clauses, optional) */
		[ "catch" Block<out stmt> (. catchClauses.Add(new CatchClause(stmt)); .) ]
	)
.

GotoStatement<out Statement stmt>
(. Expression expr; stmt = null; .)
=
	"goto"
	(
		Identifier (. stmt = new GotoStatement(t.val); .) ";"
		| "case" Expr<out expr>  ";" (. stmt = new GotoCaseStatement(expr); .)
		| "default" ";" (. stmt = new GotoCaseStatement(null); .)
	)
.

ResourceAcquisition<out Statement stmt>
(.
	stmt = null;
	Expression expr;
.)
=
	(
		IF (IsLocalVarDecl()) LocalVariableDecl<out stmt>
		| Expr<out expr> /* LL(1) conflict resoltion:                             *
		                  * check if next is Qualident followed by ident          *
		                  * ==> LocalVariableDecl                                 *
		                  * new problem: first set of ResourceAcquisition changes */
		(. stmt = new ExpressionStatement(expr); .)
	)
.

StatementExpr<out Statement stmt>
(. Expression expr; .)
=
	Expr<out expr>
	/* The grammar allows only assignments or method invocations here, */
	/* but we don't enforce that here */
	(. stmt = new ExpressionStatement(expr); .)
.

Expr<out Expression expr>
(. expr = null; Expression expr1 = null, expr2 = null; AssignmentOperatorType op; .)
=
	(. Location startLocation = la.Location; .)
	UnaryExpr<out expr>
	/*--- conditional expression: */
	(	
		( AssignmentOperator<out op> Expr<out expr1> (. expr = new AssignmentExpression(expr, op, expr1); .) )
		| IF (la.kind == Tokens.GreaterThan && Peek(1).kind == Tokens.GreaterEqual)
		  ( AssignmentOperator<out op> Expr<out expr1> (. expr = new AssignmentExpression(expr, op, expr1); .) )
		| (
			ConditionalOrExpr<ref expr>
			[ "??" Expr<out expr1> (. expr = new BinaryOperatorExpression(expr, BinaryOperatorType.NullCoalescing, expr1); .) ]
			[ "?" Expr<out expr1> ":" Expr<out expr2> (. expr = new ConditionalExpression(expr, expr1, expr2);  .) ]
		)
	)
	(.	if (expr != null) {
			expr.StartLocation = startLocation;
			expr.EndLocation = t.EndLocation;
		}
	.)
.


UnaryExpr<out Expression uExpr>
(.
	TypeReference type = null;
	Expression expr = null;
	ArrayList expressions = new ArrayList();
	uExpr = null;
.)
=
	{
		/* IF (Tokens.UnaryOp[la.kind] || IsTypeCast()) */
		(
			  "+"  (. expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.Plus)); .)
			| "-"  (. expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.Minus)); .)
			| "!"  (. expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.Not)); .)
			| "~"  (. expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.BitNot)); .)
			| "*"  (. expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.Star)); .)
			| "++" (. expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.Increment)); .)
			| "--" (. expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.Decrement)); .)
			| "&"  (. expressions.Add(new UnaryOperatorExpression(UnaryOperatorType.BitWiseAnd)); .)
			
			/*--- cast expression: */
			/* Problem:  "(" Type ")" from here and                     *
			 *           "(" Expr ")" from PrimaryExpr                  *
			 * Solution: (in IsTypeCast())                              */
			| IF (IsTypeCast()) "(" Type<out type> ")"  (.  expressions.Add(new CastExpression(type)); .)
		)
	}
	
	/* special rule (2.4.4.2) to allow writing int.MinValue and long.MinValue */
	( IF (LastExpressionIsUnaryMinus(expressions) && IsMostNegativeIntegerWithoutTypeSuffix())
		Literal
		(.
			expressions.RemoveAt(expressions.Count - 1);
			if (t.literalValue is uint) {
				expr = new PrimitiveExpression(int.MinValue, int.MinValue.ToString());
			} else if (t.literalValue is ulong) {
				expr = new PrimitiveExpression(long.MinValue, long.MinValue.ToString());
			} else {
				throw new Exception("t.literalValue must be uint or ulong");
			}
		.)
	|	PrimaryExpr<out expr> 
	)
	(.	for (int i = 0; i < expressions.Count; ++i) {
			Expression nextExpression = i + 1 < expressions.Count ? (Expression)expressions[i + 1] : expr;
			if (expressions[i] is CastExpression) {
				((CastExpression)expressions[i]).Expression = nextExpression;
			} else {
				((UnaryOperatorExpression)expressions[i]).Expression = nextExpression;
			}
		}
		if (expressions.Count > 0) {
			uExpr = (Expression)expressions[0];
		} else {
			uExpr = expr;
		}
	.)
.


PrimaryExpr<out Expression pexpr>
(.
	TypeReference type = null;
	Expression expr;
	pexpr = null;
.)
=
	(. Location startLocation = la.Location; .)
	(
		"true"                              (.pexpr = new PrimitiveExpression(true, "true");  .)
	|	"false"                           (.pexpr = new PrimitiveExpression(false, "false"); .)
	|	"null"                            (.pexpr = new PrimitiveExpression(null, "null");  .)          /* from literal token */
	|	Literal                           (.pexpr = new PrimitiveExpression(t.literalValue, t.val);  .)
	| IF (StartOfQueryExpression())
		QueryExpression<out pexpr>
	| IF (IdentAndDoubleColon())
		Identifier (. type = new TypeReference(t.val); .)
		"::"  (. pexpr = new TypeReferenceExpression(type); .)
		Identifier (. if (type.Type == "global") { type.IsGlobal = true; type.Type = (t.val ?? "?"); } else type.Type += "." + (t.val ?? "?"); .)

		/*--- simple name (IdentifierExpression): */
	|	Identifier
		(. pexpr = new IdentifierExpression(t.val); .)
		
		[	ShortedLambdaExpression<(IdentifierExpression)pexpr, out pexpr> 
		| IF (IsGenericInSimpleNameOrMemberAccess())
			(. List<TypeReference> typeList; .)
			TypeArgumentList<out typeList, false>
			(. ((IdentifierExpression)pexpr).TypeArguments = typeList; .)
		]
	| IF (IsLambdaExpression()) /* Lambda expression */
		LambdaExpression<out pexpr>

		/*--- parenthesized expression: */
	|	"(" Expr<out expr> ")" (. pexpr = new ParenthesizedExpression(expr); .)
	
	| /*--- predefined type member access: */
		(. string val = null; .)
		( "bool" (. val = "bool"; .) 
		| "byte" (. val = "byte"; .)   
		| "char" (. val = "char"; .)
		| "decimal" (. val = "decimal"; .)
		| "double"  (. val = "double"; .)
		| "float"   (. val = "float"; .)
		| "int"     (. val = "int"; .)
		| "long"  (. val = "long"; .)
		| "object"   (. val = "object"; .)
		| "sbyte" (. val = "sbyte"; .)
		| "short"   (. val = "short"; .)
		| "string"  (. val = "string"; .)
		| "uint"  (. val = "uint"; .)
		| "ulong"    (. val = "ulong"; .)
		| "ushort" (. val = "ushort"; .)
		)
		MemberAccess<out pexpr, new TypeReferenceExpression(val) { StartLocation = t.Location, EndLocation = t.EndLocation } >
		
		/*--- this access: */
	|	"this"                              (. pexpr = new ThisReferenceExpression(); .)
		/*--- base access: */
	|	"base"                              (. pexpr = new BaseReferenceExpression(); .)
	
		/* new ... - ObjectCreationExpression or ArrayCreateExpression */
	|	NewExpression<out pexpr>
	
	|	"typeof" "("
		(
			IF (NotVoidPointer()) "void" (. type = new TypeReference("void"); .)
		|	TypeWithRestriction<out type, true, true>
		)
		")"                            (. pexpr = new TypeOfExpression(type); .)
		
	|	"default" "(" Type<out type> ")" (. pexpr = new DefaultValueExpression(type); .)
	|	"sizeof" "(" Type<out type> ")" (. pexpr = new SizeOfExpression(type); .)
	|	"checked" "(" Expr<out expr> ")" (. pexpr = new CheckedExpression(expr); .)
	|	"unchecked" "(" Expr<out expr> ")" (. pexpr = new UncheckedExpression(expr); .)
	|	"delegate" AnonymousMethodExpr<out expr> (. pexpr = expr; .)
	)
	(.	if (pexpr != null) {
			pexpr.StartLocation = startLocation;
			pexpr.EndLocation = t.EndLocation;
		}
	.)
	{
		(. startLocation = la.Location; .)
		(
			"++"   (. pexpr = new UnaryOperatorExpression(pexpr, UnaryOperatorType.PostIncrement); .)
			| "--" (. pexpr = new UnaryOperatorExpression(pexpr, UnaryOperatorType.PostDecrement); .)
		)
		/*--- member access */
		| PointerMemberAccess<out pexpr, pexpr>
		| MemberAccess<out pexpr, pexpr>
			
		/*--- invocation expression: */
		| "("                        (. List<Expression> parameters = new List<Expression>(); .)
			[ Argument<out expr>     (. if (expr != null) {parameters.Add(expr);} .)
			  { "," Argument<out expr> (. if (expr != null) {parameters.Add(expr);} .)
			  }
			]
			")" (. pexpr = new InvocationExpression(pexpr, parameters); .)
		/*--- element access */
		|  (. /*if (isArrayCreation) Error("element access not allow on array creation");*/
		      List<Expression> indices = new List<Expression>();
		   .)
		"[" Expr<out expr> (. if (expr != null) { indices.Add(expr); } .)
		{ "," Expr<out expr> (. if (expr != null) { indices.Add(expr); } .)
		} "]" (. pexpr = new IndexerExpression(pexpr, indices); .)
		
		(.	if (pexpr != null) {
				pexpr.StartLocation = startLocation;
				pexpr.EndLocation = t.EndLocation;
			}
		.)
	}
.

MemberAccess<out Expression expr, Expression target>
(. List<TypeReference> typeList; .)
=
	(.	if (ShouldConvertTargetExpressionToTypeReference(target)) {
			TypeReference type = GetTypeReferenceFromExpression(target);
			if (type != null) {
				target = new TypeReferenceExpression(type) { StartLocation = t.Location, EndLocation = t.EndLocation };
			}
		}
		t.val = ""; // required for TypeReferenceExpressionTests.StandaloneIntReferenceExpression hack
	.)
	"."
	Identifier
	(. expr = new MemberReferenceExpression(target, t.val); .)
	[ IF (IsGenericInSimpleNameOrMemberAccess())
		TypeArgumentList<out typeList, false>
		(. ((MemberReferenceExpression)expr).TypeArguments = typeList; .)
	]
.

PointerMemberAccess<out Expression expr, Expression target>
(. List<TypeReference> typeList; .)
=
	"->"
	Identifier
	(. expr = new PointerReferenceExpression(target, t.val); .)
	[ IF (IsGenericInSimpleNameOrMemberAccess())
		TypeArgumentList<out typeList, false>
		(. ((MemberReferenceExpression)expr).TypeArguments = typeList; .)
	]
.

NewExpression<out Expression pexpr>
(.	pexpr = null;
	List<Expression> parameters = new List<Expression>();
	TypeReference type = null;
	Expression expr;
.)
=
	"new"
	[ NonArrayType<out type> ] /* optional since .NET 3.0 */
	
	/*--- delegate / object creation expression: */
	/* Note: a delegate creation expression allow only a single Expr  */
	/*       not an argument list, but this is not distinguished here */
	(
		(	(. ObjectCreateExpression oce = new ObjectCreateExpression(type, parameters); .)
			"(" (. if (type == null) Error("Cannot use an anonymous type with arguments for the constructor"); .)
			    [ Argument<out expr>          (. if (expr != null) { parameters.Add(expr); } .)
			      { "," Argument<out expr>    (. if (expr != null) { parameters.Add(expr); } .) }
			    ]
			")" (. pexpr = oce; .)
			[ CollectionOrObjectInitializer<out expr> (. oce.ObjectInitializer = (CollectionInitializerExpression)expr; .) ]
		|	(. ObjectCreateExpression oce = new ObjectCreateExpression(type, parameters); .)
			CollectionOrObjectInitializer<out expr> (. oce.ObjectInitializer = (CollectionInitializerExpression)expr; .)
			(. pexpr = oce; .)
		)
		
	/*--- array creation expression: */
	|	"["
		(.	ArrayCreateExpression ace = new ArrayCreateExpression(type);
			/* we must not change RankSpecifier on the null type reference*/
			if (ace.CreateType.IsNull) { ace.CreateType = new TypeReference(""); }
			pexpr = ace;
			int dims = 0; List<int> ranks = new List<int>();
		.)
		(
			{ "," (. dims += 1; .) }
			"]" (. ranks.Add(dims); dims = 0; .)
			{ "[" { "," (. ++dims; .) } "]" (. ranks.Add(dims); dims = 0; .) }
			(. ace.CreateType.RankSpecifier = ranks.ToArray(); .)
			CollectionInitializer<out expr> (. ace.ArrayInitializer = (CollectionInitializerExpression)expr; .)
		|	Expr<out expr> (. if (expr != null) parameters.Add(expr); .)
			{	"," (. dims += 1; .)
				Expr<out expr> (. if (expr != null) parameters.Add(expr); .)
			}
			"]" (. ranks.Add(dims); ace.Arguments = parameters; dims = 0; .)
			{ "[" { "," (. ++dims; .) } "]" (. ranks.Add(dims); dims = 0; .) }
			(. ace.CreateType.RankSpecifier = ranks.ToArray(); .)
			[ CollectionInitializer<out expr> (. ace.ArrayInitializer = (CollectionInitializerExpression)expr; .) ]
		)
	)
.

/* Lambda expression with parameter list */
LambdaExpression<out Expression outExpr>
(.
	LambdaExpression lambda = new LambdaExpression();
	lambda.StartLocation = la.Location;
	ParameterDeclarationExpression p;
	outExpr = lambda;
.)
=
	"("
	[
		LambdaExpressionParameter<out p> (. if (p != null) lambda.Parameters.Add(p); .)
		{ ","
			LambdaExpressionParameter<out p> (. if (p != null) lambda.Parameters.Add(p); .)
		}
	]
	")"
	"=>"
	LambdaExpressionBody<lambda>
.

ShortedLambdaExpression<IdentifierExpression ident, out Expression pexpr>
(. LambdaExpression lambda = new LambdaExpression(); pexpr = lambda; .)
=
	"=>"
	/* not an IdentifierExpression, but a short lambda expression*/
	(.
		lambda.StartLocation = ident.StartLocation;
		lambda.Parameters.Add(new ParameterDeclarationExpression(null, ident.Identifier));
		lambda.Parameters[0].StartLocation = ident.StartLocation;
		lambda.Parameters[0].EndLocation = ident.EndLocation;
	.)
	LambdaExpressionBody<lambda>
.

LambdaExpressionParameter<out ParameterDeclarationExpression p>
(.	Location start = la.Location; p = null;
	TypeReference type;
.)
=
	( IF (Peek(1).kind == Tokens.Comma || Peek(1).kind == Tokens.CloseParenthesis)
		Identifier
		(.	p = new ParameterDeclarationExpression(null, t.val);
			p.StartLocation = start; p.EndLocation = t.EndLocation;
		.)
	|	Type<out type>
		Identifier
		(.	p = new ParameterDeclarationExpression(type, t.val);
			p.StartLocation = start; p.EndLocation = t.EndLocation;
		.)
	)
.

LambdaExpressionBody<LambdaExpression lambda>
(. Expression expr; BlockStatement stmt; .)
=
	(
		BlockInsideExpression<out stmt> (. lambda.StatementBody = stmt; .)
	|	Expr<out expr> (. lambda.ExpressionBody = expr; .)
	)
	(. lambda.EndLocation = t.EndLocation; .)
.

AnonymousMethodExpr<out Expression outExpr>
(.
	AnonymousMethodExpression expr = new AnonymousMethodExpression();
	expr.StartLocation = t.Location;
	BlockStatement stmt;
	List<ParameterDeclarationExpression> p = new List<ParameterDeclarationExpression>();
	outExpr = expr;
.)
=
	[
		"("
		[ FormalParameterList<p> (. expr.Parameters = p; .) ]
		")"
		(. expr.HasParameterList = true; .)
	]
	BlockInsideExpression<out stmt> (. expr.Body  = stmt; .)
	(. expr.EndLocation = t.Location; .)
.

BlockInsideExpression<out BlockStatement outStmt>
(. Statement stmt = null; outStmt = null; .)
=
	/*--- ParseExpression doesn't set a compilation unit, */
	/*--- so we can't use block then -> skip body of anonymous method */
	(. if (compilationUnit != null) { .)
		Block<out stmt> (. outStmt = (BlockStatement)stmt; .)
	(. } else { .)
		"{"
		(. lexer.SkipCurrentBlock(0); .)
		"}"
	(. } .)
.

ConditionalOrExpr<ref Expression outExpr>
(. Expression expr;   .)
=
	ConditionalAndExpr<ref outExpr>  { "||" UnaryExpr<out expr> ConditionalAndExpr<ref expr> (.  outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.LogicalOr, expr);  .) }
.

ConditionalAndExpr<ref Expression outExpr>
(. Expression expr; .)
=
	InclusiveOrExpr<ref outExpr>  { "&&" UnaryExpr<out expr> InclusiveOrExpr<ref expr> (.  outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.LogicalAnd, expr);  .) }
.

InclusiveOrExpr<ref Expression outExpr>
(. Expression expr; .)
=
	ExclusiveOrExpr<ref outExpr>  { "|" UnaryExpr<out expr> ExclusiveOrExpr<ref expr> (.  outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.BitwiseOr, expr);  .) }
.

ExclusiveOrExpr<ref Expression outExpr>
(. Expression expr; .)
=
	AndExpr<ref outExpr>  { "^" UnaryExpr<out expr> AndExpr<ref expr> (.  outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.ExclusiveOr, expr);  .) }
.

AndExpr<ref Expression outExpr>
(. Expression expr; .)
=
	EqualityExpr<ref outExpr> { "&" UnaryExpr<out expr> EqualityExpr<ref expr> (.  outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.BitwiseAnd, expr);  .) }
.

EqualityExpr<ref Expression outExpr>
(.
	Expression expr;
	BinaryOperatorType op = BinaryOperatorType.None;
.)
=
	RelationalExpr<ref outExpr>
	{
		(
			"!="   (. op = BinaryOperatorType.InEquality; .)
			| "==" (. op = BinaryOperatorType.Equality; .)
		)
		UnaryExpr<out expr> RelationalExpr<ref expr> (.  outExpr = new BinaryOperatorExpression(outExpr, op, expr);  .) 
	}
.

RelationalExpr<ref Expression outExpr>
(.
	TypeReference type;
	Expression expr;
	BinaryOperatorType op = BinaryOperatorType.None;
.)
=
	ShiftExpr<ref outExpr>
	{
		(	"<"    (. op = BinaryOperatorType.LessThan; .)
		|	">"  (. op = BinaryOperatorType.GreaterThan; .)
		|	"<=" (. op = BinaryOperatorType.LessThanOrEqual; .)
		|	">=" (. op = BinaryOperatorType.GreaterThanOrEqual; .)
		)
		UnaryExpr<out expr>
		ShiftExpr<ref expr>
		(. outExpr = new BinaryOperatorExpression(outExpr, op, expr); .)
	|
		(	"is"
			TypeWithRestriction<out type, false, false>
			[ IF (la.kind == Tokens.Question && !IsPossibleExpressionStart(Peek(1).kind))
				NullableQuestionMark<ref type> ]
			(. outExpr = new TypeOfIsExpression(outExpr, type); .)
		|	"as"
			TypeWithRestriction<out type, false, false>
			[ IF (la.kind == Tokens.Question && !IsPossibleExpressionStart(Peek(1).kind))
				NullableQuestionMark<ref type> ]
			(. outExpr = new CastExpression(type, outExpr, CastType.TryCast); .)
		)
	}
.

ShiftExpr<ref Expression outExpr>
(.
	Expression expr;
	BinaryOperatorType op = BinaryOperatorType.None;
.)
=
	AdditiveExpr<ref outExpr> 
	{
		(	"<<"   (. op = BinaryOperatorType.ShiftLeft; .)
			| IF (IsShiftRight()) (
				">" ">" (. op = BinaryOperatorType.ShiftRight; .)
			)
		)
		UnaryExpr<out expr> AdditiveExpr<ref expr> (.  outExpr = new BinaryOperatorExpression(outExpr, op, expr);  .) 
	}
.

AdditiveExpr<ref Expression outExpr>
(.
	Expression expr;
	BinaryOperatorType op = BinaryOperatorType.None;
.)
=
	MultiplicativeExpr<ref outExpr>
	{
		(
			"+"   (. op = BinaryOperatorType.Add; .)
			| "-" (. op = BinaryOperatorType.Subtract; .)
		)
		UnaryExpr<out expr> MultiplicativeExpr<ref expr> (.  outExpr = new BinaryOperatorExpression(outExpr, op, expr);  .)
	}
.

MultiplicativeExpr<ref Expression outExpr>
(.
	Expression expr;
	BinaryOperatorType op = BinaryOperatorType.None;
.)
=
	{
		(
			"*"   (. op = BinaryOperatorType.Multiply; .)
			| "/" (. op = BinaryOperatorType.Divide; .)
			| "%" (. op = BinaryOperatorType.Modulus; .)
		) 
		UnaryExpr<out expr> (. outExpr = new BinaryOperatorExpression(outExpr, op, expr); .) 
	}
.

/* .NET 2.0 rules */	

TypeName<out TypeReference typeRef, bool canBeUnbound>
(.	List<TypeReference> typeArguments = null;
	string alias = null;
	string qualident;
.)
=
	[ IF (IdentAndDoubleColon())
		Identifier (. alias = t.val; .)
		"::"
	]
	Qualident<out qualident>
	[TypeArgumentList<out typeArguments, canBeUnbound>]
	(.
		if (alias == null) {
			typeRef = new TypeReference(qualident, typeArguments);
		} else if (alias == "global") {
			typeRef = new TypeReference(qualident, typeArguments);
			typeRef.IsGlobal = true;
		} else {
			typeRef = new TypeReference(alias + "." + qualident, typeArguments);
		}
	.)
	{ IF (DotAndIdent())
		"." (. typeArguments = null; .)
		Qualident<out qualident>
		[TypeArgumentList<out typeArguments, canBeUnbound>]
		(. typeRef = new InnerClassTypeReference(typeRef, qualident, typeArguments); .)
	}
.


NullableQuestionMark<ref TypeReference typeRef>
(. List<TypeReference> typeArguments = new List<TypeReference>(1); .)
=
	"?"
	(.
		if (typeRef != null) typeArguments.Add(typeRef);
		typeRef = new TypeReference("System.Nullable", typeArguments);
	.)
.

TypeArgumentList<out List<TypeReference> types, bool canBeUnbound>
(. 
	types = new List<TypeReference>();
	TypeReference type = null;
.)
=
	"<"
	( IF (canBeUnbound && (la.kind == Tokens.GreaterThan || la.kind == Tokens.Comma))
		(. types.Add(TypeReference.Null); .)
		{ "," (. types.Add(TypeReference.Null); .) }
	| Type<out type> (. if (type != null) { types.Add(type); } .)
	  { "," Type<out type> (. if (type != null) { types.Add(type); } .) }
	)
	">"
.

TypeParameterList<List<TemplateDefinition> templates>
(.
	AttributeSection section;
	List<AttributeSection> attributes = new List<AttributeSection>();
.)
=
	"<" { AttributeSection<out section> (. attributes.Add(section); .) }
	Identifier (. templates.Add(new TemplateDefinition(t.val, attributes)); .)
	{ "," { AttributeSection<out section> (. attributes.Add(section); .) }
	Identifier (. templates.Add(new TemplateDefinition(t.val, attributes)); .)}
	">"
.

TypeParameterConstraintsClause<List<TemplateDefinition> templates>
(. string name = ""; TypeReference type; .)
=
	"where"
	Identifier (. name = t.val; .)
	":"
	TypeParameterConstraintsClauseBase<out type> (. 
	                                                TemplateDefinition td = null;
	                                                foreach (TemplateDefinition d in templates) {
	                                                	if (d.Name == name) {
	                                                		td = d;
	                                                		break;
	                                                	}
	                                                }
	                                                if ( td != null && type != null) { td.Bases.Add(type); }
	                                             .)
	{ "," TypeParameterConstraintsClauseBase<out type> (.
	                                                    td = null;
	                                                    foreach (TemplateDefinition d in templates) {
	                                                    	if (d.Name == name) {
	                                                    		td = d;
	                                                    		break;
	                                                    	}
	                                                    }
	                                                    if ( td != null && type != null) { td.Bases.Add(type); }
	                                                   .) }
.

TypeParameterConstraintsClauseBase<out TypeReference type>
(. TypeReference t; type = null; .)
=
	"struct"          (. type = TypeReference.StructConstraint; .)
	| "class"         (. type = TypeReference.ClassConstraint; .)
	| "new" "(" ")"   (. type = TypeReference.NewConstraint; .)
	| Type<out t>     (. type = t; .)
.

QueryExpression<out Expression outExpr>
(.	QueryExpression q = new QueryExpression(); outExpr = q; q.StartLocation = la.Location; 
	QueryExpressionFromClause fromClause;
.)
=
	QueryExpressionFromClause<out fromClause>  (. q.FromClause = fromClause; .)
	QueryExpressionBody<q>
	(. q.EndLocation = t.EndLocation; .)
.

QueryExpressionFromClause<out QueryExpressionFromClause fc>
(.	fc = new QueryExpressionFromClause(); fc.StartLocation = la.Location; 
.)
=
	"from"
	QueryExpressionFromOrJoinClause<fc>
	(. fc.EndLocation = t.EndLocation; .)
.

QueryExpressionJoinClause<out QueryExpressionJoinClause jc>
(.	jc = new QueryExpressionJoinClause(); jc.StartLocation = la.Location; 
	Expression expr;
.)
=
	"join"
	QueryExpressionFromOrJoinClause<jc>
	"on"
	Expr<out expr> (. jc.OnExpression = expr; .)
	"equals"
	Expr<out expr> (. jc.EqualsExpression = expr; .)
	[ "into"
		Identifier (. jc.IntoIdentifier = t.val; .)
	]
	(. jc.EndLocation = t.EndLocation; .)
.

QueryExpressionFromOrJoinClause<QueryExpressionFromOrJoinClause fjc>
(. TypeReference type; Expression expr; .)
=
	(. fjc.Type = null; .)
	[ IF (IsLocalVarDecl()) Type<out type> (. fjc.Type = type; .) ]
	Identifier  (. fjc.Identifier = t.val; .)
	"in"
	Expr<out expr> (. fjc.InExpression = expr; .)
.

QueryExpressionBody<QueryExpression q>
(.	QueryExpressionFromClause fromClause;     QueryExpressionWhereClause whereClause;
	QueryExpressionLetClause letClause;       QueryExpressionJoinClause joinClause;
	QueryExpressionSelectClause selectClause; QueryExpressionGroupClause groupClause;
	QueryExpressionIntoClause intoClause;
.)
=
	{ (	QueryExpressionFromClause<out fromClause>   (. SafeAdd<QueryExpressionClause>(q, q.FromLetWhereClauses, fromClause); .)
	  |	QueryExpressionWhereClause<out whereClause> (. SafeAdd<QueryExpressionClause>(q, q.FromLetWhereClauses, whereClause); .)
	  |	QueryExpressionLetClause<out letClause>     (. SafeAdd<QueryExpressionClause>(q, q.FromLetWhereClauses, letClause); .)
	  |	QueryExpressionJoinClause<out joinClause>   (. SafeAdd<QueryExpressionClause>(q, q.FromLetWhereClauses, joinClause); .)
	  ) }
	[ QueryExpressionOrderByClause<q> ]
	(	QueryExpressionSelectClause<out selectClause> (. q.SelectOrGroupClause = selectClause; .)
	|	QueryExpressionGroupClause<out groupClause>  (. q.SelectOrGroupClause = groupClause; .)
	)
	[ QueryExpressionIntoClause<out intoClause> (. q.IntoClause = intoClause; .) ]
.

QueryExpressionWhereClause<out QueryExpressionWhereClause wc>
(. Expression expr; wc = new QueryExpressionWhereClause(); wc.StartLocation = la.Location; .)
=
	"where"
	Expr<out expr> (. wc.Condition = expr; .)
	(. wc.EndLocation = t.EndLocation; .)
.

QueryExpressionLetClause<out QueryExpressionLetClause wc>
(. Expression expr; wc = new QueryExpressionLetClause(); wc.StartLocation = la.Location; .)
=
	"let"
	Identifier (. wc.Identifier = t.val; .)
	"="
	Expr<out expr> (. wc.Expression = expr; .)
	(. wc.EndLocation = t.EndLocation; .)
.

QueryExpressionOrderByClause<QueryExpression q>
(. QueryExpressionOrdering ordering; .)
=
	"orderby"
	QueryExpressionOrderingClause<out ordering> (. SafeAdd(q, q.Orderings, ordering); .)
	{ ","
		QueryExpressionOrderingClause<out ordering> (. SafeAdd(q, q.Orderings, ordering); .)
	}
.

QueryExpressionOrderingClause<out QueryExpressionOrdering ordering>
(. Expression expr; ordering = new QueryExpressionOrdering(); ordering.StartLocation = la.Location; .)
=
	Expr<out expr> (. ordering.Criteria = expr; .)
	[	"ascending"  (. ordering.Direction = QueryExpressionOrderingDirection.Ascending; .)
	|	"descending" (. ordering.Direction = QueryExpressionOrderingDirection.Descending; .)
	]
	(. ordering.EndLocation = t.EndLocation; .)
.

QueryExpressionSelectClause<out QueryExpressionSelectClause sc>
(. Expression expr; sc = new QueryExpressionSelectClause(); sc.StartLocation = la.Location; .)
=
	"select"
	Expr<out expr> (. sc.Projection = expr; .)
	(. sc.EndLocation = t.EndLocation; .)
.

QueryExpressionGroupClause<out QueryExpressionGroupClause gc>
(. Expression expr; gc = new QueryExpressionGroupClause(); gc.StartLocation = la.Location; .)
=
	"group"
	Expr<out expr> (. gc.Projection = expr; .)
	"by"
	Expr<out expr> (. gc.GroupBy = expr; .)
	(. gc.EndLocation = t.EndLocation; .)
.

QueryExpressionIntoClause<out QueryExpressionIntoClause ic>
(.	ic = new QueryExpressionIntoClause(); ic.StartLocation = la.Location; .)
=
	"into"
	Identifier (. ic.IntoIdentifier = t.val; .)
	(. ic.ContinuedQuery = new QueryExpression(); .)
	(. ic.ContinuedQuery.StartLocation = la.Location; .)
	QueryExpressionBody<ic.ContinuedQuery>
	(. ic.ContinuedQuery.EndLocation = t.EndLocation; .)
	(. ic.EndLocation = t.EndLocation; .)
.

/* allow usage of context sensitive keywords as identifiers */
Identifier
=
/* when updating this list, ensure you also change KeywordList.IdentifierTokens*/
	ident
|	"partial"
|	"where"
|	"get"
|	"set"
|	"add"
|	"remove"
|	"yield"
|	"select"
|	"group"
|	"by"
|	"into"
|	"from"
|	"ascending"
|	"descending"
|	"orderby"
|	"let"
|	"join"
|	"on"
|	"equals"
.

	
END CS.
