using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Linq;
using System.Text;
using ICSharpCode.NRefactory.Ast;
using ICSharpCode.NRefactory.Parser.VB;
using ASTAttribute = ICSharpCode.NRefactory.Ast.Attribute;

COMPILER VBNET

/* START AUTOGENERATED TOKENS SECTION */
TOKENS
	/* ----- terminal classes ----- */
	/* EOF is 0 */
	EOL
	ident
	LiteralString
	LiteralCharacter
	LiteralInteger
	LiteralDouble
	LiteralSingle
	LiteralDecimal
	LiteralDate
	XmlOpenTag
	XmlCloseTag
	XmlStartInlineVB
	XmlEndInlineVB
	XmlCloseTagEmptyElement
	XmlOpenEndTag
	XmlContent
	XmlComment
	XmlCData
	XmlProcessingInstruction

	/* ----- special character ----- */
	"="
	":"
	","
	"&"
	"/"
	"\\"
	"."
	"..."
	".@"
	"!"
	"-"
	"+"
	"^"
	"?"
	"*"
	"{"
	"}"
	"("
	")"
	">"
	"<"
	"<>"
	">="
	"<="
	"<<"
	">>"
	"+="
	"^="
	"-="
	"*="
	"/="
	"\\="
	"<<="
	">>="
	"&="
	":="

	/* ----- keywords ----- */
	"AddHandler"
	"AddressOf"
	"Aggregate"
	"Alias"
	"And"
	"AndAlso"
	"Ansi"
	"As"
	"Ascending"
	"Assembly"
	"Auto"
	"Binary"
	"Boolean"
	"ByRef"
	"By"
	"Byte"
	"ByVal"
	"Call"
	"Case"
	"Catch"
	"CBool"
	"CByte"
	"CChar"
	"CDate"
	"CDbl"
	"CDec"
	"Char"
	"CInt"
	"Class"
	"CLng"
	"CObj"
	"Compare"
	"Const"
	"Continue"
	"CSByte"
	"CShort"
	"CSng"
	"CStr"
	"CType"
	"CUInt"
	"CULng"
	"CUShort"
	"Custom"
	"Date"
	"Decimal"
	"Declare"
	"Default"
	"Delegate"
	"Descending"
	"Dim"
	"DirectCast"
	"Distinct"
	"Do"
	"Double"
	"Each"
	"Else"
	"ElseIf"
	"End"
	"EndIf"
	"Enum"
	"Equals"
	"Erase"
	"Error"
	"Event"
	"Exit"
	"Explicit"
	"False"
	"Finally"
	"For"
	"Friend"
	"From"
	"Function"
	"Get"
	"GetType"
	"Global"
	"GoSub"
	"GoTo"
	"Group"
	"Handles"
	"If"
	"Implements"
	"Imports"
	"In"
	"Infer"
	"Inherits"
	"Integer"
	"Interface"
	"Into"
	"Is"
	"IsNot"
	"Join"
	"Key"
	"Let"
	"Lib"
	"Like"
	"Long"
	"Loop"
	"Me"
	"Mod"
	"Module"
	"MustInherit"
	"MustOverride"
	"MyBase"
	"MyClass"
	"Namespace"
	"Narrowing"
	"New"
	"Next"
	"Not"
	"Nothing"
	"NotInheritable"
	"NotOverridable"
	"Object"
	"Of"
	"Off"
	"On"
	"Operator"
	"Option"
	"Optional"
	"Or"
	"Order"
	"OrElse"
	"Out"
	"Overloads"
	"Overridable"
	"Overrides"
	"ParamArray"
	"Partial"
	"Preserve"
	"Private"
	"Property"
	"Protected"
	"Public"
	"RaiseEvent"
	"ReadOnly"
	"ReDim"
	"Rem"
	"RemoveHandler"
	"Resume"
	"Return"
	"SByte"
	"Select"
	"Set"
	"Shadows"
	"Shared"
	"Short"
	"Single"
	"Skip"
	"Static"
	"Step"
	"Stop"
	"Strict"
	"String"
	"Structure"
	"Sub"
	"SyncLock"
	"Take"
	"Text"
	"Then"
	"Throw"
	"To"
	"True"
	"Try"
	"TryCast"
	"TypeOf"
	"UInteger"
	"ULong"
	"Unicode"
	"Until"
	"UShort"
	"Using"
	"Variant"
	"Wend"
	"When"
	"Where"
	"While"
	"Widening"
	"With"
	"WithEvents"
	"WriteOnly"
	"Xor"
	"GetXmlNamespace"
/* END AUTOGENERATED TOKENS SECTION */

PRODUCTIONS

VBNET
	(.
		lexer.NextToken(); // get the first token
		compilationUnit = new CompilationUnit();
		BlockStart(compilationUnit);
	.)
=
	{ EndOfStmt }
	{ OptionStmt { EndOfStmt } }
	{ ImportsStmt { EndOfStmt } }
	{ IF (IsGlobalAttrTarget()) GlobalAttributeSection { EndOfStmt } }
	{ NamespaceMemberDecl { EndOfStmt } }
	EOF
.

OptionStmt (. INode node = null; bool val = true; .) =
	"Option" (. Location startPos = t.Location; .)
	(
		"Explicit" [ OptionValue<ref val> ]
		(. node = new OptionDeclaration(OptionType.Explicit, val); .)
		|
		"Strict" [ OptionValue<ref val> ]
		(. node = new OptionDeclaration(OptionType.Strict, val); .)
		|
		"Compare" ( "Binary" (. node = new OptionDeclaration(OptionType.CompareBinary, val); .)
				  | "Text" (. node = new OptionDeclaration(OptionType.CompareText, val); .)
				  )
		|
		"Infer" [ OptionValue<ref val> ]
		(. node = new OptionDeclaration(OptionType.Infer, val); .)
	)
	EndOfStmt
	(.
		if (node != null) {
			node.StartLocation = startPos;
			node.EndLocation   = t.Location;
			AddChild(node);
		}
	.)
	.

OptionValue<ref bool val> =
	(
		"On" (. val = true; .)
	|
		"Off" (. val = false; .)
	)
	.

EndOfStmt =
	SYNC ( EOL | ":" )
.

ImportsStmt
	(.List<Using> usings = new List<Using>();
	.) =
	"Imports"
	(.
		Location startPos = t.Location;
		Using u;
	.)
	ImportClause<out u> (. if (u != null) { usings.Add(u); } .)
	{
		"," ImportClause<out u> (. if (u != null) { usings.Add(u); } .)
	}
	EndOfStmt
	(.
		UsingDeclaration usingDeclaration = new UsingDeclaration(usings);
		usingDeclaration.StartLocation = startPos;
		usingDeclaration.EndLocation   = t.Location;
		AddChild(usingDeclaration);
	.)
	.

ImportClause<out Using u>
	(.
		string qualident  = null;
		TypeReference aliasedType = null;
		u = null;
	.) =
	(
		Qualident<out qualident>
		[ "=" TypeName<out aliasedType> ]
		(.
			if (qualident != null && qualident.Length > 0) {
				if (aliasedType != null) {
					u = new Using(qualident, aliasedType);
				} else {
					u = new Using(qualident);
				}
			}
		.)
	) | ( (. string prefix = null; .)
		XmlOpenTag Identifier (. prefix = t.val; .) "=" LiteralString (. u = new Using(t.literalValue as string, prefix); .) XmlCloseTag
	)
	.

/* 6.4.2 */
NamespaceMemberDecl
	(.
		ModifierList m = new ModifierList();
		AttributeSection section;
		List<AttributeSection> attributes = new List<AttributeSection>();
		string qualident;
	.) =
	("Namespace"
	(.
		Location startPos = t.Location;
	.)
	Qualident<out qualident>
	(.
		INode node =  new NamespaceDeclaration(qualident);
		node.StartLocation = startPos;
		AddChild(node);
		BlockStart(node);
	.)
	EndOfStmt
	NamespaceBody
	(.
		node.EndLocation = t.Location;
		BlockEnd();
	.)
	) | (
	{ AttributeSection<out section> (. attributes.Add(section); .) }
	{ TypeModifier<m> } NonModuleDeclaration<m, attributes> )
	.

/* 4.9.1 */
TypeParameterList<List<TemplateDefinition> templates>
(.
	TemplateDefinition template;
.)
=
	[
		IF (la.kind == Tokens.OpenParenthesis && Peek(1).kind == Tokens.Of)
		"(" "Of" TypeParameter<out template>
		(.
			if (template != null) templates.Add(template);
		.)
		{
			"," TypeParameter<out template>
			(.
				if (template != null) templates.Add(template);
			.)
		}
		")"
	]
.

/* 4.9.1 */
TypeParameter<out TemplateDefinition template>
	(. VarianceModifier modifier = VarianceModifier.Invariant; Location startLocation = la.Location; .)
=
	(
		[ "In" (. modifier = VarianceModifier.Contravariant; .) | "Out" (. modifier = VarianceModifier.Covariant; .) ] Identifier (. template = new TemplateDefinition(t.val, null) { VarianceModifier = modifier }; .)
		[TypeParameterConstraints<template>]
	)
	(.
		if (template != null) {
			template.StartLocation = startLocation;
			template.EndLocation = t.EndLocation;
		}
	.)
.

/* 4.9.2 */
TypeParameterConstraints<TemplateDefinition template>
(.
	TypeReference constraint;
.)
=
	"As"
	(
		"{"
		TypeParameterConstraint<out constraint> (. if (constraint != null) { template.Bases.Add(constraint); } .)
		{
			","
			TypeParameterConstraint<out constraint> (. if (constraint != null) { template.Bases.Add(constraint); } .)
		}
		"}"
		| TypeParameterConstraint<out constraint> (. if (constraint != null) { template.Bases.Add(constraint); } .)
	)
.

TypeParameterConstraint<out TypeReference constraint>
	(. constraint = null; Location startLocation = la.Location; .)
=
	"Class"		(. constraint = TypeReference.ClassConstraint; .)
	| "Structure"	(. constraint = TypeReference.StructConstraint; .)
	| "New"		(. constraint = TypeReference.NewConstraint; .)
	| TypeName<out constraint>
.

/* 6.4.2 */
NonModuleDeclaration<ModifierList m, List<AttributeSection> attributes>
			(.
				TypeReference typeRef = null;
				List<TypeReference> baseInterfaces = null;
			.) =
	(. m.Check(Modifiers.Classes); .)
	/* Spec, 7.5 */
	"Class"
					(. TypeDeclaration newType = new TypeDeclaration(m.Modifier, attributes);
						newType.StartLocation = t.Location;
						AddChild(newType);
						BlockStart(newType);
						
						newType.Type       = ClassType.Class;
					.)
	Identifier			 (. newType.Name = t.val; .) 
	TypeParameterList<newType.Templates>
	EndOfStmt
	(. newType.BodyStartLocation = t.Location; .)
	[ ClassBaseType<out typeRef> (. SafeAdd(newType, newType.BaseTypes, typeRef); .) ]
	{ TypeImplementsClause<out baseInterfaces> (. newType.BaseTypes.AddRange(baseInterfaces); .) }
	ClassBody<newType>
	"End" "Class" (. newType.EndLocation = t.EndLocation; .)
	EndOfStmt
	(.
		BlockEnd();
	.)
	| "Module"
		(.
			m.Check(Modifiers.VBModules);
			TypeDeclaration newType = new TypeDeclaration(m.Modifier, attributes);
			AddChild(newType);
			BlockStart(newType);
			newType.StartLocation = m.GetDeclarationLocation(t.Location);
			newType.Type = ClassType.Module;
		.)
	Identifier			 (. newType.Name = t.val; .)
	EndOfStmt
	(. newType.BodyStartLocation = t.Location; .)
	ModuleBody<newType>
	(.
		BlockEnd();
	.)
	| "Structure"
		(.
			m.Check(Modifiers.VBStructures);
			TypeDeclaration newType = new TypeDeclaration(m.Modifier, attributes);
			AddChild(newType);
			BlockStart(newType);
			newType.StartLocation = m.GetDeclarationLocation(t.Location);
			newType.Type = ClassType.Struct;
		.)
	Identifier			 (. newType.Name = t.val; .) 
	TypeParameterList<newType.Templates>
	EndOfStmt
	(. newType.BodyStartLocation = t.Location; .)
	{ TypeImplementsClause<out baseInterfaces> (. newType.BaseTypes.AddRange(baseInterfaces);.) }
	StructureBody<newType>
	(.
		BlockEnd();
	.)
	| /* 7.4 */
	"Enum"
		(.
			m.Check(Modifiers.VBEnums);
			TypeDeclaration newType = new TypeDeclaration(m.Modifier, attributes);
			newType.StartLocation = m.GetDeclarationLocation(t.Location);
			AddChild(newType);
			BlockStart(newType);
			
			newType.Type = ClassType.Enum;
		.)
	Identifier			 (. newType.Name = t.val; .) 
	[ "As" NonArrayTypeName<out typeRef, false> (. SafeAdd(newType, newType.BaseTypes, typeRef); .) ]
	EndOfStmt
	(. newType.BodyStartLocation = t.Location; .)
	EnumBody<newType>
	(.
		BlockEnd();
	.)
	| /* 7.8 */
	"Interface"
		(.
			m.Check(Modifiers.VBInterfacs);
			TypeDeclaration newType = new TypeDeclaration(m.Modifier, attributes);
			newType.StartLocation = m.GetDeclarationLocation(t.Location);
			AddChild(newType);
			BlockStart(newType);
			newType.Type = ClassType.Interface;
		.)
	Identifier			 (. newType.Name = t.val; .) 
	TypeParameterList<newType.Templates>
	EndOfStmt
	(. newType.BodyStartLocation = t.Location; .)
	{ InterfaceBase<out baseInterfaces> (. newType.BaseTypes.AddRange(baseInterfaces); .) }
	InterfaceBody<newType>
	(.
		BlockEnd();
	.)
	| /* 7.10 */
	"Delegate"
	(.
		m.Check(Modifiers.VBDelegates);
		DelegateDeclaration delegateDeclr = new DelegateDeclaration(m.Modifier, attributes);
		delegateDeclr.ReturnType = new TypeReference("System.Void", true);
		delegateDeclr.StartLocation = m.GetDeclarationLocation(t.Location);
		List<ParameterDeclarationExpression> p = new List<ParameterDeclarationExpression>();
	.)
	(
		"Sub" Identifier (. delegateDeclr.Name = t.val; .)
		TypeParameterList<delegateDeclr.Templates>
		[ "(" [ FormalParameterList<p> ] ")" (. delegateDeclr.Parameters = p; .) ]
		|
		"Function" Identifier (. delegateDeclr.Name = t.val; .)
		TypeParameterList<delegateDeclr.Templates>
		[ "(" [ FormalParameterList<p> ] ")" (. delegateDeclr.Parameters = p; .) ]
		[ "As" (. TypeReference type; .) TypeName<out type> (. delegateDeclr.ReturnType = type; .)]
	)
	(. 		delegateDeclr.EndLocation = t.EndLocation; .)
	EndOfStmt
	(.
		AddChild(delegateDeclr);
	.)
	.

NamespaceBody =
	{ EndOfStmt } /* allow empty lines at begin of body */
	{
		NamespaceMemberDecl
		{ EndOfStmt } /* allow empty lines in body */
	}
	"End" "Namespace"
	EndOfStmt
	.

ClassBody<TypeDeclaration newType>
	(. AttributeSection section; .) =
	{ EndOfStmt } /* allow empty lines at begin of body */
	{
		(.List<AttributeSection> attributes = new List<AttributeSection>();
			ModifierList m = new ModifierList();
		.)
		{ AttributeSection<out section> (. attributes.Add(section); .) }
		{ MemberModifier<m> }
		ClassMemberDecl<m, attributes>
		{ EndOfStmt } /* allow empty lines in body */
	}
	.

StructureBody<TypeDeclaration newType>
	(. AttributeSection section; .) =
	{ EndOfStmt } /* allow empty lines at begin of body */
	{
		(.List<AttributeSection> attributes = new List<AttributeSection>();
			ModifierList m = new ModifierList();
		.)
		{ AttributeSection<out section> (. attributes.Add(section); .) }
		{ MemberModifier<m> }
		StructureMemberDecl<m, attributes>
		{ EndOfStmt } /* allow empty lines in body */
	}
	"End" "Structure" (. newType.EndLocation = t.EndLocation; .)
	EndOfStmt
	.

/* 7.7.1 */
ModuleBody<TypeDeclaration newType>
	(. AttributeSection section; .) =
	{ EndOfStmt } /* allow empty lines at begin of body */
	{
		(.List<AttributeSection> attributes = new List<AttributeSection>();
			ModifierList m = new ModifierList();
		.)
		{ AttributeSection<out section> (. attributes.Add(section); .) }
		{ MemberModifier<m> }
		ClassMemberDecl<m, attributes>
		{ EndOfStmt } /* allow empty lines in body */
	}
	"End" "Module" (. newType.EndLocation = t.EndLocation; .)
	EndOfStmt
	.

EnumBody<TypeDeclaration newType>
	(. FieldDeclaration f; .) =
	{ EndOfStmt } /* allow empty lines at begin of body */
	{
		EnumMemberDecl<out f>
		(.
			AddChild(f);
		.)
		{ EndOfStmt } /* allow empty lines in body */
	}
	"End" "Enum" (. newType.EndLocation = t.EndLocation; .)
	EndOfStmt
	.

InterfaceBody<TypeDeclaration newType> =
	{ EndOfStmt } /* allow empty lines at begin of body */
	{
		InterfaceMemberDecl
		{ EndOfStmt } /* allow empty lines in body */
	}
	"End" "Interface" (. newType.EndLocation = t.EndLocation; .)
	EndOfStmt
	.

/* The information provided in the spec about */
/* interface declarations is wrong */
InterfaceMemberDecl
	(.
		TypeReference type =null;
		List<ParameterDeclarationExpression> p = new List<ParameterDeclarationExpression>();
		List<TemplateDefinition> templates = new List<TemplateDefinition>();
		AttributeSection section, returnTypeAttributeSection = null;
		ModifierList mod = new ModifierList();
		List<AttributeSection> attributes = new List<AttributeSection>();
		string name;
	.) =
	{ AttributeSection<out section>			(. attributes.Add(section); .) }
	/* this is different to c#: not only the Shadows modifier is allowed, */
	/*  also member modifiers like overloads etc. */
	{ MemberModifier<mod> }
	(
		"Event"
		(.
			mod.Check(Modifiers.VBInterfaceEvents);
			Location startLocation = t.Location;
		.)
		Identifier (. name = t.val; .)
		[ "(" [ FormalParameterList<p> ] ")" ]
		[ "As" TypeName<out type> ]
		EndOfStmt
		(.
			EventDeclaration ed = new EventDeclaration {
				Name = name, TypeReference = type, Modifier = mod.Modifier,
				Parameters = p, Attributes = attributes,
				StartLocation = startLocation, EndLocation = t.EndLocation
			};
			AddChild(ed);
		.)
		|
		"Sub"
		(.
			Location startLocation =  t.Location;
			mod.Check(Modifiers.VBInterfaceMethods);
		.)
		Identifier (. name = t.val; .)
		TypeParameterList<templates>
		[ "(" [ FormalParameterList<p> ] ")" ]
		EndOfStmt
		(.
			MethodDeclaration md = new MethodDeclaration {
				Name = name, 
				Modifier = mod.Modifier, 
				Parameters = p,
				Attributes = attributes,
				TypeReference = new TypeReference("System.Void", true),
				StartLocation = startLocation,
				EndLocation = t.EndLocation,
				Templates = templates
			};
			AddChild(md);
		.)
		|
		"Function"
		(.
			mod.Check(Modifiers.VBInterfaceMethods);
			Location startLocation = t.Location;
		.)
		Identifier (. name = t.val; .)
		TypeParameterList<templates>
		[ "(" [ FormalParameterList<p> ] ")" ]
		[ "As" { AttributeSection<out returnTypeAttributeSection> } TypeName<out type> ]
		(.
			if(type == null) {
				type = new TypeReference("System.Object", true);
			}
			MethodDeclaration md = new MethodDeclaration {
				Name = name, Modifier = mod.Modifier, 
				TypeReference = type, Parameters = p, Attributes = attributes
			};
			if (returnTypeAttributeSection != null) {
				returnTypeAttributeSection.AttributeTarget = "return";
				md.Attributes.Add(returnTypeAttributeSection);
			}
			md.StartLocation = startLocation;
			md.EndLocation = t.EndLocation;
			md.Templates = templates;
			AddChild(md);
		.)
		EndOfStmt
		|
		"Property"
		(.
			Location startLocation = t.Location;
			mod.Check(Modifiers.VBInterfaceProperties);
		.)
		Identifier	(. name = t.val;  .)
		[ "(" [ FormalParameterList<p> ] ")" ]
		[ "As" TypeName<out type> ]
		(.
			if(type == null) {
				type = new TypeReference("System.Object", true);
			}
		.)
		EndOfStmt
		(.
			PropertyDeclaration pd = new PropertyDeclaration(name, type, mod.Modifier, attributes);
			pd.Parameters = p;
			pd.EndLocation = t.EndLocation;
			pd.StartLocation = startLocation;
			AddChild(pd);
		.)
	)
	| /* inner type declarations */
	NonModuleDeclaration<mod, attributes>
	.

/* 7.4.1 */
EnumMemberDecl<out FieldDeclaration f>
	(.
		Expression expr = null;List<AttributeSection> attributes = new List<AttributeSection>();
		AttributeSection section = null;
		VariableDeclaration varDecl = null;
	.) =
	{ AttributeSection<out section> (. attributes.Add(section); .) }
	Identifier
	(.
		f = new FieldDeclaration(attributes);
		varDecl = new VariableDeclaration(t.val);
		f.Fields.Add(varDecl);
		f.StartLocation = varDecl.StartLocation = t.Location;
	.)
	[ "=" Expr<out expr> (. varDecl.Initializer = expr; .) ]
	(. f.EndLocation = varDecl.EndLocation = t.EndLocation; .)
	EndOfStmt
.

ClassMemberDecl<ModifierList m, List<AttributeSection> attributes> =
	StructureMemberDecl<m, attributes>
	.

ClassBaseType<out TypeReference typeRef>
(.
	typeRef = null;
.) =
	"Inherits"
	TypeName<out typeRef>
	EndOfStmt
.

/* 7.6.1 */
StructureMemberDecl<ModifierList m, List<AttributeSection> attributes>
	(.
		TypeReference type = null;
		List<ParameterDeclarationExpression> p = new List<ParameterDeclarationExpression>();
		Statement stmt = null;
		List<VariableDeclaration> variableDeclarators = new List<VariableDeclaration>();
		List<TemplateDefinition> templates = new List<TemplateDefinition>();
	.)
=
	NonModuleDeclaration<m, attributes>
| /* 9.2.1 */
	"Sub"
	(.
		Location startPos = t.Location;
	.)
	(
		(.
			string name = String.Empty;
			MethodDeclaration methodDeclaration; List<string> handlesClause = null;
			List<InterfaceImplementation> implementsClause = null;
		.)
		Identifier
		(.
			name = t.val;
			m.Check(Modifiers.VBMethods);
		.)
		TypeParameterList<templates>
		[ "(" [ FormalParameterList<p> ] ")" ]
		[
			(
				ImplementsClause<out implementsClause>
				|
				HandlesClause<out handlesClause>
			)
		]
		(. Location endLocation = t.EndLocation; .)
		(
			/* abstract methods without a body */
			IF(IsMustOverride(m))
			EndOfStmt
			(.
				methodDeclaration = new MethodDeclaration {
					Name = name, Modifier = m.Modifier, Parameters = p, Attributes = attributes,
					StartLocation = m.GetDeclarationLocation(startPos), EndLocation = endLocation,
					TypeReference = new TypeReference("System.Void", true),
					Templates = templates,
					HandlesClause = handlesClause,
					InterfaceImplementations = implementsClause
				};
				AddChild(methodDeclaration);
			.)
		|
			EOL
			(.
				methodDeclaration = new MethodDeclaration {
					Name = name, Modifier = m.Modifier, Parameters = p, Attributes = attributes,
					StartLocation = m.GetDeclarationLocation(startPos), EndLocation = endLocation,
					TypeReference = new TypeReference("System.Void", true),
					Templates = templates,
					HandlesClause = handlesClause,
					InterfaceImplementations = implementsClause
				};
				AddChild(methodDeclaration);
			.)
			
			(. if (ParseMethodBodies) { .)
				Block<out stmt>
				"End" "Sub"
			(. } else {
				// don't parse method body
				lexer.SkipCurrentBlock(Tokens.Sub); stmt = new BlockStatement();
			   }
			.)
			
			(. methodDeclaration.Body  = (BlockStatement)stmt; .)
			(. methodDeclaration.Body.EndLocation = t.EndLocation; .)
			EndOfStmt
		)
		/* 9.3 */
		| "New" [ "(" [ FormalParameterList<p> ] ")" ]
		(. m.Check(Modifiers.Constructors); .)
		(. Location constructorEndLocation = t.EndLocation; .)
		EOL
		
		(. if (ParseMethodBodies) { .)
			Block<out stmt>
			"End" "Sub"
		(. } else {
			// don't parse method body
			lexer.SkipCurrentBlock(Tokens.Sub); stmt = new BlockStatement();
		   }
		.)
		
		(. Location endLocation = t.EndLocation; .)
		EndOfStmt
		(.
			ConstructorDeclaration cd = new ConstructorDeclaration("New", m.Modifier, p, attributes);
			cd.StartLocation = m.GetDeclarationLocation(startPos);
			cd.EndLocation   = constructorEndLocation;
			cd.Body = (BlockStatement)stmt;
			cd.Body.EndLocation   = endLocation;
			AddChild(cd);
		.)
	)
|
	/* 9.2.1 */
	"Function"
	(.
		m.Check(Modifiers.VBMethods);
		string name = String.Empty;
		Location startPos = t.Location;
		MethodDeclaration methodDeclaration;List<string> handlesClause = null;
		List<InterfaceImplementation> implementsClause = null;
		AttributeSection returnTypeAttributeSection = null;
	.)
	Identifier			(. name = t.val; .)
	TypeParameterList<templates>
	[ "("	[ FormalParameterList<p> ] ")" ]
	["As"  {
				AttributeSection<out returnTypeAttributeSection>
				(.
					if (returnTypeAttributeSection != null) {
						returnTypeAttributeSection.AttributeTarget = "return";
						attributes.Add(returnTypeAttributeSection);
					}
				.)
			}
	TypeName<out type> ]
	(.
		if(type == null) {
			type = new TypeReference("System.Object", true);
		}
	.)
	[
		(
			ImplementsClause<out implementsClause>
			|
			HandlesClause<out handlesClause>
		)
	]
	(. Location endLocation = t.EndLocation; .)
	(
		/* abstract methods without a body */
		IF(IsMustOverride(m))
		EndOfStmt
			(.
				methodDeclaration = new MethodDeclaration {
					Name = name, Modifier = m.Modifier, TypeReference = type,
					Parameters = p, Attributes = attributes,
					StartLocation = m.GetDeclarationLocation(startPos),
					EndLocation   = endLocation,
					HandlesClause = handlesClause,
					Templates     = templates,
					InterfaceImplementations = implementsClause
				};
				
				AddChild(methodDeclaration);
			.)
		|
			EOL
			(.
				methodDeclaration = new MethodDeclaration {
					Name = name, Modifier = m.Modifier, TypeReference = type,
					Parameters = p, Attributes = attributes,
					StartLocation = m.GetDeclarationLocation(startPos),
					EndLocation   = endLocation,
					Templates     = templates,
					HandlesClause = handlesClause,
					InterfaceImplementations = implementsClause
				};
				
				AddChild(methodDeclaration);
			
				if (ParseMethodBodies) { .)
					Block<out stmt>
					"End" "Function"
			(.	} else {
					// don't parse method body
					lexer.SkipCurrentBlock(Tokens.Function); stmt = new BlockStatement();
				}
				methodDeclaration.Body = (BlockStatement)stmt;
				methodDeclaration.Body.StartLocation = methodDeclaration.EndLocation;
				methodDeclaration.Body.EndLocation   = t.EndLocation;
			.)
			EndOfStmt
	)
|
	/* 9.2.2. */
	"Declare"
	(.
		m.Check(Modifiers.VBExternalMethods);
		Location startPos = t.Location;
		CharsetModifier charsetModifer = CharsetModifier.None;
		string library = String.Empty;
		string alias = null;
		string name = String.Empty;
	.)
	[Charset<out charsetModifer> ]
	(
			"Sub"
			Identifier				(. name = t.val; .)
			"Lib" LiteralString		(. library = t.literalValue as string; .)
			["Alias" LiteralString	(. alias = t.literalValue as string; .)]
			[ "("	[ FormalParameterList<p> ] ")" ]
			EndOfStmt
			(.
				DeclareDeclaration declareDeclaration = new DeclareDeclaration(name, m.Modifier, null, p, attributes, library, alias, charsetModifer);
				declareDeclaration.StartLocation = m.GetDeclarationLocation(startPos);
				declareDeclaration.EndLocation   = t.EndLocation;
				AddChild(declareDeclaration);
			.)
		|
			"Function" 
			Identifier					(. name = t.val; .)
			"Lib" LiteralString		(. library = t.literalValue as string; .)
			["Alias" LiteralString	(. alias = t.literalValue as string; .)]
			[ "("	[ FormalParameterList<p> ] ")" ]
			["As" TypeName<out type> ]
			EndOfStmt
			(.
				DeclareDeclaration declareDeclaration = new DeclareDeclaration(name, m.Modifier, type, p, attributes, library, alias, charsetModifer);
				declareDeclaration.StartLocation = m.GetDeclarationLocation(startPos);
				declareDeclaration.EndLocation   = t.EndLocation;
				AddChild(declareDeclaration);
			.)
		)
|
	/* 9. 4 */
	"Event"
	(.
		m.Check(Modifiers.VBEvents);
		Location startPos = t.Location;
		EventDeclaration eventDeclaration;
		string name = String.Empty;
		List<InterfaceImplementation> implementsClause = null;
	.)
	Identifier (. name= t.val; .)
	(
		"As" TypeName<out type>
		|
		[ "("	[ FormalParameterList<p> ] ")" ]
	)
	[ ImplementsClause<out implementsClause> ]
	(.
		eventDeclaration = new EventDeclaration {
			Name = name, TypeReference = type, Modifier = m.Modifier, 
			Parameters = p, Attributes = attributes, InterfaceImplementations = implementsClause,
			StartLocation = m.GetDeclarationLocation(startPos),
			EndLocation = t.EndLocation
		};
		AddChild(eventDeclaration);
	.)
	EndOfStmt
| /* 9.6 */
	(.
		m.Check(Modifiers.Fields);
		FieldDeclaration fd = new FieldDeclaration(attributes, null, m.Modifier);
	.)
	IdentifierForFieldDeclaration (. string name = t.val; .)
	(. fd.StartLocation = m.GetDeclarationLocation(t.Location); .)
	
	VariableDeclaratorPartAfterIdentifier<variableDeclarators, name>
	{ "," VariableDeclarator<variableDeclarators> }
	EndOfStmt
	(.
		fd.EndLocation = t.EndLocation;
		fd.Fields = variableDeclarators;
		AddChild(fd);
	.)
	| /* 9.4 */
	(. m.Check(Modifiers.Fields); .)
	"Const" (.  m.Add(Modifiers.Const, t.Location);  .)
	(.
		FieldDeclaration fd = new FieldDeclaration(attributes, type, m.Modifier);
		fd.StartLocation = m.GetDeclarationLocation(t.Location);
		List<VariableDeclaration> constantDeclarators = new List<VariableDeclaration>();
	.)
	ConstantDeclarator<constantDeclarators>
	{ "," ConstantDeclarator<constantDeclarators> }
	(.
		fd.Fields = constantDeclarators;
		fd.EndLocation = t.Location;
	.)
	EndOfStmt
	(.
		fd.EndLocation = t.EndLocation;
		AddChild(fd);
	.)
| /* 9.7 */
	"Property"
	(.
		m.Check(Modifiers.VBProperties);
		Location startPos = t.Location;
		List<InterfaceImplementation> implementsClause = null;
		AttributeSection returnTypeAttributeSection = null;
		Expression initializer = null;
	.)
	Identifier (. string propertyName = t.val; .)
	[ "("	[ FormalParameterList<p> ] ")" ]
	[
		"As" {
				AttributeSection<out returnTypeAttributeSection>
				(.
					if (returnTypeAttributeSection != null) {
						returnTypeAttributeSection.AttributeTarget = "return";
						attributes.Add(returnTypeAttributeSection);
					}
				.)
		}
		(
			IF (IsNewExpression()) ObjectCreateExpression<out initializer>
			(.
				if (initializer is ObjectCreateExpression) {
					type = ((ObjectCreateExpression)initializer).CreateType.Clone();
				} else {
					type = ((ArrayCreateExpression)initializer).CreateType.Clone();
				}
			.)
		|
			TypeName<out type>
		)
	]
	[ "=" Expr<out initializer> ]
	[ ImplementsClause<out implementsClause> ]
	EndOfStmt
	(
	/* abstract properties without a body */
	IF(IsMustOverride(m) || IsAutomaticProperty())
		(.
			PropertyDeclaration pDecl = new PropertyDeclaration(propertyName, type, m.Modifier, attributes);
			pDecl.StartLocation = m.GetDeclarationLocation(startPos);
			pDecl.EndLocation   = t.Location;
			pDecl.TypeReference = type;
			pDecl.InterfaceImplementations = implementsClause;
			pDecl.Parameters = p;
			if (initializer != null)
				pDecl.Initializer = initializer;
			AddChild(pDecl);
		.)
	|
		(.
			PropertyDeclaration pDecl = new PropertyDeclaration(propertyName, type, m.Modifier, attributes);
			pDecl.StartLocation = m.GetDeclarationLocation(startPos);
			pDecl.EndLocation   = t.Location;
			pDecl.BodyStart   = t.Location;
			pDecl.TypeReference = type;
			pDecl.InterfaceImplementations = implementsClause;
			pDecl.Parameters = p;
			PropertyGetRegion getRegion;
			PropertySetRegion setRegion;
		.)
		AccessorDecls<out getRegion, out setRegion> 
		"End" "Property"
		EndOfStmt
		(.
			pDecl.GetRegion = getRegion;
			pDecl.SetRegion = setRegion;
			pDecl.BodyEnd = t.Location; // t = EndOfStmt; not "Property"
			AddChild(pDecl);
		.)
	)
|
	"Custom" (. Location startPos = t.Location; .) "Event"
	(.
		m.Check(Modifiers.VBCustomEvents);
		EventAddRemoveRegion eventAccessorDeclaration;
		EventAddRegion addHandlerAccessorDeclaration = null;
		EventRemoveRegion removeHandlerAccessorDeclaration = null;
		EventRaiseRegion raiseEventAccessorDeclaration = null;
		List<InterfaceImplementation> implementsClause = null;
	.)
	Identifier (. string customEventName = t.val; .)
	"As" TypeName<out type>
	[ ImplementsClause<out implementsClause> ]
	EndOfStmt
	{
		EventAccessorDeclaration<out eventAccessorDeclaration>
		(.
			if(eventAccessorDeclaration is EventAddRegion)
			{
				addHandlerAccessorDeclaration = (EventAddRegion)eventAccessorDeclaration;
			}
			else if(eventAccessorDeclaration is EventRemoveRegion)
			{
				removeHandlerAccessorDeclaration = (EventRemoveRegion)eventAccessorDeclaration;
			}
			else if(eventAccessorDeclaration is EventRaiseRegion)
			{
				raiseEventAccessorDeclaration = (EventRaiseRegion)eventAccessorDeclaration;
			}
		.)
	}
	"End" "Event" EndOfStmt
	(.
		if(addHandlerAccessorDeclaration == null)
		{
			Error("Need to provide AddHandler accessor.");
		}
		
		if(removeHandlerAccessorDeclaration == null)
		{
			Error("Need to provide RemoveHandler accessor.");
		}
		
		if(raiseEventAccessorDeclaration == null)
		{
			Error("Need to provide RaiseEvent accessor.");
		}
	
		EventDeclaration decl = new EventDeclaration {
			TypeReference = type, Name = customEventName, Modifier = m.Modifier,
			Attributes = attributes,
			StartLocation = m.GetDeclarationLocation(startPos),
			EndLocation = t.EndLocation,
			AddRegion = addHandlerAccessorDeclaration,
			RemoveRegion = removeHandlerAccessorDeclaration,
			RaiseRegion = raiseEventAccessorDeclaration
		};
		AddChild(decl);
	.)
|   (. ConversionType opConversionType = ConversionType.None; .)
	[ "Widening"		(. opConversionType = ConversionType.Implicit; .)
	| "Narrowing"		(. opConversionType = ConversionType.Explicit;.) ]
	"Operator"
	(.
		m.Check(Modifiers.VBOperators);
		Location startPos = t.Location;
		TypeReference returnType = NullTypeReference.Instance;
		TypeReference operandType = NullTypeReference.Instance;
		OverloadableOperatorType operatorType;
		AttributeSection section;
		ParameterDeclarationExpression param;
		List<ParameterDeclarationExpression> parameters = new List<ParameterDeclarationExpression>();
	.)
	OverloadableOperator<out operatorType>
	"("
	FormalParameter<out param>
	(. if (param != null) parameters.Add(param); .)
	[
		"," FormalParameter<out param>
		(. if (param != null) parameters.Add(param); .)
	]
	")"
	(. Location endPos = t.EndLocation; .)
	[ "As" { AttributeSection<out section>
			(. if (section != null) {
					section.AttributeTarget = "return";
					attributes.Add(section);
		  } .)
			} TypeName<out returnType> (. endPos = t.EndLocation; .) ]
	EOL
	Block<out stmt> "End" "Operator" EndOfStmt
	(.
		OperatorDeclaration operatorDeclaration = new OperatorDeclaration {
			Modifier = m.Modifier,
			Attributes = attributes,
			Parameters = parameters,
			TypeReference = returnType,
			OverloadableOperator = operatorType,
			ConversionType = opConversionType,
			Body = (BlockStatement)stmt,
			StartLocation = m.GetDeclarationLocation(startPos),
			EndLocation = endPos
		};
		operatorDeclaration.Body.StartLocation = startPos;
		operatorDeclaration.Body.EndLocation = t.Location;
		AddChild(operatorDeclaration);
	.)
.

OverloadableOperator<out OverloadableOperatorType operatorType>
	(. operatorType = OverloadableOperatorType.None; .)
	=
	"+"			(. operatorType = OverloadableOperatorType.Add; .)
	|
	"-"			(. operatorType = OverloadableOperatorType.Subtract; .)
	|
	"*"			(. operatorType = OverloadableOperatorType.Multiply; .)
	| 
	"/"			(. operatorType = OverloadableOperatorType.Divide; .)
	| 
	"\\"		(. operatorType = OverloadableOperatorType.DivideInteger; .)
	| 
	"&"			(. operatorType = OverloadableOperatorType.Concat; .)
	| 
	"Like"		(. operatorType = OverloadableOperatorType.Like; .)
	| 
	"Mod"		(. operatorType = OverloadableOperatorType.Modulus; .)
	| 
	"And"		(. operatorType = OverloadableOperatorType.BitwiseAnd; .)
	|
	"Or"		(. operatorType = OverloadableOperatorType.BitwiseOr; .)
	|
	"Xor"		(. operatorType = OverloadableOperatorType.ExclusiveOr; .)
	|
	"^"			(. operatorType = OverloadableOperatorType.Power; .)
	|
	"<<"		(. operatorType = OverloadableOperatorType.ShiftLeft; .)
	|
	">>"		(. operatorType = OverloadableOperatorType.ShiftRight; .)
	|
	"="			(. operatorType = OverloadableOperatorType.Equality; .)
	|
	"<>"		(. operatorType = OverloadableOperatorType.InEquality; .)
	|
	"<"			(. operatorType = OverloadableOperatorType.LessThan; .)
	|
	"<="		(. operatorType = OverloadableOperatorType.LessThanOrEqual; .)
	|
	">"			(. operatorType = OverloadableOperatorType.GreaterThan; .)
	|
	">="		(. operatorType = OverloadableOperatorType.GreaterThanOrEqual; .)
	|
	"CType"		(. operatorType = OverloadableOperatorType.CType; .)
	|
	Identifier
	(.
		string opName = t.val; 
		if (string.Equals(opName, "istrue", StringComparison.InvariantCultureIgnoreCase)) {
			operatorType = OverloadableOperatorType.IsTrue;
		} else if (string.Equals(opName, "isfalse", StringComparison.InvariantCultureIgnoreCase)) {
			operatorType = OverloadableOperatorType.IsFalse;
		} else {
			Error("Invalid operator. Possible operators are '+', '-', 'Not', 'IsTrue', 'IsFalse'.");
		}
	.)
	.

EventAccessorDeclaration<out EventAddRemoveRegion eventAccessorDeclaration>
	(.
		Statement stmt = null;
		List<ParameterDeclarationExpression> p = new List<ParameterDeclarationExpression>();
		AttributeSection section;
		List<AttributeSection> attributes = new List<AttributeSection>();
		eventAccessorDeclaration = null;
	.) =
	{ AttributeSection<out section> (. attributes.Add(section); .) }
	(
			"AddHandler" [ "(" [ FormalParameterList<p> ] ")" ] EOL
			Block<out stmt> "End" "AddHandler" EndOfStmt
			(.
				eventAccessorDeclaration = new EventAddRegion(attributes);
				eventAccessorDeclaration.Block = (BlockStatement)stmt;
				eventAccessorDeclaration.Parameters = p;
			.)
		|
			"RemoveHandler" [ "(" [ FormalParameterList<p> ] ")" ] EOL
			Block<out stmt> "End" "RemoveHandler" EndOfStmt
			(.
				eventAccessorDeclaration = new EventRemoveRegion(attributes);
				eventAccessorDeclaration.Block = (BlockStatement)stmt;
				eventAccessorDeclaration.Parameters = p;
			.)
		|
			"RaiseEvent" [ "(" [ FormalParameterList<p> ] ")" ] EOL
			Block<out stmt> "End" "RaiseEvent" EndOfStmt
			(.
				eventAccessorDeclaration = new EventRaiseRegion(attributes);
				eventAccessorDeclaration.Block = (BlockStatement)stmt;
				eventAccessorDeclaration.Parameters = p;
			.)
	)
	.

/* 9.7 */
AccessorDecls<out PropertyGetRegion getBlock, out PropertySetRegion setBlock>
	(.
		List<AttributeSection> attributes = new List<AttributeSection>();
		AttributeSection section;
		getBlock = null;
		setBlock = null; 
	.) =
	{ AttributeSection<out section> (. attributes.Add(section); .) }
	(
		GetAccessorDecl<out getBlock, attributes>
		[
			(. attributes = new List<AttributeSection>(); .)
			{ AttributeSection<out section> (. attributes.Add(section); .) }
			SetAccessorDecl<out setBlock, attributes>
		]
		|
		SetAccessorDecl<out setBlock, attributes>
		[
			(. attributes = new List<AttributeSection>(); .)
			{ AttributeSection<out section> (. attributes.Add(section); .) }
			GetAccessorDecl<out getBlock, attributes>
		]
	)
	.

/* 9.7.1 */
GetAccessorDecl<out PropertyGetRegion getBlock, List<AttributeSection> attributes>
	(. Statement stmt = null; Modifiers m; .)
=
	PropertyAccessorAccessModifier<out m>
	"Get"
	(. Location startLocation = t.Location; .)
	EOL
	Block<out stmt>
	(. getBlock = new PropertyGetRegion((BlockStatement)stmt, attributes); .)
	"End" "Get"
	(. getBlock.Modifier = m; .)
	(. getBlock.StartLocation = startLocation; getBlock.EndLocation = t.EndLocation; .)
	EndOfStmt
	.

/* 9.7.2 */
SetAccessorDecl<out PropertySetRegion setBlock, List<AttributeSection> attributes>
	(.
		Statement stmt = null;
		List<ParameterDeclarationExpression> p = new List<ParameterDeclarationExpression>();
		Modifiers m;
	.)
=
	PropertyAccessorAccessModifier<out m>
	"Set"
	(. Location startLocation = t.Location; .)
	[ "("	[ FormalParameterList<p> ] ")" ]
	EOL
	Block<out stmt>
	(.
		setBlock = new PropertySetRegion((BlockStatement)stmt, attributes);
		setBlock.Modifier = m;
		setBlock.Parameters = p;
	.)
	"End" "Set"
	(. setBlock.StartLocation = startLocation; setBlock.EndLocation = t.EndLocation; .)
	EndOfStmt
	.

/* 9.5 */
ConstantDeclarator<List<VariableDeclaration> constantDeclaration>
	(.
		Expression expr = null;
		TypeReference type = null;
		string name = String.Empty;
		Location location;
	.) =
	Identifier				(. name = t.val; location = t.Location; .)
	["As" TypeName<out type> ]
	"=" Expr<out expr>
	(.
		VariableDeclaration f = new VariableDeclaration(name, expr);
		f.TypeReference = type;
		f.StartLocation = location;
		constantDeclaration.Add(f);
	.)
.

/* 9.6 */
VariableDeclarator<List<VariableDeclaration> fieldDeclaration>
=
	Identifier (. string name = t.val; .)
	VariableDeclaratorPartAfterIdentifier<fieldDeclaration, name>
.

VariableDeclaratorPartAfterIdentifier<List<VariableDeclaration> fieldDeclaration, string name>
	(.
		Expression expr = null;
		TypeReference type = null;
		ArrayList rank = null;
		List<Expression> dimension = null;
		Location startLocation = t.Location;
	.) =
	[ IF(IsSize() && !IsDims()) ArrayInitializationModifier<out dimension> ]
	[ IF(IsDims())              ArrayNameModifier<out rank> ]
	(
		IF (IsObjectCreation()) "As" ObjectCreateExpression<out expr>
		(.
			if (expr is ObjectCreateExpression) {
				type = ((ObjectCreateExpression)expr).CreateType.Clone();
			} else {
				type = ((ArrayCreateExpression)expr).CreateType.Clone();
			}
		.)
	|
		[ "As" TypeName<out type>
		  (.
			if (type != null) {
				for (int i = fieldDeclaration.Count - 1; i >= 0; i--) {
					VariableDeclaration vd = fieldDeclaration[i];
					if (vd.TypeReference.Type.Length > 0) break;
					TypeReference newType = type.Clone();
					newType.RankSpecifier = vd.TypeReference.RankSpecifier;
					vd.TypeReference = newType;
				}
			}
		  .)
		]
		(.
			if (type == null && (dimension != null || rank != null)) {
				type = new TypeReference("");
			}
			if (dimension != null) {
				if(type.RankSpecifier != null) {
					Error("array rank only allowed one time");
				} else {
					if (rank == null) {
						type.RankSpecifier = new int[] { dimension.Count - 1 };
					} else {
						rank.Insert(0, dimension.Count - 1);
						type.RankSpecifier = (int[])rank.ToArray(typeof(int));
					}
					expr = new ArrayCreateExpression(type.Clone(), dimension);
				}
			} else if (rank != null) {
				if(type.RankSpecifier != null) {
					Error("array rank only allowed one time");
				} else {
					type.RankSpecifier = (int[])rank.ToArray(typeof(int));
				}
			}
		.)
		[ "=" Expr<out expr> ]
	)
	(.
		VariableDeclaration varDecl = new VariableDeclaration(name, expr, type);
		varDecl.StartLocation = startLocation;
		varDecl.EndLocation = t.Location;
		fieldDeclaration.Add(varDecl);
	.)
.

/* 6.8 */
ArrayInitializationModifier<out List<Expression> arrayModifiers>
(.
	arrayModifiers = null;
.) =
	"(" InitializationRankList<out arrayModifiers> ")"
.

/* 7.5.4.3 */
InitializationRankList<out List<Expression> rank>
(.
	rank = new List<Expression>();
	Expression expr = null;
.) =
	Expr<out expr>
	[	"To" (. EnsureIsZero(expr); .)
		Expr<out expr>
	]
	(. if (expr != null) { rank.Add(expr); } .)
	{	","
		Expr<out expr>
		[	"To" (. EnsureIsZero(expr); .)
			Expr<out expr>
		]
		(. if (expr != null) { rank.Add(expr); } .)
	}
.

/* 9.6.3.4 */
CollectionInitializer<out CollectionInitializerExpression outExpr>
	(.
		Expression expr = null;
		CollectionInitializerExpression initializer = new CollectionInitializerExpression();
		Location startLocation = la.Location;
	.) =
	"{"
	[
		Expr<out expr>
		(.
			if (expr != null) { initializer.CreateExpressions.Add(expr); }
		.)
		{
			IF (NotFinalComma()) "," Expr<out expr>
			(. if (expr != null) { initializer.CreateExpressions.Add(expr); } .)
		}
	]
	"}"
	(.
		outExpr = initializer;
		outExpr.StartLocation = startLocation;
		outExpr.EndLocation = t.EndLocation;
	.)
.

Charset<out CharsetModifier charsetModifier>
	(. charsetModifier = CharsetModifier.None; .) =
	| "Ansi"		(. charsetModifier = CharsetModifier.Ansi; .)
	| "Auto"		(. charsetModifier = CharsetModifier.Auto; .)
	| "Unicode"		(. charsetModifier = CharsetModifier.Unicode; .)
	.

/* 9.2.6 */
HandlesClause<out List<string> handlesClause>
	(.
		handlesClause = new List<string>();
		string name;
	.) =
	"Handles" EventMemberSpecifier<out name>	(. if (name != null) handlesClause.Add(name); .)
	{ "," EventMemberSpecifier<out name>		(. if (name != null) handlesClause.Add(name); .) }
	.

/* 7.8. */
InterfaceBase<out List<TypeReference> bases>
	(.
		TypeReference type;
		bases = new List<TypeReference>();
	.) =
	"Inherits"
	TypeName<out type> (. if (type != null) bases.Add(type); .)
	{
		","
		TypeName<out type> (. if (type != null) bases.Add(type); .)
	}
	EndOfStmt
	.

/* 7.2 */
TypeImplementsClause<out List<TypeReference> baseInterfaces>
	(.
		baseInterfaces = new List<TypeReference>();
		TypeReference type = null;
	.) =
	"Implements" TypeName<out type>
	(.
		if (type != null) baseInterfaces.Add(type);
	.)
	{
		"," TypeName<out type>
		(. if (type != null) baseInterfaces.Add(type); .)
	}
	EndOfStmt
	.

/* 9.1 */
ImplementsClause<out List<InterfaceImplementation> baseInterfaces>
	(.
		baseInterfaces = new List<InterfaceImplementation>();
		TypeReference type = null;
		string memberName = null;
	.) =
	"Implements"
	NonArrayTypeName<out type, false>
	(. if (type != null) memberName = TypeReference.StripLastIdentifierFromType(ref type); .)
	(. baseInterfaces.Add(new InterfaceImplementation(type, memberName)); .)
	{ ","
		NonArrayTypeName<out type, false>
		(. if (type != null) memberName = TypeReference.StripLastIdentifierFromType(ref type); .)
		(. baseInterfaces.Add(new InterfaceImplementation(type, memberName)); .)
	}
.

EventMemberSpecifier<out string name>
(. string eventName; .)
=
	( Identifier | "MyBase" | "Me" )
	(. name = t.val; .)
	"."
	IdentifierOrKeyword<out eventName>
	(. name = name + "." + eventName; .)
.

Expr<out Expression expr>
	(. expr = null; Location startLocation = la.Location; .)
	=
	(
		  IF ( IsQueryExpression() )
		  QueryExpr<out expr>
		| LambdaExpr<out expr>
		| DisjunctionExpr<out expr>
	)
	(.
		if (expr != null) {
			expr.StartLocation = startLocation;
			expr.EndLocation = t.EndLocation;
		}
	.)
.

AssignmentOperator<out AssignmentOperatorType op>
	(. op = AssignmentOperatorType.None; .) =
	"="		(. op = AssignmentOperatorType.Assign; .)
	| "&="	(. op = AssignmentOperatorType.ConcatString; .)
	| "+="	(. op = AssignmentOperatorType.Add; .)
	| "-="	(. op = AssignmentOperatorType.Subtract; .)
	| "*="	(. op = AssignmentOperatorType.Multiply; .)
	| "/="	(. op = AssignmentOperatorType.Divide; .)
	| "\\="	(. op = AssignmentOperatorType.DivideInteger; .)
	| "^="	(. op = AssignmentOperatorType.Power; .)
	| "<<="	(. op = AssignmentOperatorType.ShiftLeft; .)
	| ">>="	(. op = AssignmentOperatorType.ShiftRight; .)
	.

/* 11.4 */
SimpleExpr<out Expression pexpr>
(. string name; Location startLocation = la.Location; .)
=
(
	SimpleNonInvocationExpression<out pexpr>
	{
			"." (
				XmlOpenTag IdentifierOrKeyword<out name> XmlCloseTag
				(. pexpr = new XmlMemberAccessExpression(pexpr, XmlAxisType.Element, name, true); .)
				| IdentifierOrKeyword<out name>
				(. pexpr = new MemberReferenceExpression(pexpr, name) { StartLocation = startLocation, EndLocation = t.EndLocation }; .)
			)
			[ IF (la.kind == Tokens.OpenParenthesis && Peek(1).kind == Tokens.Of)
					"(" "Of" TypeArgumentList<((MemberReferenceExpression)pexpr).TypeArguments> ")"
			]
		|	"!" IdentifierOrKeyword<out name> (. pexpr = new BinaryOperatorExpression(pexpr, BinaryOperatorType.DictionaryAccess, new PrimitiveExpression(name, name) { StartLocation = t.Location, EndLocation = t.EndLocation }); .)
		|	(. XmlAxisType type = XmlAxisType.Attribute; bool isXmlName = false; .)
			( ".@" | "..." (. type = XmlAxisType.Descendents; .) ) [ XmlOpenTag (. isXmlName = true; .) ] IdentifierOrKeyword<out name> [ XmlCloseTag ]
			(. pexpr = new XmlMemberAccessExpression(pexpr, type, name, isXmlName); .)
		|	InvocationExpression<ref pexpr>
	}
)
(.
	if (pexpr != null) {
		pexpr.StartLocation = startLocation;
		pexpr.EndLocation = t.EndLocation;
	}
.)
.

SimpleNonInvocationExpression<out Expression pexpr>
(.
	Expression expr;
	CollectionInitializerExpression cie;
	TypeReference type = null;
	string name = String.Empty;
	Location startLocation = la.Location;
	pexpr = null;
.) =
	(
		(
			/* 11.4.1 */ 
			LiteralString							(.pexpr = new PrimitiveExpression(t.literalValue, t.val) { LiteralFormat = t.literalFormat };  .)
		|	LiteralCharacter						(.pexpr = new PrimitiveExpression(t.literalValue, t.val) { LiteralFormat = t.literalFormat };  .)
		|	LiteralSingle							(.pexpr = new PrimitiveExpression(t.literalValue, t.val) { LiteralFormat = t.literalFormat };  .)
		|	LiteralDouble							(.pexpr = new PrimitiveExpression(t.literalValue, t.val) { LiteralFormat = t.literalFormat };  .)
		|	LiteralInteger						(.pexpr = new PrimitiveExpression(t.literalValue, t.val) { LiteralFormat = t.literalFormat };  .)
		|	LiteralDate							(.pexpr = new PrimitiveExpression(t.literalValue, t.val) { LiteralFormat = t.literalFormat };  .)
		|	LiteralDecimal						(.pexpr = new PrimitiveExpression(t.literalValue, t.val) { LiteralFormat = t.literalFormat };  .)
			/* True, False and Nothing are handled as literals in the spec */
		|	"True"											(.pexpr = new PrimitiveExpression(true, "true");  .)
		|	"False"											(.pexpr = new PrimitiveExpression(false, "false"); .)
		|	"Nothing"											(.pexpr = new PrimitiveExpression(null, "null");  .)
		|	/* 11.4.2 */ "(" Expr<out expr> ")" 				(. pexpr = new ParenthesizedExpression(expr); .)
		|	/* 11.4.4 */ Identifier
				(. 	pexpr = new IdentifierExpression(t.val);
					pexpr.StartLocation = t.Location; pexpr.EndLocation = t.EndLocation;
				.)
				[ IF (la.kind == Tokens.OpenParenthesis && Peek(1).kind == Tokens.Of)
					"(" "Of" TypeArgumentList<((IdentifierExpression)pexpr).TypeArguments> ")"
				]
		|	(. string val = String.Empty; .)
			( PrimitiveTypeName<out val> | "Object" (. val = "System.Object"; .) )
			(. pexpr = new TypeReferenceExpression(new TypeReference(val, true)); .)
		|	"Me"							(. pexpr = new ThisReferenceExpression(); .)
		|	(. Expression retExpr = null; .)
			( "MyBase"										(. retExpr = new BaseReferenceExpression() { StartLocation = t.Location, EndLocation = t.EndLocation }; .)
			| "MyClass"										(. retExpr = new ClassReferenceExpression() { StartLocation = t.Location, EndLocation = t.EndLocation }; .)
			)
			"." IdentifierOrKeyword<out name>				(. pexpr = new MemberReferenceExpression(retExpr, name) { StartLocation = startLocation, EndLocation = t.EndLocation }; .)
		|	"Global" "."
			Identifier (. type = new TypeReference(t.val ?? ""); .)
			/* fallback to "" is required if the token wasn't an identifier (->parser error but no exception) */
			(. type.IsGlobal = true; .)
			(. pexpr = new TypeReferenceExpression(type); .)
		|	ObjectCreateExpression<out expr>					(. pexpr = expr; .)
		|	CollectionInitializer<out cie>					(. pexpr = cie; .)
		|	/* 11.11 : Casts */
			(. CastType castType = CastType.Cast; .)
			( "DirectCast"
			| "CType"   (. castType = CastType.Conversion; .)
			| "TryCast" (. castType = CastType.TryCast; .)
			)
			"(" Expr<out expr> "," TypeName<out type> ")"
			(. pexpr = new CastExpression(type, expr, castType); .)
		|	/* 11.11 */ CastTarget<out type> "(" Expr<out expr> ")"	(. pexpr = new CastExpression(type, expr, CastType.PrimitiveConversion); .)
		|	/* 11.4.5 */ "AddressOf" Expr<out expr>			(. pexpr = new AddressOfExpression(expr); .)
		|	/* 11.5.1 */ "GetType" "(" GetTypeTypeName<out type> ")"	(. pexpr = new TypeOfExpression(type); .)
		|	/* 11.5.2 */ "TypeOf" SimpleExpr<out expr> "Is" TypeName<out type> (. pexpr = new TypeOfIsExpression(expr, type); .)
		|   /* 11.22 */ ConditionalExpression<out pexpr>
		| XmlLiteralExpression<out pexpr>
		)
	|
		(
			/* this form only occurs in WithStatements */
			"." (
				XmlOpenTag IdentifierOrKeyword<out name> XmlCloseTag
				(. pexpr = new XmlMemberAccessExpression(null, XmlAxisType.Element, name, true) { StartLocation = startLocation, EndLocation = t.EndLocation }; .)
				| IdentifierOrKeyword<out name>
				(. pexpr = new MemberReferenceExpression(null, name) { StartLocation = startLocation, EndLocation = t.EndLocation }; .)
			) |
			"!" IdentifierOrKeyword<out name> (. pexpr = new BinaryOperatorExpression(null, BinaryOperatorType.DictionaryAccess, new PrimitiveExpression(name, name) { StartLocation = t.Location, EndLocation = t.EndLocation }); .)
			| (. XmlAxisType axisType = XmlAxisType.Element; bool isXmlIdentifier = false; .)
			( "..." (. axisType = XmlAxisType.Descendents; .) | ".@" (. axisType = XmlAxisType.Attribute; .) ) (
				[ XmlOpenTag (. isXmlIdentifier = true; .) ] IdentifierOrKeyword<out name> [ XmlCloseTag ]
				(. pexpr = new XmlMemberAccessExpression(null, axisType, name, isXmlIdentifier); .)
			)
		)
	)
(.
	if (pexpr != null) {
		pexpr.StartLocation = startLocation;
		pexpr.EndLocation = t.EndLocation;
	}
.)
.

XmlLiteralExpression<out Expression pexpr>
(.
	List<XmlExpression> exprs = new List<XmlExpression>();
	XmlExpression currentExpression = null;
.)
	=
	(
		XmlContentExpression<exprs> { XmlContentExpression<exprs> } [ XmlElement<out currentExpression> (. exprs.Add(currentExpression); .) { XmlContentExpression<exprs> } ]
	|
		XmlElement<out currentExpression> (. exprs.Add(currentExpression); .) { XmlContentExpression<exprs> }
	)
	(.
		if (exprs.Count > 1) {
			pexpr = new XmlDocumentExpression() { Expressions = exprs };
		} else {
			pexpr = exprs[0];
		}
	.)
.

XmlContentExpression<List<XmlExpression> exprs> =
(. XmlContentExpression expr = null; .)
	(
		XmlContent (. expr = new XmlContentExpression(t.val, XmlContentType.Text); .)
		| XmlCData (. expr = new XmlContentExpression(t.val, XmlContentType.CData); .)
		| XmlComment (. expr = new XmlContentExpression(t.val, XmlContentType.Comment); .)
		| XmlProcessingInstruction (. expr = new XmlContentExpression(t.val, XmlContentType.ProcessingInstruction); .)
	)
	(.
		expr.StartLocation = t.Location;
		expr.EndLocation = t.EndLocation;
		exprs.Add(expr);
	.)
.

XmlNestedContent<out XmlExpression expr>
	(. XmlExpression tmpExpr = null; Location start = la.Location; .)
=
	(
		XmlContent (. tmpExpr = new XmlContentExpression(t.val, XmlContentType.Text); .)
		| XmlCData (. tmpExpr = new XmlContentExpression(t.val, XmlContentType.CData); .)
		| XmlComment (. tmpExpr = new XmlContentExpression(t.val, XmlContentType.Comment); .)
		| XmlProcessingInstruction (. tmpExpr = new XmlContentExpression(t.val, XmlContentType.ProcessingInstruction); .)
		| XmlStartInlineVB (. Expression innerExpression; .) Expr<out innerExpression> XmlEndInlineVB (. tmpExpr = new XmlEmbeddedExpression() { InlineVBExpression = innerExpression }; .)
		| XmlElement<out tmpExpr>
	)
	(.
		if (tmpExpr.StartLocation.IsEmpty)
			tmpExpr.StartLocation = start;
		if (tmpExpr.EndLocation.IsEmpty)
			tmpExpr.EndLocation = t.EndLocation;
		expr = tmpExpr;
	.)
.

XmlElement<out XmlExpression expr>
	(. XmlElementExpression el = new XmlElementExpression(); .)
=
	(
		XmlOpenTag (. el.StartLocation = t.Location; .)
		( XmlStartInlineVB (. Expression innerExpression; .) Expr<out innerExpression> XmlEndInlineVB
		(. el.NameExpression = new XmlEmbeddedExpression() { InlineVBExpression = innerExpression }; .)
		| Identifier (. el.XmlName = t.val; .) ) { XmlAttribute<el.Attributes> }
		( XmlCloseTagEmptyElement (. el.EndLocation = t.EndLocation; .) | XmlCloseTag { (. XmlExpression child; .) XmlNestedContent<out child> (. el.Children.Add(child); .) } XmlOpenEndTag { ANY } XmlCloseTag (. el.EndLocation = t.EndLocation; .) )
	)
	(. expr = el; .)
.

XmlAttribute<List<XmlExpression> attrs>
	(. Location start = la.Location; .)
=
		Identifier (. string name = t.val; .) "="
		(. string literalValue = null; Expression expressionValue = null; bool useDoubleQuotes = false; .)
		( LiteralString (. literalValue = t.literalValue.ToString(); useDoubleQuotes = t.val[0] == '"'; .) | XmlStartInlineVB Expr<out expressionValue> XmlEndInlineVB )
		(. attrs.Add(new XmlAttributeExpression() { Name = name, ExpressionValue = expressionValue, LiteralValue = literalValue, UseDoubleQuotes = useDoubleQuotes, StartLocation = start, EndLocation = t.EndLocation }); .)
	|
		XmlStartInlineVB (. Expression innerExpression; .) Expr<out innerExpression> XmlEndInlineVB
		(. attrs.Add(new XmlEmbeddedExpression() { InlineVBExpression = innerExpression, StartLocation = start, EndLocation = t.EndLocation }); .)
.

ConditionalExpression<out Expression expr>
	(.
		ConditionalExpression conditionalExpression = new ConditionalExpression();
		BinaryOperatorExpression binaryOperatorExpression = new BinaryOperatorExpression();
		conditionalExpression.StartLocation = binaryOperatorExpression.StartLocation = la.Location;
		
		Expression condition = null;
		Expression trueExpr = null;
		Expression falseExpr = null;
	.)
=
	"If" "(" Expr<out condition> "," Expr<out trueExpr> [ "," Expr<out falseExpr> ] ")"
	(.
		if(falseExpr != null)
		{
			conditionalExpression.Condition = condition;
			conditionalExpression.TrueExpression = trueExpr;
			conditionalExpression.FalseExpression = falseExpr;
			conditionalExpression.EndLocation = t.EndLocation;
			
			expr = conditionalExpression;
		}
		else
		{
			binaryOperatorExpression.Left = condition;
			binaryOperatorExpression.Right = trueExpr;
			binaryOperatorExpression.Op = BinaryOperatorType.NullCoalescing;
			binaryOperatorExpression.EndLocation = t.EndLocation;
			
			expr = binaryOperatorExpression;
		}
	.)
.	

InvocationExpression<ref Expression pexpr>
(. List<Expression> parameters = null; .)
=
	"(" (. Location start = t.Location; .)
	ArgumentList<out parameters>
	")"
	(.
		pexpr = new InvocationExpression(pexpr, parameters);
	.)
	(. pexpr.StartLocation = start; pexpr.EndLocation = t.Location; .)
.

/* 11.11 */

CastTarget<out TypeReference type>
	(.
		type = null;
	.) =
	"CBool"		(. type = new TypeReference("System.Boolean", true); .)
	| "CByte"	(. type = new TypeReference("System.Byte", true); .)
	| "CSByte"	(. type = new TypeReference("System.SByte", true); .)
	| "CChar"	(. type = new TypeReference("System.Char", true); .)
	| "CDate"	(. type = new TypeReference("System.DateTime", true); .)
	| "CDec"	(. type = new TypeReference("System.Decimal", true); .)
	| "CDbl"	(. type = new TypeReference("System.Double", true); .)
	| "CShort"	(. type = new TypeReference("System.Int16", true); .)
	| "CInt"	(. type = new TypeReference("System.Int32", true); .)
	| "CLng"	(. type = new TypeReference("System.Int64", true); .)
	| "CUShort"	(. type = new TypeReference("System.UInt16", true); .)
	| "CUInt"	(. type = new TypeReference("System.UInt32", true); .)
	| "CULng"	(. type = new TypeReference("System.UInt64", true); .)
	| "CObj"	(. type = new TypeReference("System.Object", true); .)
	| "CSng"	(. type = new TypeReference("System.Single", true); .)
	| "CStr"	(. type = new TypeReference("System.String", true); .)
	.

DisjunctionExpr<out Expression outExpr>
(.
	Expression expr;
	BinaryOperatorType op = BinaryOperatorType.None;
	Location startLocation = la.Location;
.) =
	ConjunctionExpr<out outExpr>
	{
		(
			  "Or"     (. op = BinaryOperatorType.BitwiseOr; .)
			| "OrElse" (. op = BinaryOperatorType.LogicalOr; .)
			| "Xor"    (. op = BinaryOperatorType.ExclusiveOr; .)
		)
		ConjunctionExpr<out expr> (.  outExpr = new BinaryOperatorExpression(outExpr, op, expr) { StartLocation = startLocation, EndLocation = t.EndLocation };  .)
	}
.

ConjunctionExpr<out Expression outExpr>
(.
	Expression expr;
	BinaryOperatorType op = BinaryOperatorType.None;
	Location startLocation = la.Location;
.) =
	NotExpr<out outExpr>
	{
		(
			  "And"     (. op = BinaryOperatorType.BitwiseAnd; .)
			| "AndAlso" (. op = BinaryOperatorType.LogicalAnd; .)
		)
		NotExpr<out expr> (.  outExpr = new BinaryOperatorExpression(outExpr, op, expr) { StartLocation = startLocation, EndLocation = t.EndLocation };  .)
	}
.

NotExpr<out Expression outExpr> 
	(. UnaryOperatorType uop = UnaryOperatorType.None; .) =
	{	"Not" (. uop = UnaryOperatorType.Not; .) }
	ComparisonExpr<out outExpr>
                (. if (uop != UnaryOperatorType.None)
	                   outExpr = new UnaryOperatorExpression(outExpr, uop);
                .)
	.

ComparisonExpr<out Expression outExpr>
(.
	Expression expr;
	BinaryOperatorType op = BinaryOperatorType.None;
	Location startLocation = la.Location;
.) =
	ShiftExpr<out outExpr>
	{
		(
			"<"    (. op = BinaryOperatorType.LessThan; .)
			| ">"  (. op = BinaryOperatorType.GreaterThan; .)
			| "<=" (. op = BinaryOperatorType.LessThanOrEqual; .)
			| ">=" (. op = BinaryOperatorType.GreaterThanOrEqual; .)
			| "<>"		(. op = BinaryOperatorType.InEquality; .)
			| "=" 		(. op = BinaryOperatorType.Equality; .)
			| "Like"	(. op = BinaryOperatorType.Like; .)
			| "Is"	(. op = BinaryOperatorType.ReferenceEquality; .)
			| "IsNot" (. op = BinaryOperatorType.ReferenceInequality; .)
		)
		(
			ShiftExpr<out expr> (.  outExpr = new BinaryOperatorExpression(outExpr, op, expr) { StartLocation = startLocation, EndLocation = t.EndLocation };  .)
		| (. Location startLocation2 = la.Location; .)
			"Not"
			ShiftExpr<out expr> (.  outExpr = new BinaryOperatorExpression(outExpr, op, new UnaryOperatorExpression(expr, UnaryOperatorType.Not) { StartLocation = startLocation2, EndLocation = t.EndLocation }) { StartLocation = startLocation, EndLocation = t.EndLocation };  .)
		)
	}
.

ShiftExpr<out Expression outExpr>
	(.
		Expression expr;
		BinaryOperatorType op = BinaryOperatorType.None;
		Location startLocation = la.Location;
	.) =
	ConcatenationExpr<out outExpr> 
	{
		(
			"<<"   (. op = BinaryOperatorType.ShiftLeft; .)
			| ">>" (. op = BinaryOperatorType.ShiftRight; .)
		)
		ConcatenationExpr<out expr> (.  outExpr = new BinaryOperatorExpression(outExpr, op, expr) { StartLocation = startLocation, EndLocation = t.EndLocation };  .) 
	}
	.

ConcatenationExpr<out Expression outExpr>
(. Expression expr; Location startLocation = la.Location; .)
=
	AdditiveExpr<out outExpr> { "&" AdditiveExpr<out expr> (.  outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.Concat, expr) { StartLocation = startLocation, EndLocation = t.EndLocation };  .) }
.

AdditiveExpr<out Expression outExpr>
(.
	Expression expr;
	BinaryOperatorType op = BinaryOperatorType.None;
	Location startLocation = la.Location;
.) =
	ModuloExpr<out outExpr>
	{
		(
			  "+"   (. op = BinaryOperatorType.Add; .)
			| "-" (. op = BinaryOperatorType.Subtract; .)
		)
		ModuloExpr<out expr> (.  outExpr = new BinaryOperatorExpression(outExpr, op, expr) { StartLocation = startLocation, EndLocation = t.EndLocation };  .)
	}
.

ModuloExpr<out Expression outExpr>
(. Expression expr; Location startLocation = la.Location; .)
= 
	IntegerDivisionExpr<out outExpr> { "Mod" IntegerDivisionExpr<out expr> (.  outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.Modulus, expr) { StartLocation = startLocation, EndLocation = t.EndLocation };  .) }
.

IntegerDivisionExpr<out Expression outExpr>
(. Expression expr; Location startLocation = la.Location; .)
=
	MultiplicativeExpr<out outExpr> { "\\" MultiplicativeExpr<out expr> (.  outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.DivideInteger, expr) { StartLocation = startLocation, EndLocation = t.EndLocation };  .) }
.

MultiplicativeExpr<out Expression outExpr>
(.
	Expression expr;
	BinaryOperatorType op = BinaryOperatorType.None;
	Location startLocation = la.Location;
.) =
	UnaryExpr<out outExpr>
	{
		(
			"*"   (. op = BinaryOperatorType.Multiply; .)
			| "/" (. op = BinaryOperatorType.Divide; .)
		) 
		UnaryExpr<out expr> (. outExpr = new BinaryOperatorExpression(outExpr, op, expr) { StartLocation = startLocation, EndLocation = t.EndLocation }; .) 
	}
.

UnaryExpr<out Expression uExpr> 
(.
	Expression expr;
	UnaryOperatorType uop = UnaryOperatorType.None;
	Location startLocation = la.Location;
	bool isUOp = false;
.) =
	{ 	"+" 		(. uop = UnaryOperatorType.Plus; isUOp = true; .)
		| "-" 		(. uop = UnaryOperatorType.Minus; isUOp = true; .)
		| "*" 		(. uop = UnaryOperatorType.Dereference;  isUOp = true;.)
	}
	ExponentiationExpr<out expr>
	(.
		if (isUOp) {
			uExpr = new UnaryOperatorExpression(expr, uop) { StartLocation = startLocation, EndLocation = t.EndLocation };
		} else {
			uExpr = expr;
		}
	.)
.

ExponentiationExpr<out Expression outExpr>
(. Expression expr; Location startLocation = la.Location; .)
=
	SimpleExpr<out outExpr> { "^" SimpleExpr<out expr> (.  outExpr = new BinaryOperatorExpression(outExpr, BinaryOperatorType.Power, expr) { StartLocation = startLocation, EndLocation = t.EndLocation };  .) }
.
	
ObjectCreateExpression<out Expression oce>
(.
	TypeReference type = null;
	CollectionInitializerExpression initializer = null;
	List<Expression> arguments = null;
	ArrayList dimensions = null;
	oce = null;
	Location startLocation = la.Location;
	bool canBeNormal; bool canBeReDim;
.) =
	"New" 
	[ NonArrayTypeName<out type, false>
		["(" NormalOrReDimArgumentList<out arguments, out canBeNormal, out canBeReDim> ")"
			[ IF (la.kind == Tokens.OpenParenthesis)
				ArrayTypeModifiers<out dimensions>
				CollectionInitializer<out initializer>
			|	CollectionInitializer<out initializer>
			]
			(. if (canBeReDim && !canBeNormal && initializer == null) initializer = new CollectionInitializerExpression(); .)
		]
	]
	(.
		if (initializer == null) {
			oce = new ObjectCreateExpression(type, arguments);
		} else {
			if (dimensions == null) dimensions = new ArrayList();
			dimensions.Insert(0, (arguments == null) ? 0 : Math.Max(arguments.Count - 1, 0));
			type.RankSpecifier = (int[])dimensions.ToArray(typeof(int));
			ArrayCreateExpression ace = new ArrayCreateExpression(type, initializer);
			ace.Arguments = arguments;
			oce = ace;
		}
	.)
	
	[
		(
			(.
				MemberInitializerExpression memberInitializer = null;
				Expression anonymousMember = null;
			.)
			"With"
			(.
				CollectionInitializerExpression memberInitializers = new CollectionInitializerExpression();
				memberInitializers.StartLocation = la.Location;
			.)
			"{"
				(
					MemberInitializer<out memberInitializer>
						(. memberInitializers.CreateExpressions.Add(memberInitializer); .)
					| Expr<out anonymousMember>
						(. memberInitializers.CreateExpressions.Add(anonymousMember); .)
				)
				{ ","
					(
						MemberInitializer<out memberInitializer>
							(. memberInitializers.CreateExpressions.Add(memberInitializer); .)
						| Expr<out anonymousMember>
							(. memberInitializers.CreateExpressions.Add(anonymousMember); .)
					)
				}
			"}"
			(.
				memberInitializers.EndLocation = t.Location;
				if(oce is ObjectCreateExpression)
				{
					((ObjectCreateExpression)oce).ObjectInitializer = memberInitializers;
				}
			.)
		)
	|
		(
			"From"
			CollectionInitializer<out initializer>
			(.
				if(oce is ObjectCreateExpression)
					((ObjectCreateExpression)oce).ObjectInitializer = initializer;
			.)
		)
	]
	(.
		if (oce != null) {
			oce.StartLocation = startLocation;
			oce.EndLocation = t.EndLocation;
		}
	.)
.

LambdaExpr<out Expression expr>
	(.
		LambdaExpression lambda = null;
	.) =
	( SubLambdaExpression<out lambda> |
	FunctionLambdaExpression<out lambda> )
	(. expr = lambda; .)
.

SubLambdaExpression<out LambdaExpression lambda>
	(.
		lambda = new LambdaExpression();
		lambda.ReturnType = new TypeReference("System.Void", true);
		Expression inner = null;
		Statement statement = null;
		lambda.StartLocation = la.Location;
	.)
=
	"Sub" [ "(" [ FormalParameterList<lambda.Parameters> ] ")" ]
	(
		(
			Expr<out inner>
			(.
				lambda.ExpressionBody = inner;
				lambda.EndLocation = t.EndLocation; // la.Location?
			.)
		|
			EmbeddedStatement<out statement>
			(.
				lambda.StatementBody = statement;
				lambda.EndLocation = t.EndLocation;
			.)
		)
	|
		EOL
		Block<out statement>
		"End" "Sub"
		(.
			lambda.StatementBody = statement;
			lambda.EndLocation = t.EndLocation;
		.)
	)
.

FunctionLambdaExpression<out LambdaExpression lambda>
	(.
		lambda = new LambdaExpression();
		TypeReference typeRef = null;
		Expression inner = null;
		Statement statement = null;
		lambda.StartLocation = la.Location;
	.)
=
	"Function" [ "(" [ FormalParameterList<lambda.Parameters> ] ")" ]
	[ "As" TypeName<out typeRef> (. lambda.ReturnType = typeRef; .) ]
	(
		(
			Expr<out inner>
			(.
				lambda.ExpressionBody = inner;
				lambda.EndLocation = t.EndLocation; // la.Location?
			.)
		|
			EmbeddedStatement<out statement>
			(.
				lambda.StatementBody = statement;
				lambda.EndLocation = t.EndLocation;
			.)
		)
	|
		EOL
		Block<out statement>
		"End" "Function"
		(.
			lambda.StatementBody = statement;
			lambda.EndLocation = t.EndLocation;
		.)
	)
.

QueryExpr<out Expression expr>
	(.
		QueryExpressionVB qexpr = new QueryExpressionVB();
		qexpr.StartLocation = la.Location;
		expr = qexpr;
	.) =
	FromOrAggregateQueryOperator<qexpr.Clauses>
	{ QueryOperator<qexpr.Clauses> }
	(.
		qexpr.EndLocation = t.EndLocation;
	.)
.

FromOrAggregateQueryOperator<List<QueryExpressionClause> middleClauses>
	(.
		QueryExpressionFromClause fromClause = null;
		QueryExpressionAggregateClause aggregateClause = null;
	.) =
	   FromQueryOperator<out fromClause>
	   (. middleClauses.Add(fromClause); .)
	|  AggregateQueryOperator<out aggregateClause>
	   (. middleClauses.Add(aggregateClause); .)
.

QueryOperator<List<QueryExpressionClause> middleClauses>
	(.
		QueryExpressionJoinVBClause joinClause = null;
		QueryExpressionGroupVBClause groupByClause = null;
		QueryExpressionPartitionVBClause partitionClause = null;
		QueryExpressionGroupJoinVBClause groupJoinClause = null;
		QueryExpressionFromClause fromClause = null;
		QueryExpressionAggregateClause aggregateClause = null;
	.) =
	   FromQueryOperator<out fromClause>
	   (. middleClauses.Add(fromClause); .)
	|  AggregateQueryOperator<out aggregateClause>
	   (. middleClauses.Add(aggregateClause); .)
    | SelectQueryOperator<middleClauses>
	| DistinctQueryOperator<middleClauses>
	| WhereQueryOperator<middleClauses>
	| OrderByQueryOperator<middleClauses>
	| PartitionQueryOperator<out partitionClause>
	  (. middleClauses.Add(partitionClause); .)
	| LetQueryOperator<middleClauses>
	| JoinQueryOperator<out joinClause>
	  (. middleClauses.Add(joinClause); .)
	| IF(la.kind == Tokens.Group && Peek(1).kind == Tokens.Join) GroupJoinQueryOperator<out groupJoinClause>
	  (. middleClauses.Add(groupJoinClause); .)
	| GroupByQueryOperator<out groupByClause>
	  (. middleClauses.Add(groupByClause); .)
.	

OrderByQueryOperator<List<QueryExpressionClause> middleClauses>
	(.
		QueryExpressionOrderClause orderClause = new QueryExpressionOrderClause();
		orderClause.StartLocation = la.Location;
		List<QueryExpressionOrdering> orderings = null;
	.) =
	"Order" "By" OrderExpressionList<out orderings>
	(.
		orderClause.Orderings = orderings;
		orderClause.EndLocation = t.EndLocation;
		middleClauses.Add(orderClause);
	.)
.

OrderExpressionList<out List<QueryExpressionOrdering> orderings>
	(.
		orderings = new List<QueryExpressionOrdering>();
		QueryExpressionOrdering ordering = null;
	.) =
	OrderExpression<out ordering>
	(. orderings.Add(ordering); .)
	{
		"," OrderExpression<out ordering>
		(. orderings.Add(ordering); .)
	}
.

OrderExpression<out QueryExpressionOrdering ordering>
	(.
		ordering = new QueryExpressionOrdering();
		ordering.StartLocation = la.Location;
		ordering.Direction = QueryExpressionOrderingDirection.None;
		Expression orderExpr = null;
	.) =
	Expr<out orderExpr>
	(.
		ordering.Criteria = orderExpr;
	.)
	[
		  "Ascending" 	(. ordering.Direction = QueryExpressionOrderingDirection.Ascending; .)
		| "Descending"	(. ordering.Direction = QueryExpressionOrderingDirection.Descending; .)
	]
	(. ordering.EndLocation = t.EndLocation; .)
.

GroupByQueryOperator<out QueryExpressionGroupVBClause groupByClause>
	(.
		groupByClause = new QueryExpressionGroupVBClause();
		groupByClause.StartLocation = la.Location;
	.) =
	"Group" ExpressionRangeVariableDeclarationList<groupByClause.GroupVariables>
	"By" ExpressionRangeVariableDeclarationList<groupByClause.ByVariables>
	"Into" ExpressionRangeVariableDeclarationList<groupByClause.IntoVariables>
	(.
		groupByClause.EndLocation = t.EndLocation;
	.)
.

GroupJoinQueryOperator<out QueryExpressionGroupJoinVBClause groupJoinClause>
	(.
		groupJoinClause = new QueryExpressionGroupJoinVBClause();
		groupJoinClause.StartLocation = la.Location;
		QueryExpressionJoinVBClause joinClause = null;
	.) =
	"Group" JoinQueryOperator<out joinClause>
	"Into"  ExpressionRangeVariableDeclarationList<groupJoinClause.IntoVariables>
	(.
		groupJoinClause.JoinClause = joinClause;
		groupJoinClause.EndLocation = t.EndLocation;
	.)
.

FromQueryOperator<out QueryExpressionFromClause fromClause>
	(.
	    fromClause = new QueryExpressionFromClause();
	    fromClause.StartLocation = la.Location;
	.) =
	"From" CollectionRangeVariableDeclarationList<fromClause.Sources>
	(.
	   fromClause.EndLocation = t.EndLocation;
	.)
.

SelectQueryOperator<List<QueryExpressionClause> middleClauses>
	(.
		QueryExpressionSelectVBClause selectClause = new QueryExpressionSelectVBClause();
		selectClause.StartLocation = la.Location;
	.) =
	"Select" ExpressionRangeVariableDeclarationList<selectClause.Variables>
	(.
		selectClause.EndLocation = t.Location;
		middleClauses.Add(selectClause);
	.)
.

DistinctQueryOperator<List<QueryExpressionClause> middleClauses>
	(.
		QueryExpressionDistinctClause distinctClause = new QueryExpressionDistinctClause();
		distinctClause.StartLocation = la.Location;
	.) =
	"Distinct"
	(.
		distinctClause.EndLocation = t.EndLocation;
		middleClauses.Add(distinctClause);
	.)
.

WhereQueryOperator<List<QueryExpressionClause> middleClauses>
	(.
		QueryExpressionWhereClause whereClause = new QueryExpressionWhereClause();
		whereClause.StartLocation = la.Location;
		Expression operand = null;
	.) =
	"Where" Expr<out operand>
	(.
		whereClause.Condition = operand;
		whereClause.EndLocation = t.EndLocation;
		
		middleClauses.Add(whereClause);
	.)
.

PartitionQueryOperator<out QueryExpressionPartitionVBClause partitionClause>
	(.
		partitionClause = new QueryExpressionPartitionVBClause();
		partitionClause.StartLocation = la.Location;
		Expression expr = null;
	.) =
	  (
	   "Take" (. partitionClause.PartitionType = QueryExpressionPartitionType.Take; .)
	  [ "While" (. partitionClause.PartitionType = QueryExpressionPartitionType.TakeWhile; .) ]
	| "Skip" (. partitionClause.PartitionType = QueryExpressionPartitionType.Skip; .)
      [ "While" (. partitionClause.PartitionType = QueryExpressionPartitionType.SkipWhile; .) ]
      )
	  Expr<out expr>
	(.
		partitionClause.Expression = expr;
		partitionClause.EndLocation = t.EndLocation;
	.)
.

AggregateQueryOperator<out QueryExpressionAggregateClause aggregateClause>
	(.
		aggregateClause = new QueryExpressionAggregateClause();
		aggregateClause.IntoVariables = new List<ExpressionRangeVariable>();
		aggregateClause.StartLocation = la.Location;
		CollectionRangeVariable source;
	.) =
	"Aggregate" CollectionRangeVariableDeclaration<out source>
	(.
		aggregateClause.Source = source;
	.)
	{
		QueryOperator<aggregateClause.MiddleClauses>
	}
	"Into" ExpressionRangeVariableDeclarationList<aggregateClause.IntoVariables>
	(.
		aggregateClause.EndLocation = t.EndLocation;
	.)
.

LetQueryOperator<List<QueryExpressionClause> middleClauses>
	(.
		QueryExpressionLetVBClause letClause = new QueryExpressionLetVBClause();
		letClause.StartLocation = la.Location;
	.) =
	"Let" ExpressionRangeVariableDeclarationList<letClause.Variables>
	(.
		letClause.EndLocation = t.EndLocation;
		middleClauses.Add(letClause);
	.)
.	

ExpressionRangeVariableDeclarationList<List<ExpressionRangeVariable> variables>
	(.
		ExpressionRangeVariable variable = null;
	.) =
	ExpressionRangeVariableDeclaration<out variable>
	(. variables.Add(variable); .)
	{ "," ExpressionRangeVariableDeclaration<out variable> (. variables.Add(variable); .) }
.

ExpressionRangeVariableDeclaration<out ExpressionRangeVariable variable>
	(.
		variable = new ExpressionRangeVariable();
		variable.StartLocation = la.Location;
		Expression rhs = null;
		TypeReference typeName = null;
	.) =
	[
		IF(IsIdentifiedExpressionRange()) Identifier
		(. variable.Identifier = t.val; .)
		[
			"As" TypeName<out typeName>
			(. variable.Type = typeName; .)
		]
		"="
	]
	Expr<out rhs>
	(.
		variable.Expression = rhs;
		variable.EndLocation = t.EndLocation;
	.)
.

JoinQueryOperator<out QueryExpressionJoinVBClause joinClause>
	(.
		joinClause = new QueryExpressionJoinVBClause();
		joinClause.StartLocation = la.Location;
		CollectionRangeVariable joinVariable = null;
		QueryExpressionJoinVBClause subJoin = null;
		QueryExpressionJoinConditionVB condition = null;
		
	.) =
	"Join" CollectionRangeVariableDeclaration<out joinVariable> 
	(. joinClause.JoinVariable = joinVariable; .)
	[
		JoinQueryOperator<out subJoin>
		(. joinClause.SubJoin = subJoin; .)
	]
	"On"
	JoinCondition<out condition>
	(. SafeAdd(joinClause, joinClause.Conditions, condition); .)
	{
		"And" JoinCondition<out condition>
		(. SafeAdd(joinClause, joinClause.Conditions, condition); .)
	}
	(.
		joinClause.EndLocation = t.EndLocation;
	.)
.

CollectionRangeVariableDeclarationList<List<CollectionRangeVariable> rangeVariables>
(. CollectionRangeVariable variableDeclaration; .)
  =
	CollectionRangeVariableDeclaration<out variableDeclaration>
	(. rangeVariables.Add(variableDeclaration); .)
	{ "," CollectionRangeVariableDeclaration<out variableDeclaration> (. rangeVariables.Add(variableDeclaration); .) }
.

CollectionRangeVariableDeclaration<out CollectionRangeVariable rangeVariable>
	(.
		rangeVariable = new CollectionRangeVariable();
		rangeVariable.StartLocation = la.Location;
		TypeReference typeName = null;
		Expression inExpr = null;
	.) =
	Identifier (. rangeVariable.Identifier = t.val; .)
	[ "As" TypeName<out typeName> (. rangeVariable.Type = typeName; .) ] 
	"In" Expr<out inExpr>
	(.
		rangeVariable.Expression = inExpr;
		rangeVariable.EndLocation = t.EndLocation;
	.)
.

JoinCondition<out QueryExpressionJoinConditionVB condition>
	(.
		condition = new QueryExpressionJoinConditionVB();
		condition.StartLocation = la.Location;
		
		Expression lhs = null;
		Expression rhs = null;
	.) =
	Expr<out lhs> "Equals" Expr<out rhs>
	(.
		condition.LeftSide = lhs;
		condition.RightSide = rhs;
		condition.EndLocation = t.EndLocation;
	.)
.

MemberInitializer<out MemberInitializerExpression memberInitializer>
	(.
		memberInitializer = new MemberInitializerExpression();
		memberInitializer.StartLocation = la.Location;
		Expression initExpr = null;
		bool isKey = false;
		string name = null;
	.) =
	[ "Key" (. isKey = true; .) ]
	"." IdentifierOrKeyword<out name> "=" Expr<out initExpr>
	(.
		memberInitializer.Name = name;
		memberInitializer.Expression = initExpr;
		memberInitializer.IsKey = isKey;
		memberInitializer.EndLocation = t.EndLocation;
	.)
.

/* 9.3.2 */
ArgumentList<out List<Expression> arguments>
	(.
		arguments = new List<Expression>();
		Expression expr = null;
	.) =
	[ Argument<out expr> ]
	{ "," (. arguments.Add(expr ?? Expression.Null); expr = null; .)
		[ Argument<out expr> ]
		(. if (expr == null) expr = Expression.Null; .)
	}
	(. if (expr != null) arguments.Add(expr); .)
.

/* argument list that hasn't decided if it is method call or array initialisation */
NormalOrReDimArgumentList<out List<Expression> arguments, out bool canBeNormal, out bool canBeRedim>
	(.
		arguments = new List<Expression>();
		canBeNormal = true; canBeRedim = !IsNamedAssign();
		Expression expr = null;
	.)
=
	[ Argument<out expr>
	  [ "To" (. EnsureIsZero(expr); canBeNormal = false; .)
	    Expr<out expr>
	] ]
	{ ","
		(. if (expr == null) canBeRedim = false; .)
		(. arguments.Add(expr ?? Expression.Null); expr = null; .)
		(. canBeRedim &= !IsNamedAssign(); .)
		[ Argument<out expr>
		  [ "To" (. EnsureIsZero(expr); canBeNormal = false; .)
		    Expr<out expr>
		] ]
		(. if (expr == null) { canBeRedim = false; expr = Expression.Null; } .)
	}
	(. if (expr != null) arguments.Add(expr); else canBeRedim = false; .)
.

/* Spec, 11.8 */
Argument<out Expression argumentexpr>
	(.
		Expression expr;
		argumentexpr = null;
		string name;
		Location startLocation = la.Location;
	.) =
	IF(IsNamedAssign()) Identifier (. name = t.val;  .) ":=" Expr<out expr>
	(.
		argumentexpr = new NamedArgumentExpression(name, expr) { StartLocation = startLocation, EndLocation = t.EndLocation };
	.)
	|
	Expr<out argumentexpr>
.

/* 7.1. */
TypeName<out TypeReference typeref>
(. ArrayList rank = null; Location startLocation = la.Location; .)
=
	NonArrayTypeName<out typeref, false>
	ArrayTypeModifiers<out rank>
	(.
		if (typeref != null) {
			if (rank != null) {
				typeref.RankSpecifier = (int[])rank.ToArray(typeof(int));
			}
			typeref.StartLocation = startLocation;
			typeref.EndLocation = t.EndLocation;
		}
	.)
.

GetTypeTypeName<out TypeReference typeref>
(. ArrayList rank = null; .)
=
	NonArrayTypeName<out typeref, true>
	ArrayTypeModifiers<out rank>
	(.	if (rank != null && typeref != null) {
			typeref.RankSpecifier = (int[])rank.ToArray(typeof(int));
		}
	.)
.

/* 7.1 */
NonArrayTypeName<out TypeReference typeref, bool canBeUnbound>
(.
	string name;
	typeref = null;
	bool isGlobal = false;
.) =
	(
		[ "Global" "." (. isGlobal = true; .) ]
		QualIdentAndTypeArguments<out typeref, canBeUnbound>
		(. typeref.IsGlobal = isGlobal; .)
		{ "." (. TypeReference nestedTypeRef; .)
			QualIdentAndTypeArguments<out nestedTypeRef, canBeUnbound>
			(. typeref = new InnerClassTypeReference(typeref, nestedTypeRef.Type, nestedTypeRef.GenericTypes); .)
		}
	)
	| "Object" (. typeref = new TypeReference("System.Object", true); .)
		[
	  	"?"
	  	(.
		  	List<TypeReference> typeArguments = new List<TypeReference>(1);
		  	if (typeref != null) typeArguments.Add(typeref);
			typeref = new TypeReference("System.Nullable", typeArguments) { IsKeyword = true };
		.)			
	  ]
	
	| PrimitiveTypeName<out name> (. typeref = new TypeReference(name, true); .)
	  [
		"?"
	  	(.
		  	List<TypeReference> typeArguments = new List<TypeReference>(1);
		  	if (typeref != null) typeArguments.Add(typeref);
			typeref = new TypeReference("System.Nullable", typeArguments) { IsKeyword = true };
		.)			
	  ]
.

QualIdentAndTypeArguments<out TypeReference typeref, bool canBeUnbound>
(. string name; typeref = null; .)
=
	Qualident<out name>
	(. typeref = new TypeReference(name); .)
	[IF (la.kind == Tokens.OpenParenthesis && Peek(1).kind == Tokens.Of)
		"(" "Of"
		( IF (canBeUnbound && (la.kind == Tokens.CloseParenthesis || la.kind == Tokens.Comma))
			(. typeref.GenericTypes.Add(NullTypeReference.Instance); .)
			{ "," (. typeref.GenericTypes.Add(NullTypeReference.Instance); .) }
		  | TypeArgumentList<typeref.GenericTypes>
		)
		")"
	]
.

/* 7.9 */
ArrayNameModifier<out ArrayList arrayModifiers>
(.
	arrayModifiers = null;
.) =
	ArrayTypeModifiers<out arrayModifiers>
.


/* 7.9 */
ArrayTypeModifiers<out ArrayList arrayModifiers>
(.
	arrayModifiers = new ArrayList();
	int i = 0;
.) =
	{	IF (IsDims())
		"("
		[ RankList<out i>]
		(.
			arrayModifiers.Add(i);
		.)
		")"
	}
	(.
		if(arrayModifiers.Count == 0) {
			 arrayModifiers = null;
		}
	.)
.

/* 7.9 */
RankList<out int i>
(. i = 0; .) =
	{ "," (. ++i; .) }
.

/* 7.12 */
TypeArgumentList<List<TypeReference> typeArguments>
(.
	TypeReference typeref;
.) =
	TypeName<out typeref> (. if (typeref != null) typeArguments.Add(typeref); .)
	{
		","
		TypeName<out typeref> (. if (typeref != null) typeArguments.Add(typeref); .)
	}
.

GlobalAttributeSection =
	"<" (. Location startPos = t.Location; .)
	("Assembly" | "Module")
		(.  string attributeTarget = t.val != null ? t.val.ToLower(System.Globalization.CultureInfo.InvariantCulture) : null;
			List<ASTAttribute> attributes = new List<ASTAttribute>();
			ASTAttribute attribute;
		.)
	":" Attribute<out attribute> (. attributes.Add(attribute); .)
	{ IF (NotFinalComma()) ["," ("Assembly" | "Module") ":"] Attribute<out attribute> (. attributes.Add(attribute); .)}
	[ "," ]
	">"
	EndOfStmt
		(.
			AttributeSection section = new AttributeSection {
				AttributeTarget = attributeTarget,
				Attributes = attributes,
				StartLocation = startPos,
				EndLocation = t.EndLocation
			};
			AddChild(section);
		.)
	.

/* Spec, 5. */
Attribute<out ASTAttribute attribute>
(.
	string name;
	List<Expression> positional = new List<Expression>();
	List<NamedArgumentExpression> named = new List<NamedArgumentExpression>();
	Location startLocation = la.Location;
.) =
	[ "Global" "." ]
	Qualident<out name>
	[ AttributeArguments<positional, named> ]
	(.
		attribute  = new ASTAttribute(name, positional, named) { StartLocation = startLocation, EndLocation = t.EndLocation };
	.)
.

/* Spec, 5.2.2 */
AttributeArguments<List<Expression> positional, List<NamedArgumentExpression> named>
	(.
		bool nameFound = false;
		string name = "";
		Expression expr;
	.) =
	"("
	[
		IF (IsNotClosingParenthesis()) (
			(. Location startLocation = la.Location; .)
			[
				IF (IsNamedAssign()) (. nameFound = true; .)
				IdentifierOrKeyword<out name>
				( ":=" | "=" )
			] Expr<out expr>
				(.
					if (expr != null) {
						if (string.IsNullOrEmpty(name)) { positional.Add(expr); }
						else { named.Add(new NamedArgumentExpression(name, expr) { StartLocation = startLocation, EndLocation = t.EndLocation }); name = ""; }
					}
				.)
			{
				","
					(
						IF (IsNamedAssign())	(. nameFound = true; .)
						IdentifierOrKeyword<out name>
						( ":=" | "=" )
						| (. if (nameFound) Error("no positional argument after named argument"); .)
					) Expr<out expr>	(. 	if (expr != null) { if(name == "") positional.Add(expr);
											else { named.Add(new NamedArgumentExpression(name, expr) { StartLocation = startLocation, EndLocation = t.EndLocation }); name = ""; }
											}
										.)
			}
		)
	]
	")"
	.

/* Spec, 5. */
AttributeSection<out AttributeSection section>
	(.
		string attributeTarget = "";
		List<ASTAttribute> attributes = new List<ASTAttribute>();
		ASTAttribute attribute;
		Location startLocation = la.Location;
	.) =
	"<"
	[ IF (IsLocalAttrTarget())
		( "Event"		(. attributeTarget = "event";.)
		| "Return"		(. attributeTarget = "return";.)
		| Identifier
			(.
				string val = t.val.ToLower(System.Globalization.CultureInfo.InvariantCulture);
				if (val != "field"	|| val != "method" ||
					val != "module" || val != "param"  ||
					val != "property" || val != "type")
				Error("attribute target specifier (event, return, field," +
						"method, module, param, property, or type) expected");
				attributeTarget = t.val;
			.)
		) ":" 
	]
	Attribute<out attribute>	(. attributes.Add(attribute); .)
	{ IF (NotFinalComma()) "," Attribute<out attribute> (. attributes.Add(attribute); .) }
	[ "," ]
	">"
		(.
			section = new AttributeSection {
				AttributeTarget = attributeTarget,
				Attributes = attributes,
				StartLocation = startLocation,
				EndLocation = t.EndLocation
			};
		.)
	.

/* 9.2.5 */
FormalParameterList<List<ParameterDeclarationExpression> parameter>
(. ParameterDeclarationExpression p; .)
=
	FormalParameter<out p>	(. if (p != null) parameter.Add(p); .)
	{	","
		FormalParameter<out p>	(. if (p != null) parameter.Add(p); .)
	}
.
/* 9.2.5 */
FormalParameter<out ParameterDeclarationExpression p>
(.
	AttributeSection section;
	List<AttributeSection> attributes = new List<AttributeSection>();
	TypeReference type = null;
	ParamModifierList mod = new ParamModifierList(this);
	Expression expr = null;
	p = null;
	ArrayList arrayModifiers = null;
	Location startLocation = la.Location;
.)
=
	{ AttributeSection<out section> (. attributes.Add(section); .) }
	{ ParameterModifier<mod> }
	Identifier (. string parameterName = t.val; .)
	[ IF(IsDims()) ArrayTypeModifiers<out arrayModifiers> ]
	[ "As" TypeName<out type> ]
	(.
		if(type != null) {
			if (arrayModifiers != null) {
				if (type.RankSpecifier != null) {
					Error("array rank only allowed one time");
				} else {
					type.RankSpecifier = (int[])arrayModifiers.ToArray(typeof(int));
				}
			}
		}
	.)
	[ "=" Expr<out expr> ]
	(.
		mod.Check();
		p = new ParameterDeclarationExpression(type, parameterName, mod.Modifier, expr);
		p.Attributes = attributes;
		p.StartLocation = startLocation;
		p.EndLocation = t.EndLocation;
	.)
.

/* 10.1 */
Block<out Statement stmt>
	=
	(.
		BlockStatement blockStmt = new BlockStatement();
		/* in snippet parsing mode, t might be null */
		if (t != null) blockStmt.StartLocation = t.EndLocation;
		BlockStart(blockStmt);
	.)
	{	
			IF (IsEndStmtAhead())
				(. Token first = la; .)
				"End" EndOfStmt
				(.
					AddChild(new EndStatement() {
						StartLocation = first.Location,
						EndLocation = first.EndLocation }
					);
				.)
			| Statement EndOfStmt
/*	 	IF (!LeaveBlock()) { }*/
	}
	(.
		stmt = blockStmt;
		if (t != null) blockStmt.EndLocation = t.EndLocation;
		BlockEnd();
	.)
.

Statement
	(.
		Statement stmt = null;
		Location startPos = la.Location;
		string label = String.Empty;
		
	.) =
	(
		| IF (IsLabel()) LabelName<out label>
		(.
			AddChild(new LabelStatement(t.val));
		.)
		":" Statement
		| EmbeddedStatement<out stmt>			(. AddChild(stmt); .)
	)
	(.
		if (stmt != null) {
			stmt.StartLocation = startPos;
			stmt.EndLocation = t.Location;
		}
	.)
.

/* 10.2 */
LocalDeclarationStatement<out Statement statement>
	(.
		ModifierList m = new ModifierList();
		LocalVariableDeclaration localVariableDeclaration;
		bool dimfound = false;
	.) =
	/* this differs from the spec: dim static x	compiles with vbc. */
	{
		"Const" 	(. m.Add(Modifiers.Const, t.Location); .)
		| "Static"	(. m.Add(Modifiers.Static, t.Location); .)
		| "Dim"		(. dimfound = true; .)
	}
	(.
		if(dimfound && (m.Modifier & Modifiers.Const) != 0) {
			Error("Dim is not allowed on constants.");
		}
		
		if(m.isNone && dimfound == false) {
			Error("Const, Dim or Static expected");
		}
		
		localVariableDeclaration = new LocalVariableDeclaration(m.Modifier);
		localVariableDeclaration.StartLocation = t.Location;
	.)
	VariableDeclarator<localVariableDeclaration.Variables>
	{ "," VariableDeclarator<localVariableDeclaration.Variables> }
	(.
		statement = localVariableDeclaration;
	.)
.

EmbeddedStatement<out Statement statement>
	(.
		Statement embeddedStatement = null;
		statement = null;
		Expression expr = null;
		string name = String.Empty;
		List<Expression> p = null;
		Location startLocation = la.Location;
	.) =
	(
		"Exit"				(. ExitType exitType = ExitType.None; .)
		(
		"Sub"				(. exitType = ExitType.Sub; .)
		|
		"Function"			(. exitType = ExitType.Function; .)
		|
		"Property"			(. exitType = ExitType.Property; .)
		|
		"Do"				(. exitType = ExitType.Do; .)
		|
		"For"				(. exitType = ExitType.For; .)
		|
		"Try"				(. exitType = ExitType.Try; .)
		|
		"While"				(. exitType = ExitType.While; .)
		|
		"Select"			(. exitType = ExitType.Select; .)
		)
	(. statement = new ExitStatement(exitType); .)
	| TryStatement<out statement>
	| "Continue" (. ContinueType continueType = ContinueType.None; .) [ "Do" (. continueType = ContinueType.Do; .) | "For" (. continueType = ContinueType.For; .) | "While" (. continueType = ContinueType.While; .)] (. statement = new ContinueStatement(continueType); .)
	| /* 10.10.1.3 */
	"Throw" [ Expr<out expr> ]				(. statement = new ThrowStatement(expr); .)
	| /* 10.11 */
	"Return" [ Expr<out expr> ] 			(. statement = new ReturnStatement(expr); .)
	| /* 10.4 */
	"SyncLock" Expr<out expr> EndOfStmt Block<out embeddedStatement>
	"End" "SyncLock" 						(. statement = new LockStatement(expr, embeddedStatement); .)
	| /* 10.5.1 */
	"RaiseEvent" Identifier (. name = t.val; .)
	[ "(" [ ArgumentList<out p> ] ")" ]
	(.
		statement = new RaiseEventStatement(name, p);
	.)
	| /* 10.3 */
	WithStatement<out statement>
	| /* 10.5.2 */
	"AddHandler" (. Expression handlerExpr = null; .)
	Expr<out expr> "," Expr<out handlerExpr>
	(.
		statement = new AddHandlerStatement(expr, handlerExpr);
	.)
	| /* 10.5.2 */
	"RemoveHandler" (. Expression handlerExpr = null; .)
	Expr<out expr> "," Expr<out handlerExpr>
	(.
		statement = new RemoveHandlerStatement(expr, handlerExpr);
	.)
	| /* 10.9.1 */
	"While" Expr<out expr> EndOfStmt
	Block<out embeddedStatement> "End" "While"
	(.
		statement = new DoLoopStatement(expr, embeddedStatement, ConditionType.While, ConditionPosition.Start);
	.)
	| /* 10.9.1 */
	"Do"
	(.
		ConditionType conditionType = ConditionType.None;
	.)
	(
		WhileOrUntil<out conditionType> Expr<out expr> EndOfStmt
		Block<out embeddedStatement>
		"Loop"
		(.
			statement = new DoLoopStatement(expr, 
			                                embeddedStatement, 
			                                conditionType == ConditionType.While ? ConditionType.DoWhile : conditionType, 
			                                ConditionPosition.Start);
		.)
		|
		EndOfStmt
		Block<out embeddedStatement>
		"Loop" [WhileOrUntil<out conditionType> Expr<out expr>]
		(.
			statement = new DoLoopStatement(expr, embeddedStatement, conditionType, ConditionPosition.End);
		.)
	)
	| "For"
	(.
			Expression group = null;
			TypeReference typeReference;
			string        typeName;
	.)
	(
		/* 10.9.3  */
 		"Each" LoopControlVariable<out typeReference, out typeName>
		"In" Expr<out group> EndOfStmt
		Block<out embeddedStatement>
		"Next" [ Expr<out expr> ]
		(.
			statement = new ForeachStatement(typeReference, 
			                                 typeName,
			                                 group, 
			                                 embeddedStatement, 
			                                 expr);
			statement.StartLocation = startLocation;
			statement.EndLocation   = t.EndLocation;
			
		.)
		| /* 10.9.2 */
		(.
			Expression start = null;
			Expression end = null;
			Expression step = null;
			Expression variableExpr = null;
			Expression nextExpr = null;
			List<Expression> nextExpressions = null;
		.)
		(	IF (IsLoopVariableDeclaration())
			LoopControlVariable<out typeReference, out typeName>
		|
			(. typeReference = null; typeName = null; .)
			SimpleExpr<out variableExpr>
		)
		"=" Expr<out start> "To" Expr<out end> [ "Step" Expr<out step> ]
		EndOfStmt Block<out embeddedStatement>
		"Next"
		[
			Expr<out nextExpr>
			(.
				nextExpressions = new List<Expression>();
				nextExpressions.Add(nextExpr);
			.)
			{ "," Expr<out nextExpr> (. nextExpressions.Add(nextExpr); .) }
		]
		(.
			statement = new ForNextStatement {
				TypeReference = typeReference,
				VariableName = typeName, 
				LoopVariableExpression = variableExpr,
				Start = start, 
				End = end, 
				Step = step, 
				EmbeddedStatement = embeddedStatement, 
				NextExpressions = nextExpressions
			};
		.)
	)
	| /* 10.10.2.1 */
	"Error" Expr<out expr> 				(. statement = new ErrorStatement(expr); .)
	| /* 10.12.1 */
	"ReDim" (. bool isPreserve = false; .) [ "Preserve" (. isPreserve = true; .) ]
	ReDimClause<out expr>
	(.
		ReDimStatement reDimStatement = new ReDimStatement(isPreserve);
		statement = reDimStatement;
		SafeAdd(reDimStatement, reDimStatement.ReDimClauses, expr as InvocationExpression);
	.)
	{ "," ReDimClause<out expr>
		(. SafeAdd(reDimStatement, reDimStatement.ReDimClauses, expr as InvocationExpression); .)
	}
	| /* 10.12.2 */
	"Erase"
	Expr<out expr>
	(.
		EraseStatement eraseStatement = new EraseStatement();
		if (expr != null) { SafeAdd(eraseStatement, eraseStatement.Expressions, expr);}
	.)
	{ "," Expr<out expr> (. if (expr != null) { SafeAdd(eraseStatement, eraseStatement.Expressions, expr); }.) }
	(. statement = eraseStatement; .)
	| /* 10.11 */
	"Stop" (. statement = new StopStatement(); .)
	| /* 10.8.1 */
	IF (la.kind == Tokens.If) 
	"If" (. Location ifStartLocation = t.Location; .) Expr<out expr> [ "Then" ] 
	(	
		/* multiline if statement */
		EndOfStmt Block<out embeddedStatement>
		(.
			IfElseStatement ifStatement = new IfElseStatement(expr, embeddedStatement);
			ifStatement.StartLocation = ifStartLocation;
			Location elseIfStart;
		.)
		{
			(
				IF(IsElseIf()) "Else" (. elseIfStart = t.Location; .)  "If"
				| "ElseIf" (. elseIfStart = t.Location; .)
			)
			(. Expression condition = null; Statement block = null; .)
			Expr<out condition> [ "Then"] EndOfStmt
			Block<out block>
			(.
				ElseIfSection elseIfSection = new ElseIfSection(condition, block);
				elseIfSection.StartLocation = elseIfStart;
				elseIfSection.EndLocation = t.Location;
				elseIfSection.Parent = ifStatement;
				ifStatement.ElseIfSections.Add(elseIfSection);
			.)
		}
		[
			"Else" [EndOfStmt]
			Block<out embeddedStatement>
			(.
				ifStatement.FalseStatement.Add(embeddedStatement);
			.)
		] "End" "If"
		(.
			ifStatement.EndLocation = t.Location;
			statement = ifStatement;
		.)
	|	/* singleline if statement */
		(.
			IfElseStatement ifStatement = new IfElseStatement(expr);
			ifStatement.StartLocation = ifStartLocation;
		.)
		SingleLineStatementList<ifStatement.TrueStatement>
		[
			"Else"
			[ SingleLineStatementList<ifStatement.FalseStatement> ]
		]
		(. ifStatement.EndLocation = t.Location; statement = ifStatement; .)
	)
	| /* 10.8.2 */
	"Select" [ "Case" ] Expr<out expr> EndOfStmt
	(.List<SwitchSection> selectSections = new List<SwitchSection>();
		Statement block = null;
	.)
	{
		(.List<CaseLabel> caseClauses = null; Location caseLocation = la.Location; .)
		"Case" CaseClauses<out caseClauses> [ IF(IsNotStatementSeparator()) ":" ] EndOfStmt
		(.
			SwitchSection selectSection = new SwitchSection(caseClauses);
			selectSection.StartLocation = caseLocation;
		.)
		Block<out block>
		(.
			selectSection.Children = block.Children;
			selectSection.EndLocation = t.EndLocation;
			selectSections.Add(selectSection);
		.)
	}
	(.
		statement = new SwitchStatement(expr, selectSections);
	.)
	"End" "Select"
	| (. OnErrorStatement onErrorStatement = null; .)
	OnErrorStatement<out onErrorStatement> (. statement = onErrorStatement; .)
	| (. GotoStatement goToStatement = null; .)
	GotoStatement<out goToStatement> (. statement = goToStatement; .)
	| (. ResumeStatement resumeStatement = null; .)
	ResumeStatement<out resumeStatement> (. statement = resumeStatement; .)
	|/* Statement expression (invocation and assignment) 10.6.1, 10.6.2, 10.6.3 */
	(.
		Expression val = null;
		AssignmentOperatorType op;
		Location startLoc = la.Location;
		
		bool mustBeAssignment = la.kind == Tokens.Plus  || la.kind == Tokens.Minus ||
		                        la.kind == Tokens.Not   || la.kind == Tokens.Times;
	.)
	SimpleExpr<out expr>
		(
		AssignmentOperator<out op> Expr<out val>
		(.
			expr = new AssignmentExpression(expr, op, val);
			expr.StartLocation = startLoc;
			expr.EndLocation = t.EndLocation;
		.)
		| (. if (mustBeAssignment) Error("error in assignment."); .)
		)
		(.
			// a field reference expression that stands alone is a
			// invocation expression without parantheses and arguments
			if(expr is MemberReferenceExpression || expr is IdentifierExpression) {
				Location endLocation = expr.EndLocation;
				expr = new InvocationExpression(expr);
				expr.StartLocation = startLoc;
				expr.EndLocation = endLocation;
			}
			statement = new ExpressionStatement(expr);
		.)
	| "Call" SimpleExpr<out expr> (. statement = new ExpressionStatement(expr); .)
	| "Using"
		(. Statement block;  .)
		( IF (Peek(1).kind == Tokens.As)
			(. LocalVariableDeclaration resourceAquisition = new LocalVariableDeclaration(Modifiers.None); .)
			VariableDeclarator<resourceAquisition.Variables>
			{ ","
			  VariableDeclarator<resourceAquisition.Variables>
			}
			Block<out block>
			(.
				statement = new UsingStatement(resourceAquisition, block);
			.)
		|	Expr<out expr>
			Block<out block>
			(. statement = new UsingStatement(new ExpressionStatement(expr), block); .)
		)
		"End" "Using"
	| LocalDeclarationStatement<out statement>
)
(.
	if (statement != null) {
		statement.StartLocation = startLocation;
		statement.EndLocation = t.EndLocation;
	}
.)
.

SingleLineStatementList<List<Statement> list>
(. Statement embeddedStatement = null; .)
=
	( "End" (. embeddedStatement = new EndStatement() { StartLocation = t.Location, EndLocation = t.EndLocation }; .)
	| EmbeddedStatement<out embeddedStatement> )
	(. if (embeddedStatement != null) list.Add(embeddedStatement); .)
	{	":" { ":" }
		( "End" (. embeddedStatement = new EndStatement() { StartLocation = t.Location, EndLocation = t.EndLocation }; .)
		| EmbeddedStatement<out embeddedStatement> )
		(. if (embeddedStatement != null) list.Add(embeddedStatement); .)
	}
.

/* 10.9.2 */
LoopControlVariable<out TypeReference type, out string name>
(.ArrayList arrayModifiers = null;
	type = null;
.)
=
	Qualident<out name>
	[ IF(IsDims()) ArrayTypeModifiers<out arrayModifiers> ]
	[ "As" TypeName<out type> (. if (name.IndexOf('.') > 0) { Error("No type def for 'for each' member indexer allowed."); } .) ]
	(.
		if (type != null) {
			if(type.RankSpecifier != null && arrayModifiers != null) {
				Error("array rank only allowed one time");
			} else if (arrayModifiers != null) {
				type.RankSpecifier = (int[])arrayModifiers.ToArray(typeof(int));
			}
		}
	.)
.

/* 10.2.2 */
OnErrorStatement<out OnErrorStatement stmt>
	(.
		stmt = null;
		Location startLocation = la.Location;
		GotoStatement goToStatement = null;
	.)
	=
	"On" "Error"
	(
		IF(IsNegativeLabelName())"GoTo" "-" LiteralInteger
		(.
			long intLabel = Int64.Parse(t.val);
			if(intLabel != 1) {
				Error("invalid label in on error statement.");
			}
			stmt = new OnErrorStatement(new GotoStatement((intLabel * -1).ToString()));
		.)
		| GotoStatement<out goToStatement>
		(.
			string val = goToStatement.Label;
			
			// if value is numeric, make sure that is 0
			try {
				long intLabel = Int64.Parse(val);
				if(intLabel != 0) {
					Error("invalid label in on error statement.");
				}
			} catch {
			}
			stmt = new OnErrorStatement(goToStatement);
		.)
		| "Resume" "Next"
		(.
			stmt = new OnErrorStatement(new ResumeStatement(true));
		.)
	)
	(.
		if (stmt != null) {
			stmt.StartLocation = startLocation;
			stmt.EndLocation = t.EndLocation;
		}
	.)
	.

/* 10.11 */
GotoStatement<out GotoStatement goToStatement>
	(. string label = String.Empty; Location startLocation = la.Location; .)
	=
	"GoTo" LabelName<out label>
	(.
		goToStatement = new GotoStatement(label) {
			StartLocation = startLocation,
			EndLocation = t.EndLocation
		};
	.)
.

/* 10.1 */
LabelName<out string name>
	(.
		name = String.Empty;
	.) =
	Identifier 				(. name = t.val; .)
	| LiteralInteger	(. name = t.val; .)
	.

/* 12.12.1 */
ReDimClause<out Expression expr>
=
	SimpleNonInvocationExpression<out expr>
	ReDimClauseInternal<ref expr>
.

ReDimClauseInternal<ref Expression expr>
(. List<Expression> arguments; bool canBeNormal; bool canBeRedim; string name; Location startLocation = la.Location; .)
=
	{ "." IdentifierOrKeyword<out name> (. expr = new MemberReferenceExpression(expr, name) { StartLocation = startLocation, EndLocation = t.EndLocation }; .)
	|  IF (la.kind == Tokens.OpenParenthesis && Peek(1).kind == Tokens.Of)
		InvocationExpression<ref expr>
		(.
			expr.StartLocation = startLocation;
			expr.EndLocation = t.EndLocation;
		.)
	}
	"("
	NormalOrReDimArgumentList<out arguments, out canBeNormal, out canBeRedim>
	")"
	(.	expr = new InvocationExpression(expr, arguments);
		if (canBeRedim == false || canBeNormal && (la.kind == Tokens.Dot || la.kind == Tokens.OpenParenthesis)) {
			if (this.Errors.Count == 0) {
				// don't recurse on parse errors - could result in endless recursion
				ReDimClauseInternal(ref expr);
			}
		}
	.)
.

/* 10.10.2.3 */
ResumeStatement<out ResumeStatement resumeStatement>
	(.
		resumeStatement = null;
		string label = String.Empty;
	.) =
	IF(IsResumeNext())
	"Resume" "Next" 					(. resumeStatement = new ResumeStatement(true); .)
	| "Resume" [ LabelName<out label> ]	(. resumeStatement = new ResumeStatement(label); .)
	.

/* 18.8.2 */
CaseClauses<out List<CaseLabel> caseClauses>
	(.
		caseClauses = new List<CaseLabel>();
		CaseLabel caseClause = null;
	.) =
	CaseClause<out caseClause> (. if (caseClause != null) { caseClauses.Add(caseClause); } .)
	{ "," CaseClause<out caseClause> (. if (caseClause != null) { caseClauses.Add(caseClause); } .) }
	.

/* 19.8.2 */
CaseClause<out CaseLabel caseClause>
	(.
		Expression expr = null;
		Expression sexpr = null;
		BinaryOperatorType op = BinaryOperatorType.None;
		caseClause = null;
	.) =
	"Else"
	(. caseClause = new CaseLabel(); .)
	|
	[ "Is" ] 
	(
		"<"		(. op = BinaryOperatorType.LessThan; .)
		| ">"	(. op = BinaryOperatorType.GreaterThan; .)
		| "<="	(. op = BinaryOperatorType.LessThanOrEqual; .)
		| ">="	(. op = BinaryOperatorType.GreaterThanOrEqual; .)
		| "="	(. op = BinaryOperatorType.Equality; .)
		| "<>"	(. op = BinaryOperatorType.InEquality; .)
	)
	Expr<out expr>
	(.
		caseClause = new CaseLabel(op, expr);
	.)
	| Expr<out expr> [ "To" Expr<out sexpr> ]
	(.
		caseClause = new CaseLabel(expr, sexpr);
	.)
	.

/* 10.9.1 */
WhileOrUntil<out ConditionType conditionType>
	(. conditionType = ConditionType.None; .) =
	"While"		(. conditionType = ConditionType.While; .)
	| "Until"	(. conditionType = ConditionType.Until; .)
	.

/* 10.3 */
WithStatement<out Statement withStatement>
	(.
		Statement blockStmt = null;
		Expression expr = null;
	.) =
	"With" (. Location start = t.Location; .)
	Expr<out expr> EndOfStmt
	(.
		withStatement = new WithStatement(expr);
		withStatement.StartLocation = start;
	.)
	Block<out blockStmt>
	(.
		((WithStatement)withStatement).Body = (BlockStatement)blockStmt;
	.)
	"End" "With"
	(. withStatement.EndLocation = t.Location; .)
	.
	
/* 10.10.1 */
TryStatement<out Statement tryStatement>
	(.
		Statement blockStmt = null, finallyStmt = null;List<CatchClause> catchClauses = null;
	.) =
	"Try" EndOfStmt
	Block<out blockStmt>
	[CatchClauses<out catchClauses>]
	["Finally" EndOfStmt Block<out finallyStmt> ]
	"End" "Try"
	(.
		tryStatement = new TryCatchStatement(blockStmt, catchClauses, finallyStmt);
	.)
	.

/* 10.10.1.2 */
CatchClauses<out List<CatchClause> catchClauses>
	(.
		catchClauses = new List<CatchClause>();
		TypeReference type = null;
		Statement blockStmt = null;
		Expression expr = null;
		string name = String.Empty;
	.) =
	{
		"Catch"
		[ Identifier (. name = t.val; .) ["As" TypeName<out type>] ]
		[ "When" Expr<out expr> ]
		EndOfStmt
		Block<out blockStmt>
		(. catchClauses.Add(new CatchClause(type, name, blockStmt, expr)); .)
	}
	.

/* 4.7 */
Qualident<out string qualident>
(. 
	string name;
	qualidentBuilder.Length = 0; 
.)
=
	Identifier	(. qualidentBuilder.Append(t.val); .)
	{ IF (DotAndIdentOrKw()) "." IdentifierOrKeyword<out name> (. qualidentBuilder.Append('.'); qualidentBuilder.Append(name); .) }
	
	(. qualident = qualidentBuilder.ToString(); .)
.

/* This production handles pseudo keywords that are needed in the grammar */
Identifier	=
	IdentifierForFieldDeclaration
	| "Custom" 
.

IdentifierForFieldDeclaration =
	ident
	| "Aggregate"
	| "Ansi"
	| "Ascending"
	| "Assembly"
	| "Auto"
	| "Binary"
	| "By"
	| "Compare"
	| "Descending"
	| "Distinct"
	| "Equals"
	| "Explicit"
	| "From"
	| "Group"
	| "Infer"
	| "Into"
	| "Join"
	| "Key"
	| "Off"
	| "Order"
	| "Out"
	| "Preserve"
	| "Skip"
	| "Take"
	| "Text"
	| "Unicode"
	| "Until"
	| "Where"
.

/* 2.2 */

IdentifierOrKeyword<out string name>
=
	ANY (. name = t.val;  .)
.


/* 7.3 */
PrimitiveTypeName<out string type>
	(. type = String.Empty; .) =
	"Boolean"		(. type = "System.Boolean"; .)
	| "Date"		(. type = "System.DateTime"; .)
	| "Char"		(. type = "System.Char"; .)
	| "String"		(. type = "System.String"; .)
	| "Decimal"		(. type = "System.Decimal"; .)
	| "Byte"		(. type = "System.Byte"; .)
	| "Short"		(. type = "System.Int16"; .)
	| "Integer"		(. type = "System.Int32"; .)
	| "Long"		(. type = "System.Int64"; .)
	| "Single"		(. type = "System.Single"; .)
	| "Double"		(. type = "System.Double"; .)
	| "UInteger"	(. type = "System.UInt32"; .)
	| "ULong"		(. type = "System.UInt64"; .)
	| "UShort"		(. type = "System.UInt16"; .)
	| "SByte"		(. type = "System.SByte"; .)
	.

ParameterModifier<ParamModifierList m>
	= "ByVal"			(. m.Add(ParameterModifiers.In); .)
	| "ByRef"			(. m.Add(ParameterModifiers.Ref); .)
	| "Optional"		(. m.Add(ParameterModifiers.Optional); .)
	| "ParamArray"		(. m.Add(ParameterModifiers.Params); .)
	.

TypeModifier<ModifierList m>
=	  "Public"			(. m.Add(Modifiers.Public, t.Location); .)
	| "Protected"		(. m.Add(Modifiers.Protected, t.Location); .)
	| "Friend"			(. m.Add(Modifiers.Internal, t.Location); .)
	| "Private"			(. m.Add(Modifiers.Private, t.Location); .)
	| "Shared"			(. m.Add(Modifiers.Static, t.Location); .)
	| "Shadows"			(. m.Add(Modifiers.New, t.Location); .)
	| "MustInherit"		(. m.Add(Modifiers.Abstract, t.Location); .)
	| "NotInheritable"	(. m.Add(Modifiers.Sealed, t.Location); .)
	| "Partial"			(. m.Add(Modifiers.Partial, t.Location); .)
.

MemberModifier<ModifierList m> =
	  "MustInherit"		(.m.Add(Modifiers.Abstract, t.Location);.)
	| "Default"			(.m.Add(Modifiers.Default, t.Location);.)
	| "Friend"			(.m.Add(Modifiers.Internal, t.Location);.)
	| "Shadows"			(.m.Add(Modifiers.New, t.Location);.)
	| "Overrides"		(.m.Add(Modifiers.Override, t.Location);.)
	| "MustOverride"	(.m.Add(Modifiers.Abstract, t.Location);.)
	| "Private"			(.m.Add(Modifiers.Private, t.Location);.)
	| "Protected"		(.m.Add(Modifiers.Protected, t.Location);.)
	| "Public"			(.m.Add(Modifiers.Public, t.Location);.)
	| "NotInheritable"	(.m.Add(Modifiers.Sealed, t.Location);.)
	| "NotOverridable"	(.m.Add(Modifiers.Sealed, t.Location);.)
	| "Shared"			(.m.Add(Modifiers.Static, t.Location);.)
	| "Overridable"		(.m.Add(Modifiers.Virtual, t.Location);.)
	| "Overloads"		(.m.Add(Modifiers.Overloads, t.Location);.)
	| "ReadOnly"		(.m.Add(Modifiers.ReadOnly, t.Location);.)
	| "WriteOnly"		(.m.Add(Modifiers.WriteOnly, t.Location);.)
	| "WithEvents"		(.m.Add(Modifiers.WithEvents, t.Location);.)
	| "Dim"				(.m.Add(Modifiers.Dim, t.Location);.)
	| "Partial"			(.m.Add(Modifiers.Partial, t.Location);.)
.

PropertyAccessorAccessModifier<out Modifiers m> =
	(. m = Modifiers.None; .)
	{(
		"Public"    (. m |= Modifiers.Public; .)
	 |  "Protected" (. m |= Modifiers.Protected; .)
	 |  "Friend"    (. m |= Modifiers.Internal; .)
	 |  "Private"   (. m |= Modifiers.Private; .)
	)}
.

END VBNET.
